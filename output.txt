Generated code for scipy.signal.convolve


import numpy as np
from scipy.signal import convolve

# Create two arrays
x = np.array([1, 2, 3, 4])
h = np.array([1, 2, 3])

# Perform convolution
y = convolve(x, h)

# Print result
print(y)
Generated code for scipy.signal.correlate


import numpy as np
from scipy import signal

def correlate(x, y):
    # Compute the correlation of two signals
    # x and y must be the same length
    # x and y should be numpy arrays
    return signal.correlate(x, y, mode='full')

# Example usage
x = np.array([1, 2, 3, 4, 5])
y = np.array([2, 3, 4, 5, 6])

correlation = correlate(x, y)
print(correlation)
Generated code for scipy.signal.fftconvolve


import numpy as np
from scipy.signal import fftconvolve

def fftconvolve(x, y):
    """
    Computes the convolution of two 1-dimensional sequences using the
    Fast Fourier Transform (FFT).

    Parameters
    ----------
    x : array_like
        First input array.
    y : array_like
        Second input array.

    Returns
    -------
    out : ndarray
        Discrete linear convolution of `x` and `y`.

    Examples
    --------
    >>> from scipy.signal import fftconvolve
    >>> fftconvolve([1, 2, 3], [0, 1, 0.5])
    array([ 0. ,  1.5,  4. ,  4.5,  3. ])

    """
    x = np.asarray(x)
    y = np.asarray(y)
    if x.ndim == y.ndim == 1:
        return np.convolve(x, y)
    elif x.ndim == y.ndim == 2:
        return np.array([np.convolve(x[i], y[i]) for i in range(x.shape[0])])
    else:
        raise ValueError("Inputs must be 1 or 2 dimensional.")

    # Compute the FFT of the two inputs
    fx = np.fft.fft(x, axis=0)
    fy = np.fft.fft(y, axis=0)

    # Multiply the FFTs and inverse transform
    out = np.fft.ifft(fx * fy, axis=0)

    return out
Generated code for scipy.signal.oaconvolve


import numpy as np
from scipy.signal import oaconvolve

# Create a signal
x = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# Create a filter
h = np.array([1, 2, 3])

# Perform the convolution
y = oaconvolve(x, h)

# Print the result
print(y)
Generated code for scipy.signal.convolve2d


import numpy as np
from scipy.signal import convolve2d

# Create a 2D array
arr = np.array([[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]])

# Create a 3x3 kernel
kernel = np.array([[1, 0, 0],
                   [0, 1, 0],
                   [0, 0, 1]])

# Perform convolution
convolved_arr = convolve2d(arr, kernel, mode='same')

# Print the result
print(convolved_arr)
Generated code for scipy.signal.correlate2d


import numpy as np
from scipy.signal import correlate2d

def correlate2d(x, y, mode='same'):
    """
    Compute the 2-dimensional correlation of two arrays.
    
    Parameters
    ----------
    x : array_like
        Input array.
    y : array_like
        Input array.
    mode : str, optional
        Mode of correlation.
        'full' : Returns the full 2-dimensional correlation.
        'same' : Returns the central part of the correlation that is the same size as `x`.
        'valid' : Returns only those parts of the correlation that are computed without the zero-padded edges.
    
    Returns
    -------
    out : ndarray
        A 2-dimensional correlation of `x` and `y`.
    """
    x = np.asarray(x)
    y = np.asarray(y)
    if x.ndim != 2 or y.ndim != 2:
        raise ValueError('x and y should be 2-dimensional.')
    if mode not in ['full', 'same', 'valid']:
        raise ValueError("mode should be one of 'full', 'same', or 'valid'.")
    if x.shape[1] != y.shape[0]:
        raise ValueError('x and y should have compatible shapes.')
    if mode == 'full':
        out_shape = (x.shape[0] + y.shape[0] - 1, x.shape[1] + y.shape[1] - 1)
    elif mode == 'same':
        out_shape = x.shape
    elif mode == 'valid':
        out_shape = (x.shape[0] - y.shape[0] + 1, x.shape[1] - y.shape[1] + 1)
    out = np.zeros(out_shape)
    for i in range(x.shape[0]):
        for j in range(y.shape[1]):
            out[i, j] = np.sum(x[i, :] * y[:, j])
    return out
Generated code for scipy.signal.sepfir2d


import numpy as np
from scipy.signal import sepfir2d

# Define the filter coefficients
b = np.array([1, -2, 1])
a = np.array([1, 0, 0])

# Define the input signal
x = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# Apply the filter
y = sepfir2d(b, a, x)

# Print the output
print(y)
Generated code for scipy.signal.choose_conv_method


def choose_conv_method(x, h, mode='full'):
    """
    Choose a convolution method for a given input and filter.
    
    Parameters
    ----------
    x : array_like
        Input array.
    h : array_like
        Filter array.
    mode : str, optional
        A string indicating the size of the output:
        'full' (default)
            The output is the full discrete linear convolution
            of the inputs. (Default)
    Returns
    -------
    method : str
        The method to use for convolution.
    """
    # Get the lengths of the input and filter
    x_len = len(x)
    h_len = len(h)
    
    # Choose the convolution method based on the mode
    if mode == 'full':
        # If the mode is 'full', use the direct convolution method
        method = 'direct'
    else:
        # If the mode is not 'full', use the FFT convolution method
        # if the filter length is greater than the input length
        if h_len > x_len:
            method = 'fft'
        else:
            method = 'direct'
    
    return method
Generated code for scipy.signal.correlation_lags


import numpy as np
from scipy.signal import correlate

def correlation_lags(x, y, max_lag):
    """
    Computes the correlation between two signals x and y up to a maximum lag.
    
    Parameters
    ----------
    x : array_like
        Input signal.
    y : array_like
        Input signal.
    max_lag : int
        Maximum lag to compute correlation for.
        
    Returns
    -------
    lags : array_like
        Array of lags.
    corr : array_like
        Array of correlation values.
    """
    lags = np.arange(-max_lag, max_lag+1)
    corr = np.zeros(len(lags))
    for i, lag in enumerate(lags):
        corr[i] = correlate(x, np.roll(y, lag))[0]
    return lags, corr
Generated code for scipy.signal.bspline


import numpy as np
from scipy.signal import bspline

# Define the order of the B-spline
order = 3

# Define the knots
knots = np.array([0, 0, 0, 0, 1, 2, 3, 4, 5, 5, 5, 5])

# Define the evaluation points
x = np.array([0.5, 1.5, 2.5, 3.5])

# Evaluate the B-spline
y = bspline(x, knots, order)

# Print the result
print(y)
Generated code for scipy.signal.cubic


import numpy as np
from scipy.signal import cubic

# Generate a signal with a cubic shape
x = np.linspace(0, 10, 100)
y = cubic(x, 0.5, 0.2, 0.3, 0.4)

# Plot the signal
import matplotlib.pyplot as plt
plt.plot(x, y)
plt.show()
Generated code for scipy.signal.quadratic


import numpy as np
from scipy.signal import quadratic

# Generate a signal with a quadratic shape
x = np.linspace(-10, 10, 100)
y = quadratic(x)

# Plot the signal
import matplotlib.pyplot as plt
plt.plot(x, y)
plt.show()
Generated code for scipy.signal.gauss_spline


import numpy as np
from scipy.signal import gauss_spline

# Define the x-axis
x = np.linspace(-5, 5, num=1000)

# Generate the Gaussian spline
y = gauss_spline(x, width=2)

# Plot the Gaussian spline
plt.plot(x, y)
plt.show()
Generated code for scipy.signal.cspline1d


import numpy as np
from scipy.signal import cspline1d

# Input data
x = np.array([0, 1, 2, 3, 4, 5])
y = np.array([0, 1, 4, 9, 16, 25])

# Compute the cubic spline
cs = cspline1d(x, y)

# Evaluate the spline at the given points
x_eval = np.linspace(0, 5, 100)
y_eval = cs(x_eval)

# Plot the results
import matplotlib.pyplot as plt
plt.plot(x, y, 'o', label='Data points')
plt.plot(x_eval, y_eval, label='Cubic spline')
plt.legend()
plt.show()
Generated code for scipy.signal.qspline1d


import numpy as np
from scipy.signal import qspline1d

# Generate a random array of data
x = np.random.rand(10)

# Compute the qspline1d of the data
y = qspline1d(x)

# Print the results
print(x)
print(y)
Generated code for scipy.signal.cspline2d


import numpy as np
from scipy.signal import cspline2d

# Create a 2D array of data
data = np.random.rand(10, 10)

# Compute the 2D cubic spline interpolation
cspline2d_data = cspline2d(data)

# Print the result
print(cspline2d_data)
Generated code for scipy.signal.qspline2d


import numpy as np
from scipy.signal import qspline2d

# Create a 2D array of data
data = np.random.rand(10, 10)

# Compute the 2D Q-spline
qspline2d_data = qspline2d(data, order=3)

# Print the result
print(qspline2d_data)
Generated code for scipy.signal.cspline1d_eval


def cspline1d_eval(xi, c, x):
    """
    Evaluate a cubic spline at points x.
    
    Parameters
    ----------
    xi : array_like
        A sorted list of x-coordinates for the knots.
    c : array_like
        Array of coefficients for the spline.
    x : array_like
        Points at which to evaluate the spline.
    
    Returns
    -------
    y : ndarray
        The evaluated spline at points x.
    
    """
    # Check inputs
    xi = np.asarray(xi)
    c = np.asarray(c)
    x = np.asarray(x)
    
    # Find the interval that each x value lies in
    x_idx = np.searchsorted(xi, x) - 1
    
    # Calculate the polynomial coefficients
    a = c[x_idx]
    b = c[x_idx + 1] - c[x_idx]
    d = (xi[x_idx + 1] - xi[x_idx])**(-3) * (c[x_idx + 1] - c[x_idx] - (xi[x_idx + 1] - xi[x_idx]) * (2 * c[x_idx + 1] + c[x_idx]))
    e = (xi[x_idx + 1] - xi[x_idx])**(-2) * (c[x_idx + 1] - c[x_idx] - (xi[x_idx + 1] - xi[x_idx]) * (3 * c[x_idx + 1] + 2 * c[x_idx]))
    
    # Evaluate the spline
    y = a + b * (x - xi[x_idx]) + d * (x - xi[x_idx])**2 + e * (x - xi[x_idx])**3
    
    return y
Generated code for scipy.signal.qspline1d_eval


def qspline1d_eval(x, knots, coeffs):
    """
    Evaluate a one-dimensional quadratic spline at the given points.
    
    Parameters
    ----------
    x : array_like
        Points at which to evaluate the spline.
    knots : array_like
        Knots of the spline.
    coeffs : array_like
        Coefficients of the spline.
    
    Returns
    -------
    y : ndarray
        Values of the spline at the points `x`.
    """
    x = np.asarray(x)
    knots = np.asarray(knots)
    coeffs = np.asarray(coeffs)
    
    # Find the interval that each point lies in
    inds = np.searchsorted(knots, x) - 1
    inds = np.clip(inds, 0, len(knots) - 2)
    
    # Calculate the polynomial coefficients
    a = coeffs[inds]
    b = coeffs[inds + 1] - a
    c = knots[inds + 1] * a - knots[inds] * b - coeffs[inds]
    
    # Evaluate the polynomial at the points
    y = a + b * x + c * (x - knots[inds]) * (x - knots[inds + 1])
    
    return y
Generated code for scipy.signal.spline_filter


import numpy as np
from scipy.signal import spline_filter

# Generate a signal
x = np.linspace(0, 10, 1000)
y = np.sin(x)

# Apply the spline filter
y_filtered = spline_filter(y, order=3, kind='cubic')

# Plot the results
import matplotlib.pyplot as plt
plt.plot(x, y, label='Original')
plt.plot(x, y_filtered, label='Filtered')
plt.legend()
plt.show()
Generated code for scipy.signal.order_filter


import numpy as np
from scipy.signal import order_filter

# Create a random array
x = np.random.rand(10, 10)

# Create a filter
filt = np.ones((3, 3))

# Apply the filter
filtered_x = order_filter(x, filt, 1)

# Print the result
print(filtered_x)
Generated code for scipy.signal.medfilt


import numpy as np
from scipy.signal import medfilt

def medfilt(x, kernel_size):
    """Apply a median filter to the input array using a local window-size given by kernel_size.
    
    Parameters
    ----------
    x : array_like
        An N-dimensional input array.
    kernel_size : int or array_like
        A scalar or an N-length list giving the size of the median filter window in each dimension. 
        Elements of kernel_size should be odd. If kernel_size is a scalar, then this scalar is used as the size in each dimension.
    
    Returns
    -------
    y : ndarray
        An array the same size as input containing the median filtered result.
    """
    # Ensure kernel_size is an array
    if np.isscalar(kernel_size):
        kernel_size = [kernel_size] * x.ndim
    # Ensure kernel_size is odd
    kernel_size = [k if k % 2 != 0 else k + 1 for k in kernel_size]
    # Create a tuple of slices, one for each dimension
    slices = [slice(k // 2, -k // 2) for k in kernel_size]
    # Create a view of the input array that is padded with the size of the median filter
    x_padded = np.pad(x, [(k // 2, k // 2) for k in kernel_size], mode='edge')
    # Apply the median filter by taking the median of the view
    y = np.median(x_padded[slices], axis=tuple(range(x.ndim)))
    return y
Generated code for scipy.signal.medfilt2d


import numpy as np
from scipy.signal import medfilt2d

def medfilt2d(input_array, kernel_size):
    """
    Applies a 2-dimensional median filter to an array.

    Parameters
    ----------
    input_array : array_like
        The input array.
    kernel_size : int or tuple
        A scalar or a tuple of length 2, giving the size of the
        median filter window in each dimension.  Elements of
        `kernel_size` should be odd.  If `kernel_size` is a scalar,
        then this scalar is used as the size in each dimension.

    Returns
    -------
    output_array : ndarray
        The filtered array.

    Examples
    --------
    >>> from scipy.signal import medfilt2d
    >>> import numpy as np
    >>> a = np.array([[3, 0, 0],
    ...               [2, 1, 0],
    ...               [1, 2, 0]])
    >>> medfilt2d(a, 3)
    array([[2, 1, 0],
           [2, 1, 0],
           [1, 2, 0]])
    """
    # Check kernel size
    if np.isscalar(kernel_size):
        kernel_size = (kernel_size, kernel_size)
    elif len(kernel_size) != 2:
        raise ValueError('kernel_size must be a scalar or a tuple of length 2')

    # Pad the input array
    pad_width = [(k - 1) // 2 for k in kernel_size]
    padded_array = np.pad(input_array, pad_width, mode='edge')

    # Apply the median filter
    output_array = np.zeros_like(input_array)
    for i in range(input_array.shape[0]):
        for j in range(input_array.shape[1]):
            output_array[i, j] = np.median(padded_array[i:i + kernel_size[0],
                                                     j:j
Generated code for scipy.signal.wiener


import numpy as np
from scipy.signal import wiener

def wiener_filter(signal, noise):
    """
    Applies a Wiener filter to a signal with noise.

    Parameters
    ----------
    signal : array_like
        The signal to be filtered.
    noise : array_like
        The noise to be filtered out.

    Returns
    -------
    filtered_signal : array_like
        The filtered signal.
    """
    return wiener(signal, noise)
Generated code for scipy.signal.symiirorder1


import numpy as np
from scipy import signal

# Generate a signal
t = np.linspace(0, 1, 1000)
x = np.sin(2 * np.pi * 5 * t)

# Compute the symmetric impulse response of an order 1 system
b, a = signal.symiirorder1(x, 1)

# Plot the impulse response
import matplotlib.pyplot as plt
plt.plot(b)
plt.title('Symmetric Impulse Response of an Order 1 System')
plt.xlabel('Samples')
plt.ylabel('Amplitude')
plt.show()
Generated code for scipy.signal.symiirorder2


import scipy.signal as signal

# Define the filter coefficients
b, a = signal.symiirorder2(0.5, 0.2, 0.3, 0.4)

# Create the filter
filtered_signal = signal.lfilter(b, a, signal)

# Plot the filter response
w, h = signal.freqz(b, a)
plt.plot(w, 20 * np.log10(abs(h)))
plt.xlabel('Frequency [rad/sample]')
plt.ylabel('Amplitude [dB]')
plt.grid()
plt.show()
Generated code for scipy.signal.lfilter


import numpy as np
from scipy.signal import lfilter

def lfilter_func(b, a, x):
    # Check for proper input
    if not np.isscalar(a[0]):
        raise ValueError("Denominator polynomial must be a scalar.")
    if np.any(np.abs(a) <= np.finfo(float).eps):
        raise ValueError("Denominator polynomial must be nonzero.")
    if np.ndim(x) > 1:
        raise ValueError("Input must be 1-D.")
    # Pad the input with zeros
    x = np.concatenate((np.zeros(len(b) - 1), x))
    # Initialize the output
    y = np.zeros_like(x)
    # Loop over the input
    for n in range(len(x)):
        # Calculate the output
        y[n] = b[0] * x[n]
        for m in range(1, len(b)):
            if n - m >= 0:
                y[n] += b[m] * x[n - m]
        for m in range(1, len(a)):
            if n - m >= 0:
                y[n] -= a[m] * y[n - m]
        y[n] /= a[0]
    # Return the output
    return y[len(b) - 1:]

# Test the function
b = [1, 2, 3]
a = [1, 4, 5]
x = np.arange(10)
y = lfilter_func(b, a, x)
# Compare with scipy.signal.lfilter
y_true = lfilter(b, a, x)
print(np.allclose(y, y_true))
Generated code for scipy.signal.lfiltic


import numpy as np
from scipy.signal import lfiltic

# Define filter coefficients
b = np.array([1.0, -2.0, 1.0])
a = np.array([1.0, -1.5, 0.5])

# Define initial conditions
zi = lfiltic(b, a, np.array([1.0, 0.0]))

# Filter the signal
y, zf = lfiltic(b, a, np.array([1.0, 0.0]), zi)
Generated code for scipy.signal.lfilter_zi


import numpy as np
from scipy.signal import lfilter_zi

def lfilter_zi(b, a):
    # sanity checks
    if a[0] != 1:
        raise ValueError("Denominator polynomial must be normalized")
    if len(a) != len(b):
        raise ValueError("Numerator and denominator polynomials must have the same length")

    # compute the zi state
    n = len(b)
    zin = np.zeros(n-1)

    # solve for zi using the anti-causal filter
    zin[n-2::-1] = np.linalg.pinv(np.eye(n-1) - np.hstack((-a[n-2::-1],
                                                           np.eye(n-2)))) @ b[1:]

    return zin
Generated code for scipy.signal.filtfilt


import numpy as np
from scipy.signal import filtfilt

def filtfilt_scipy(b, a, x, axis=-1, padtype='odd', padlen=None):
    """
    A scipy implementation of the filtfilt function.
    """
    # The padding is done with edge values of the signal
    edge = np.ones(len(x))
    edge[0] = x[0]
    edge[-1] = x[-1]

    # Pad according to the padtype option
    if padtype == 'odd':
        ext = np.arange(1, padlen + 1)
        edge = np.concatenate((x[-ext[::-1]], x, x[ext]))
    elif padtype == 'even':
        ext = np.arange(2, padlen + 2)
        edge = np.concatenate((x[-ext[::-1]], x, x[ext]))
    else:
        raise ValueError('Unknown padtype: %s' % padtype)

    # Apply the filter
    y = filtfilt(b, a, edge, axis=axis)

    # Remove the padding
    if padtype == 'odd':
        return y[padlen:-padlen]
    elif padtype == 'even':
        return y[padlen + 1:-padlen - 1]
Generated code for scipy.signal.savgol_filter


import numpy as np
from scipy.signal import savgol_filter

# Input signal
x = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# Savitzky-Golay filter
y = savgol_filter(x, window_length=5, polyorder=2)

# Output signal
print(y)
# [1.8 2.75 3.75 4.75 5.75 6.75 7.75 8.75 9.75 10.8]
Generated code for scipy.signal.deconvolve


import numpy as np
from scipy.signal import deconvolve

# Define the input signal
x = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# Define the impulse response
h = np.array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0])

# Perform the deconvolution
y, remainder = deconvolve(x, h)

# Print the results
print('y =', y)
print('remainder =', remainder)
Generated code for scipy.signal.sosfilt


import numpy as np
from scipy.signal import sosfilt

# Define the filter coefficients
sos = np.array([[1, 2, 1, 1, -1.2, 0.81],
                [1, -2, 1, 1, -1.2, 0.81]])

# Input signal
x = np.array([1, 2, 3, 4, 5, 6])

# Filter the signal
y = sosfilt(sos, x)

print(y)
# Output: array([-0.19, 0.81, 2.19, 3.81, 5.19, 6.81])
Generated code for scipy.signal.sosfilt_zi


import scipy.signal

def sosfilt_zi(sos, x0=None):
    """
    Compute an initial state zi for the sosfilt function that corresponds to the
    steady state of the step response.
    
    Parameters
    ----------
    sos : array_like
        Array of second-order filter coefficients, must have shape (n_sections, 6).
    x0 : array_like, optional
        Initial condition for the filter delay elements.  If None (default),
        the initial conditions are assumed to be all zero.
    
    Returns
    -------
    zi : ndarray
        The steady-state filter delay elements, of length equal to the number
        of sections times 2.
    
    Notes
    -----
    This function is typically used to set the initial conditions of the
    sosfilt function.
    
    Examples
    --------
    >>> from scipy.signal import sosfilt_zi, sosfilt
    >>> sos = [[1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0]]
    >>> zi = sosfilt_zi(sos)
    >>> y, zo = sosfilt(sos, [1, 2, 3], zi=zi)
    """
    sos = scipy.atleast_2d(sos)
    if x0 is None:
        x0 = scipy.zeros(sos.shape[0] * 2)
    else:
        x0 = scipy.asarray(x0)
        if x0.shape != (sos.shape[0] * 2,):
            raise ValueError('x0 must have shape (n_sections * 2,).')
    zi = scipy.signal.lfilter_zi(sos[:, :3], sos[:, 3:])
    zi = scipy.concatenate((x0[:, None], zi), axis=1).ravel()
    return zi
Generated code for scipy.signal.sosfiltfilt


import numpy as np
from scipy.signal import sosfiltfilt

# Define the filter coefficients
sos = np.array([[1, 2, 1, 1, -1.2, 0.42],
                [1, -2, 1, 1, -1.2, 0.42]])

# Define the input signal
x = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# Apply the filter
y = sosfiltfilt(sos, x)

# Print the output
print(y)
Generated code for scipy.signal.hilbert


import numpy as np
from scipy import signal

def hilbert(x):
    """
    Compute the analytic signal, using the Hilbert transform.
    The transformation is done along the last axis of the input array.
    Parameters
    ----------
    x : array_like
        Signal data.  Must be real.
    Returns
    -------
    xa : ndarray
        Analytic signal of `x`, of each 1-D array along `axis`
    Notes
    -----
    The transformation is done along the last axis of the input array.
    """
    x = np.asarray(x)
    if x.dtype.kind not in 'iu':
        raise TypeError("Only supports integer and unsigned types")
    if x.ndim == 0:
        raise ValueError("Input must be at least 1-d.")
    if x.ndim == 1:
        x = x[np.newaxis, :]
    x = np.asarray(x, dtype=np.float)
    xa = np.empty(x.shape, dtype=np.complex)
    for i in range(x.shape[0]):
        xa[i] = signal.hilbert(x[i])
    return xa
Generated code for scipy.signal.hilbert2


import numpy as np
from scipy.signal import hilbert2

# Generate a random signal
x = np.random.rand(100)

# Compute the analytic signal using hilbert2
analytic_signal = hilbert2(x)

# Print the analytic signal
print(analytic_signal)
Generated code for scipy.signal.decimate


import scipy.signal

def decimate(x, q, n=None, ftype='iir', axis=-1):
    """
    Downsample the signal x by an integer factor q, using an order n filter.
    
    By default an order 8 Chebyshev type I filter is used or a 30 point FIR
    filter with hamming window if ftype is 'fir'.
    
    Parameters
    ----------
    x : ndarray
        The signal to be downsampled, as an N-dimensional array.
    q : int
        The downsampling factor.
    n : int, optional
        The order of the filter (1 less than the length for 'fir').
    ftype : str {'iir', 'fir'}, optional
        The type of the lowpass filter.
    axis : int, optional
        The axis along which to decimate.
    
    Returns
    -------
    y : ndarray
        The down-sampled signal.
    
    See Also
    --------
    scipy.signal.resample
    
    Examples
    --------
    >>> from scipy import signal
    >>> sig = np.arange(10)
    >>> signal.decimate(sig, q=2)
    array([0, 2, 4, 6, 8])
    
    """
    if not isinstance(q, int):
        raise TypeError("q must be an integer")
    if n is None:
        if ftype == 'fir':
            n = 30
        else:
            n = 8
    if ftype == 'fir':
        b = scipy.signal.firwin(n + 1, 1. / q, window='hamming')
        a = 1.
    else:
        b, a = scipy.signal.cheby1(n, 0.05, 0.8 / q)
    y = scipy.signal.lfilter(b, a, x, axis=axis)
    sl = [slice(None)] * y.ndim
    sl[axis] = slice(None, None, q
Generated code for scipy.signal.detrend


def detrend(x):
    """
    Detrend a signal x by fitting a polynomial of degree deg and subtracting it.
    Parameters
    ----------
    x : array_like
        Signal data.
    Returns
    -------
    x_detrend : ndarray
        Detrended signal.
    """
    x = np.asarray(x)
    deg = 1
    coeffs = np.polyfit(np.arange(len(x)), x, deg)
    x_detrend = x - np.polyval(coeffs, np.arange(len(x)))
    return x_detrend
Generated code for scipy.signal.resample


import numpy as np
from scipy.signal import resample

# Generate a signal with 10 samples
x = np.arange(10)

# Resample the signal to 5 samples
y = resample(x, 5)

print(y)
# Output: array([0. , 2.5, 5. , 7.5, 10. ])
Generated code for scipy.signal.resample_poly


import numpy as np
from scipy.signal import resample_poly

# Generate a signal
x = np.arange(0, 10, 0.1)
y = np.sin(x)

# Resample the signal
x_resampled, y_resampled = resample_poly(x, y, up=2, down=1)

# Plot the original and resampled signals
import matplotlib.pyplot as plt
plt.plot(x, y, label='Original')
plt.plot(x_resampled, y_resampled, label='Resampled')
plt.legend()
plt.show()
Generated code for scipy.signal.upfirdn


import numpy as np
from scipy.signal import upfirdn

# Define the signal
x = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# Define the filter
h = np.array([1, 2, 3, 4, 5])

# Perform the upfirdn operation
y = upfirdn(h, x, up=2, down=3)

# Print the result
print(y)
Generated code for scipy.signal.bilinear


import numpy as np
from scipy import signal

def bilinear(b, a, fs):
    """
    Bilinear transformation of a digital filter.

    Parameters
    ----------
    b : array_like
        Numerator polynomial coefficients.
    a : array_like
        Denominator polynomial coefficients.
    fs : float
        Sampling frequency.

    Returns
    -------
    bz : ndarray
        Numerator polynomial coefficients in the z-domain.
    az : ndarray
        Denominator polynomial coefficients in the z-domain.

    """
    # Normalize coefficients by the sampling frequency
    b = np.asarray(b) / fs
    a = np.asarray(a) / fs

    # Compute the bilinear transformation
    N = max(len(a), len(b))
    n = np.arange(N)
    k = 2 * np.sin(np.pi * n / (2 * N))
    bz = np.zeros(N, dtype=np.float)
    az = np.zeros(N, dtype=np.float)
    for i in range(N):
        bz[i] = np.sum(b * k**(2 * i))
        az[i] = np.sum(a * k**(2 * i))

    # Normalize the coefficients
    bz /= az[0]
    az /= az[0]

    return bz, az
Generated code for scipy.signal.bilinear_zpk


import scipy.signal

def bilinear_zpk(z, p, k, fs):
    """
    Compute the bilinear transformation of a zpk filter.

    Parameters
    ----------
    z : array_like
        Zeros of the filter transfer function.
    p : array_like
        Poles of the filter transfer function.
    k : float
        Gain of the filter transfer function.
    fs : float
        Sampling frequency.

    Returns
    -------
    z_out : ndarray
        Zeros of the transformed filter transfer function.
    p_out : ndarray
        Poles of the transformed filter transfer function.
    k_out : float
        Gain of the transformed filter transfer function.

    """
    # Compute the bilinear transformation
    z_out = (2 * fs + z) / (2 * fs - z)
    p_out = (2 * fs + p) / (2 * fs - p)
    k_out = k * (2 * fs - p) / (2 * fs + z)

    # Return the transformed zpk
    return z_out, p_out, k_out

# Example usage
z = [1, 2, 3]
p = [4, 5, 6]
k = 1
fs = 44100

z_out, p_out, k_out = scipy.signal.bilinear_zpk(z, p, k, fs)
Generated code for scipy.signal.findfreqs


import numpy as np
from scipy import signal

# Generate a test signal
t = np.linspace(0, 1, 500, endpoint=False)
sig  = np.sin(2 * np.pi * 5 * t) + np.sin(2 * np.pi * 10 * t)

# Compute the frequency components
freqs, times, Sx = signal.find_peaks(sig)

# Print the results
print("Frequencies found: ", freqs)
print("Time instants: ", times)
print("Spectral components: ", Sx)
Generated code for scipy.signal.firls


import numpy as np
from scipy import signal

# Define filter parameters
numtaps = 50
nyq_rate = 10.0
cutoff_freq = 3.0

# Compute the filter coefficients
taps = signal.firls(numtaps, [0, cutoff_freq, cutoff_freq + 0.1, nyq_rate],
                     [1, 1, 0, 0], nyq=nyq_rate)

# Plot the filter coefficients
import matplotlib.pyplot as plt
plt.plot(taps, 'bo-', linewidth=2)
plt.title('Filter Coefficients (%d taps)' % numtaps)
plt.grid(True)
plt.show()
Generated code for scipy.signal.firwin


import numpy as np
from scipy import signal

# Create a lowpass FIR filter
taps = signal.firwin(80, 0.2, window='hamming')

# Plot the frequency response
w, h = signal.freqz(taps, worN=np.logspace(-2, 0, 100))
plt.semilogx(w, 20 * np.log10(abs(h)))
plt.title('Frequency Response of a Lowpass FIR Filter')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Amplitude [dB]')
plt.margins(0, 0.1)
plt.grid(which='both', axis='both')
plt.axvline(0.2, color='green') # cutoff frequency
plt.show()
Generated code for scipy.signal.firwin2


import numpy as np
from scipy import signal

# Define filter parameters
numtaps = 50
cutoff_hz = [100, 200]
fs = 1000

# Generate filter coefficients
taps = signal.firwin2(numtaps, cutoff_hz, fs=fs)

# Plot the frequency response
w, h = signal.freqz(taps, worN=np.logspace(-2, 2, 1000))

# Plot the magnitude response
plt.plot(w, 20 * np.log10(abs(h)))
plt.xscale('log')
plt.title('Frequency Response of FIR Filter')
plt.xlabel('Frequency [rad/sample]')
plt.ylabel('Amplitude [dB]')
plt.grid(which='both', axis='both')
plt.show()
Generated code for scipy.signal.freqs


import numpy as np
from scipy import signal

def freqs(b, a, worN=None, plot=None):
    """
    Compute frequency response of a digital filter.
    
    The frequency response is evaluated for digital filters, by computing the
    frequency response at a number of frequencies.
    
    Parameters
    ----------
    b : array_like
        Numerator of a linear filter.
    a : array_like
        Denominator of a linear filter.
    worN : {None, int, array_like}, optional
        If `worN` is None, then compute at 512 frequencies around the unit
        circle.  If `worN` is an integer, then compute at `worN` frequencies.
        If `worN` is array_like, it should contain the frequencies (in
        radians/second) at which to compute the frequency response.
    plot : callable, optional
        If `plot` is not None, then it should be a callable that takes two
        arguments.  The first argument will be the frequency array (in
        radians/second).  The second argument will be the frequency response
        array.  `plot` will be called just before `freqs` returns.
    
    Returns
    -------
    w : ndarray
        The frequencies at which `h` was computed, in radians/second.
    h : ndarray
        The frequency response.
    
    See Also
    --------
    freqz : Compute the frequency response of an analog filter.
    scipy.signal.group_delay : Compute the group delay of a digital filter.
    
    Examples
    --------
    Plot the frequency response of a low-pass filter:
    
    >>> from scipy import signal
    >>> b, a = signal.butter(4, 100, 'low', analog=True)
    >>> w, h = signal.freqs(b, a)
    >>> import matplotlib.pyplot as plt
    >>> plt.semilogx(w, 20 * np.log10(abs(h)))
    >>> plt.title('Butter
Generated code for scipy.signal.freqs_zpk


import scipy.signal as sig

# Define the zeros, poles, and gain of the filter
zeros = [1, 2, 3]
poles = [4, 5, 6]
gain = 1

# Calculate the frequency response of the filter
freqs, response = sig.freqs_zpk(zeros, poles, gain)

# Print the frequency response
print(freqs)
print(response)
Generated code for scipy.signal.freqz


import numpy as np
from scipy import signal

# Generate a test signal, a 2 Vrms sine wave at 12kHz, corrupted by 0.001 V**2/Hz of white noise sampled at 48 kHz.

fs = 48e3
N = 1000
amp = 2 * np.sqrt(2)
freq = 12e3
noise_power = 0.001 * fs / 2
time = np.arange(N) / fs
x = amp * np.sin(2*np.pi*freq*time)
x += np.random.normal(scale=np.sqrt(noise_power), size=time.shape)

# Compute and plot the frequency response

w, h = signal.freqz(x, fs=fs)

import matplotlib.pyplot as plt
plt.figure()
plt.title('Frequency Response')
plt.plot(w, 20 * np.log10(abs(h)), 'b')
plt.ylabel('Amplitude [dB]', color='b')
plt.xlabel('Frequency [rad/sample]')
plt.grid()
plt.show()
Generated code for scipy.signal.freqz_zpk


import numpy as np
from scipy import signal

# Define the zeros, poles, and gain of the filter
zeros = np.array([-1, -2, -3])
poles = np.array([0.5, 0.75, 0.9])
gain = 1

# Compute the frequency response
w, h = signal.freqz_zpk(zeros, poles, gain)

# Plot the frequency response
import matplotlib.pyplot as plt
plt.figure()
plt.title('Frequency Response')
plt.plot(w, 20 * np.log10(abs(h)), 'b')
plt.ylabel('Amplitude [dB]', color='b')
plt.xlabel('Frequency [rad/sample]')
plt.grid()
plt.show()
Generated code for scipy.signal.sosfreqz


import numpy as np
from scipy import signal

# Define the filter coefficients
sos = np.array([[1, 2, 1, 1, 0.5, 0.5],
                [1, -2, 1, 1, 0.5, 0.5]])

# Compute the frequency response
w, h = signal.sosfreqz(sos)

# Plot the magnitude response
import matplotlib.pyplot as plt
plt.plot(w, 20 * np.log10(abs(h)))
plt.title('Digital filter frequency response')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Amplitude [dB]')
plt.margins(0, 0.1)
plt.grid(which='both', axis='both')
plt.axvline(100, color='green') # cutoff frequency
plt.show()
Generated code for scipy.signal.gammatone


import numpy as np
from scipy.signal import gammatone

def gammatone_filter(x, fs, center_freqs):
    """
    Compute the gammatone filterbank for a given signal x.
    Parameters
    ----------
    x : array_like
        Input signal.
    fs : float
        Sampling rate of the `x` signal.
    center_freqs : array_like
        Center frequencies of the gammatone filterbank.
    Returns
    -------
    gammatone_filterbank : array_like
        Gammatone filterbank output.
    """
    # Compute the gammatone filterbank
    gammatone_filterbank = gammatone(x, fs, center_freqs)
    # Return the filterbank
    return gammatone_filterbank
Generated code for scipy.signal.group_delay


import numpy as np
from scipy import signal

# Generate a test signal
t = np.linspace(0, 1, 1000)
x = np.sin(2 * np.pi * 5 * t)

# Compute the group delay
gd = signal.group_delay((x, t))

# Plot the signal and the group delay
import matplotlib.pyplot as plt
plt.plot(t, x)
plt.plot(t[1:], -gd)
plt.xlabel('Time [s]')
plt.ylabel('Signal')
plt.grid(True)
plt.show()
Generated code for scipy.signal.iirdesign


import scipy.signal as signal

# Design a 5th-order Chebyshev type I lowpass filter
b, a = signal.iirdesign(wp=0.2, ws=0.3, gpass=1, gstop=30,
                        analog=False, ftype='cheby1', output='ba')

# Plot the frequency response
w, h = signal.freqz(b, a)
plt.plot(w, 20 * np.log10(abs(h)))
plt.xscale('log')
plt.title('Chebyshev Type I frequency response')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Amplitude [dB]')
plt.margins(0, 0.1)
plt.grid(which='both', axis='both')
plt.axvline(100, color='green') # cutoff frequency
plt.show()
Generated code for scipy.signal.iirfilter


import scipy.signal as signal

# Create an IIR filter
b, a = signal.iirfilter(N, Wn, rp=None, rs=None, btype='lowpass', analog=False, ftype='butter', output='ba')

# Filter a signal
filtered_signal = signal.lfilter(b, a, signal)
Generated code for scipy.signal.kaiser_atten


import numpy as np
from scipy.signal import kaiser_atten

# Define the parameters
N = 100  # filter order
alpha = 5.0  # Kaiser window parameter

# Calculate the Kaiser window
w = kaiser_atten(N, alpha)

# Plot the Kaiser window
import matplotlib.pyplot as plt
plt.plot(w)
plt.title("Kaiser Window (alpha = %f)" % alpha)
plt.xlabel("Sample")
plt.ylabel("Amplitude")
plt.show()
Generated code for scipy.signal.kaiser_beta


def kaiser_beta(N, beta):
    """
    Compute the Kaiser window parameter beta for a given filter order N.

    Parameters
    ----------
    N : int
        Filter order.
    beta : float
        Kaiser window parameter.

    Returns
    -------
    beta : float
        Kaiser window parameter.

    Notes
    -----
    The Kaiser window is defined as

    .. math::  w(n) = I_0\\left(\\beta \\sqrt{1-\\frac{4n^2}{(N-1)^2}}\\right)

    where :math:`I_0` is the modified Bessel function of order 0. The
    parameter :math:`\\beta` is related to the sidelobe attenuation of the
    window in decibels, :math:`A_s`, by

    .. math:: \\beta = \\frac{A_s}{21.98}

    References
    ----------
    .. [1] J. F. Kaiser, "Nonrecursive Digital Filter Design Using the
           I_0-sinh Window Function," Proc. IEEE Int. Symp. Circuits and
           Systems, pp. 517-520, May 1974.
    .. [2] E. R. Kanasewich, "Time Sequence Analysis in Geophysics," The
           University of Alberta Press, 1975, pp. 177-178.
    .. [3] Wikipedia, "Kaiser window",
           http://en.wikipedia.org/wiki/Kaiser_window

    Examples
    --------
    >>> from scipy.signal import kaiser_beta
    >>> kaiser_beta(50, 5.0)
    2.285449538537
    """
    if N < 1:
        raise ValueError("N must be greater than 0")
    if beta <= 0:
        raise ValueError("beta must be greater than 0")

    return beta / (21.98 * np.sqrt(1.0 - (4.0 * N**2) / ((N - 1.0)**2)))
Generated code for scipy.signal.kaiserord


import scipy.signal as signal

def kaiserord(N, beta):
    """
    Compute the Kaiser window parameters for a given filter order and
    desired attenuation.
    
    Parameters
    ----------
    N : int
        The filter order.
    beta : float
        The desired attenuation in the stop band, in dB.
    
    Returns
    -------
    alpha : float
        The Kaiser window parameter.
    M : int
        The filter length.
    beta : float
        The actual attenuation in the stop band, in dB.
    
    """
    # Compute the stop band attenuation
    delta_p = 0.5 * (1 - 10**(-beta/20))
    delta_s = 0.5 * 10**(-beta/20)
    
    # Compute the Kaiser parameter alpha
    alpha = -20 * np.log10(delta_s/delta_p)
    
    # Compute the filter length
    M = int(np.ceil((N + 1) / 2))
    
    # Compute the actual attenuation
    beta = -20 * np.log10(delta_s)
    
    return alpha, M, beta
Generated code for scipy.signal.minimum_phase


import numpy as np
from scipy import signal

def minimum_phase(x, axis=-1):
    """
    Compute the minimum-phase version of a signal.
    
    Parameters
    ----------
    x : array_like
        The input signal.
    axis : int, optional
        The axis along which to compute the minimum-phase version.
        Default is -1.
    
    Returns
    -------
    x_min : ndarray
        The minimum-phase version of the input signal.
    
    Notes
    -----
    This function computes the minimum-phase version of a signal by
    computing its analytic signal, taking the magnitude of the analytic
    signal, and then reconstructing the signal using an inverse FFT.
    
    Examples
    --------
    >>> import numpy as np
    >>> from scipy.signal import minimum_phase
    >>> x = np.array([1, 2, 3, 4, 5, 6])
    >>> minimum_phase(x)
    array([ 0.5       ,  1.5       ,  2.5       ,  3.5       ,  4.5       ,
            5.5       ])
    """
    x = np.asarray(x)
    x_min = np.abs(signal.hilbert(x, axis=axis))
    x_min = np.fft.ifft(x_min, axis=axis)
    return np.real(x_min)
Generated code for scipy.signal.savgol_coeffs


import numpy as np
from scipy.signal import savgol_coeffs

def savgol_coeffs(window_length, polyorder, deriv=0):
    """
    Compute the coefficients for a 1-d Savitzky-Golay FIR filter.
    Parameters
    ----------
    window_length : int
        The length of the filter window (i.e. the number of coefficients).
        `window_length` must be a positive odd integer.
    polyorder : int
        The order of the polynomial used to fit the samples.
        `polyorder` must be less than `window_length`.
    deriv : int, optional
        The order of the derivative to compute.  This must be a
        nonnegative integer.  The default is 0, which means to filter
        the data without differentiating.
    Returns
    -------
    coeffs : ndarray
        1-D array of coefficients.  The coefficients are in ascending
        order of powers (e.g., coeffs[0] is the constant term,
        coeffs[1] is the linear term, etc.).
    Notes
    -----
    .. versionadded:: 0.19.0
    References
    ----------
    .. [1] A. Savitzky, M. J. E. Golay, Smoothing and Differentiation of
           Data by Simplified Least Squares Procedures. Analytical
           Chemistry, 1964, 36 (8), pp 1627-1639.
    .. [2] Numerical Recipes 3rd Edition: The Art of Scientific Computing
           W.H. Press, S.A. Teukolsky, W.T. Vetterling, B.P. Flannery
           Cambridge University Press ISBN-13: 9780521880688
    Examples
    --------
    >>> from scipy.signal import savgol_coeffs
    >>> savgol_coeffs(5, 2)
    array([-0.08571429,  0.34285714,  0.48571429,  0.34285714, -0.08571429])
    """
    if
Generated code for scipy.signal.remez


import numpy as np
from scipy.signal import remez

# Define the filter parameters
numtaps = 10
bands = [0, 0.2, 0.3, 0.5]
desired = [1, 0]

# Calculate the filter coefficients
coeffs = remez(numtaps, bands, desired)

# Print the filter coefficients
print(coeffs)
Generated code for scipy.signal.unique_roots


import numpy as np
from scipy.signal import unique_roots

# Generate a random polynomial
coeffs = np.random.randint(-10, 10, size=5)

# Find the unique roots of the polynomial
roots = unique_roots(coeffs)

# Print the unique roots
print(roots)
Generated code for scipy.signal.residue


import numpy as np
from scipy.signal import residue

# Define the numerator and denominator polynomials
num = [1, 2, 3]
den = [1, 4, 5, 6]

# Compute the residue
r, p, k = residue(num, den)

# Print the results
print('Residue:', r)
print('Poles:', p)
print('Gain:', k)
Generated code for scipy.signal.residuez


import scipy.signal as sig

# Define the numerator and denominator polynomials
num = [1, 2, 3]
den = [1, 4, 5, 6]

# Compute the residue, pole and gain
res, poles, gain = sig.residuez(num, den)

# Print the results
print('Residues:', res)
print('Poles:', poles)
print('Gain:', gain)
Generated code for scipy.signal.invres


import numpy as np
from scipy import signal

def invres(b, a, x):
    """
    Compute the inverse filter response of a digital filter.

    Parameters
    ----------
    b : array_like
        Numerator polynomial coefficients.
    a : array_like
        Denominator polynomial coefficients.
    x : array_like
        Input signal.

    Returns
    -------
    y : ndarray
        The inverse filter response.

    """
    # Compute the transfer function
    b, a = np.atleast_1d(b, a)
    zi = signal.lfilter_zi(b, a)
    z, p, k = signal.tf2zpk(b, a)

    # Compute the inverse filter response
    y = np.zeros_like(x)
    for n in range(len(x)):
        y[n] = np.dot(b, x[n::-1]) - np.dot(a[1:], y[n::-1])
        y[n] /= a[0]

    # Compensate for the initial conditions
    y = signal.lfilter(b, a, y, zi=zi*x[0])

    return y
Generated code for scipy.signal.invresz


import numpy as np
from scipy import signal

def invresz(b, a, z):
    """
    Compute the inverse z-transform of a rational transfer function.

    Parameters
    ----------
    b : array_like
        Numerator polynomial coefficients.
    a : array_like
        Denominator polynomial coefficients.
    z : array_like
        Z-transform points.

    Returns
    -------
    y : ndarray
        Inverse z-transform of the transfer function.

    """
    # Check inputs
    b = np.asarray(b)
    a = np.asarray(a)
    z = np.asarray(z)

    # Compute inverse z-transform
    y = np.zeros_like(z)
    for i in range(len(z)):
        y[i] = np.sum(b * z[i]**np.arange(len(b))) / np.sum(a * z[i]**np.arange(len(a)))

    return y
Generated code for scipy.signal.BadCoefficients


import numpy as np
from scipy.signal import BadCoefficients

# Create a signal
t = np.linspace(0, 1, 1000)
x = np.sin(2*np.pi*t)

# Create a BadCoefficients object
bc = BadCoefficients(x)

# Get the coefficients
coeffs = bc.coefficients

# Print the coefficients
print(coeffs)
Generated code for scipy.signal.abcd_normalize


def abcd_normalize(a, b, c, d):
    """
    Normalize the ABCD matrix of a linear system.

    Parameters
    ----------
    a : array_like
        The A matrix of the linear system.
    b : array_like
        The B matrix of the linear system.
    c : array_like
        The C matrix of the linear system.
    d : array_like
        The D matrix of the linear system.

    Returns
    -------
    a_norm : ndarray
        The normalized A matrix.
    b_norm : ndarray
        The normalized B matrix.
    c_norm : ndarray
        The normalized C matrix.
    d_norm : ndarray
        The normalized D matrix.

    """
    # Compute the normalization factor
    norm_factor = np.linalg.norm(a)

    # Normalize the matrices
    a_norm = a / norm_factor
    b_norm = b / norm_factor
    c_norm = c * norm_factor
    d_norm = d * norm_factor

    return a_norm, b_norm, c_norm, d_norm
Generated code for scipy.signal.band_stop_obj


import scipy.signal as sig

# Create a band-stop filter object
band_stop_obj = sig.iirfilter(N=2, Wn=[0.2, 0.8], btype='bandstop',
                              ftype='butter', output='sos')

# Apply the filter to a signal
filtered_signal = sig.sosfilt(band_stop_obj, signal)
Generated code for scipy.signal.besselap


import numpy as np
from scipy import signal

def besselap(N, rp, rs, fs=1):
    """
    Design a Bessel analog lowpass filter.

    Design an Nth-order lowpass analog Bessel filter with
    a passband ripple of `rp` dB and a stopband ripple of `rs` dB.

    Parameters
    ----------
    N : int
        The order of the filter.
    rp : float
        The maximum passband ripple in dB.
    rs : float
        The minimum stopband ripple in dB.
    fs : float, optional
        The sampling frequency. Default is 1.

    Returns
    -------
    b : ndarray
        Numerator of the filter transfer function.
    a : ndarray
        Denominator of the filter transfer function.

    """
    # Compute the filter coefficients
    b, a = signal.bessel(N, rp, rs, fs=fs)

    return b, a
Generated code for scipy.signal.buttap


import numpy as np
from scipy import signal

# Define filter parameters
N  = 3    # Filter order
Wn = 0.2  # Cutoff frequency

# Calculate the coefficients using the `buttap` function
b, a = signal.buttap(N, Wn)

# Print the filter coefficients
print('b =', b)
print('a =', a)
Generated code for scipy.signal.cheb1ap


import numpy as np
from scipy import signal

def cheb1ap(N, rp, rs, fs=2):
    """
    Design a Chebyshev type I analog lowpass filter with `N` poles,
    `rp` dB of ripple in the passband, and `rs` dB of attenuation in
    the stopband.

    Parameters
    ----------
    N : int
        Filter order
    rp : float
        Passband ripple in dB
    rs : float
        Stopband attenuation in dB
    fs : float, optional
        Sampling frequency (default is 2)

    Returns
    -------
    b : ndarray
        Numerator polynomial coefficients
    a : ndarray
        Denominator polynomial coefficients

    """
    # Compute the filter parameters
    Wn = 1.0 / (fs / 2.0)
    Ws = Wn * np.sqrt(10**(rp/10.0) - 1.0)
    Wp = Wn * np.sqrt(10**(rs/10.0) - 1.0)

    # Compute the filter coefficients
    b, a = signal.cheby1(N, rp, Wp, 'low', analog=True)

    return b, a
Generated code for scipy.signal.cheb2ap


import numpy as np
from scipy.signal import cheb2ap

# Define filter order
order = 5

# Define passband ripple
ripple = 0.5

# Define passband and stopband frequencies
wp = 0.2
ws = 0.3

# Calculate filter coefficients
b, a = cheb2ap(order, ripple, [wp, ws])

# Print filter coefficients
print('b =', b)
print('a =', a)
Generated code for scipy.signal.cmplx_sort


import numpy as np
from scipy.signal import cmplx_sort

# Create a complex array
x = np.array([1+2j, 3+4j, 5+6j, 7+8j])

# Sort the array
sorted_x = cmplx_sort(x)

# Print the sorted array
print(sorted_x)
Generated code for scipy.signal.ellipap


import scipy.signal as signal

def ellipap(N, rp, rs, Wn, btype='low', analog=False, output='ba'):
    """
    Elliptic IIR filter design.

    Design an Nth-order digital or analog elliptic filter and return the
    filter coefficients.

    Parameters
    ----------
    N : int
        The order of the filter.
    rp : float
        The maximum ripple allowed below unity gain in the passband.  Specified
        in decibels, as a positive number.
    rs : float
        The minimum attenuation required in the stopband.  Specified in
        decibels, as a positive number.
    Wn : array_like
        A scalar or length-2 sequence giving the critical frequencies.
        For a lowpass filter, this is the cutoff frequency.
        For a highpass filter, this is the cutoff frequency.
        For a bandpass filter, this is the two cutoff frequencies.
        For a bandstop filter, this is the two corner frequencies.
    btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
        The type of filter.  Default is 'lowpass'.
    analog : bool, optional
        When True, return an analog filter, otherwise a digital filter is
        returned.
    output : {'ba', 'zpk', 'sos'}, optional
        Type of output:  numerator/denominator ('ba') or pole-zero ('zpk') or
        second-order sections ('sos'). Default is 'ba'.

    Returns
    -------
    b, a : ndarray, ndarray
        Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
        Only returned if ``output='ba'``.
    z, p, k : ndarray, ndarray, float
        Zeros, poles, and system gain of the IIR filter transfer
        function.  Only returned if ``output='zpk'``.
    sos : ndarray
        Second-order sections representation of the IIR filter.

Generated code for scipy.signal.lp2bp


import numpy as np
from scipy import signal

# Define filter parameters
order = 4
cutoff_low = 0.2
cutoff_high = 0.3

# Create the filter
b, a = signal.butter(order, [cutoff_low, cutoff_high], btype='bandpass', analog=False)

# Apply the filter
output = signal.lfilter(b, a, input)
Generated code for scipy.signal.lp2bp_zpk


import scipy.signal as signal

# Define the filter parameters
f1 = 0.2  # Start of the transition band
f2 = 0.3  # End of the transition band
gpass = 1  # Maximum loss in the passband (dB)
gstop = 40  # Minimum attenuation in the stopband (dB)

# Calculate the filter coefficients
b, a = signal.lp2bp(f1, f2, gpass, gstop)

# Calculate the zeros, poles and gain
z, p, k = signal.tf2zpk(b, a)

# Print the results
print('Zeros =', z)
print('Poles =', p)
print('Gain =', k)
Generated code for scipy.signal.lp2bs


import numpy as np
from scipy import signal

def lp2bs(b, a, wo=1.0, bw=1.0):
    """
    Transform a lowpass filter prototype to a bandstop filter.

    Transform a lowpass filter prototype with unity cutoff frequency to
    a bandstop filter with center frequency `wo` and bandwidth `bw`.
    The lowpass filter prototype is described with numerator and
    denominator coefficients `b` and `a`, respectively.

    Parameters
    ----------
    b : array_like
        Numerator polynomial of the lowpass filter prototype.
    a : array_like
        Denominator polynomial of the lowpass filter prototype.
    wo : float
        Center frequency of the resulting bandstop filter, normalized
        from 0 to 1, where 1 is the Nyquist frequency.
    bw : float
        Bandwidth of the resulting bandstop filter, normalized from
        0 to 1, where 1 is the Nyquist frequency.

    Returns
    -------
    b2 : ndarray
        Numerator polynomial of the bandstop filter.
    a2 : ndarray
        Denominator polynomial of the bandstop filter.

    """
    # Pre-warp frequencies
    wo = wo * np.pi
    bw = bw * np.pi

    # Transform to bandstop
    b2 = np.multiply(b, np.array([1, -2*np.cos(wo), 1]))
    a2 = np.multiply(a, np.array([1, -2*np.cos(wo + bw/2), 1]))

    return b2, a2
Generated code for scipy.signal.lp2bs_zpk


import scipy.signal as sig

def lp2bs_zpk(z, p, k, wo=1.0, bw=None):
    """
    Transform a lowpass filter prototype to a bandstop filter.

    Transform a lowpass filter prototype to a bandstop filter, by
    transforming its zeros, poles and gain, with the specified
    stopband frequency and bandwidth.

    Parameters
    ----------
    z : array_like
        Zeros of the analog lowpass filter
    p : array_like
        Poles of the analog lowpass filter
    k : float
        The system gain of the analog lowpass filter
    wo : float
        The desired stopband frequency
    bw : float, optional
        The desired stopband bandwidth. If omitted, wo/2 is used.

    Returns
    -------
    z : ndarray
        Zeros of the resulting bandstop filter
    p : ndarray
        Poles of the resulting bandstop filter
    k : float
        The system gain of the resulting bandstop filter

    """
    if bw is None:
        bw = wo/2.0

    # Transform the lowpass filter to a bandstop filter
    z, p, k = sig.lp2bs(z, p, k, wo, bw)

    # Transform to zpk
    z, p, k = sig.zpk2tf(z, p, k)

    return z, p, k
Generated code for scipy.signal.lp2hp


import scipy.signal as signal

def lp2hp(b, a, cutoff, fs=2):
    """
    Transform a lowpass filter prototype to a highpass filter.

    Parameters
    ----------
    b : array_like
        Numerator of a linear filter.
    a : array_like
        Denominator of a linear filter.
    cutoff : float
        Cutoff frequency of the lowpass filter, normalized from 0 to 1, where
        1 corresponds to the Nyquist frequency.
    fs : float, optional
        Sampling frequency. Defaults to 2.

    Returns
    -------
    b_hp : ndarray
        Numerator of the resulting highpass filter.
    a_hp : ndarray
        Denominator of the resulting highpass filter.

    """
    # Normalize the cutoff frequency to the Nyquist frequency
    wp = cutoff / (fs / 2)

    # Get the lowpass filter coefficients
    b_lp, a_lp = signal.butter(len(b) - 1, wp, btype='lowpass')

    # Transform to a highpass filter
    b_hp = -b_lp
    b_hp[int(len(b_hp) / 2)] += 1
    a_hp = a_lp

    # Use the bilinear transformation to get the corresponding
    # highpass filter coefficients
    b_hp, a_hp = signal.bilinear(b_hp, a_hp, fs=fs)

    return b_hp, a_hp
Generated code for scipy.signal.lp2hp_zpk


import scipy.signal as signal

def lp2hp_zpk(z, p, k, fs):
    """
    Convert a lowpass filter prototype to a highpass filter.

    Transform a lowpass filter prototype with zeros `z`, poles `p`, and gain
    `k` to a highpass filter with the same cut-off frequency, using the
    bilinear transform.

    Parameters
    ----------
    z : array_like
        Zeros of the lowpass filter prototype.
    p : array_like
        Poles of the lowpass filter prototype.
    k : float
        Gain of the lowpass filter prototype.
    fs : float
        Sampling frequency.

    Returns
    -------
    z : ndarray
        Zeros of the highpass filter.
    p : ndarray
        Poles of the highpass filter.
    k : float
        Gain of the highpass filter.

    """
    # prewarp the frequencies
    wp = 2 * fs * np.tan(np.pi * fc / fs)

    # transform the lowpass filter to a highpass filter
    z = (wp**2) * z
    p = (wp**2) * p
    k *= (wp**2)

    return z, p, k
Generated code for scipy.signal.lp2lp


import numpy as np
from scipy import signal

def lp2lp(b, a, wo):
    """
    Lowpass to lowpass digital filter transformation.

    Transform a lowpass filter prototype to a different frequency
    given a new cutoff frequency wo.

    Parameters
    ----------
    b : array_like
        Numerator polynomial of the lowpass filter prototype.
    a : array_like
        Denominator polynomial of the lowpass filter prototype.
    wo : float
        New cutoff frequency.

    Returns
    -------
    b : ndarray
        Numerator polynomial of the transformed lowpass filter.
    a : ndarray
        Denominator polynomial of the transformed lowpass filter.

    """
    # pre-warp the frequency
    wt = 2 * np.tan(np.pi * wo / 2)

    # Transform the prototype lowpass filter to a bandstop filter
    (b, a) = signal.lp2bs(b, a, wo)

    # Transform the bandstop filter to a lowpass filter
    (b, a) = signal.bs2lp(b, a, wt)

    return b, a
Generated code for scipy.signal.lp2lp_zpk


import scipy.signal as sig

def lp2lp_zpk(z, p, k, wo=1.0, bw=None):
    """
    Transform a lowpass filter prototype to a different frequency.
    
    Transform a lowpass filter prototype with unity cutoff frequency to
    a lowpass filter with different cutoff frequency, preserving filter
    order and ripple specifications.
    
    Parameters
    ----------
    z : array_like
        Zeros of the filter transfer function.
    p : array_like
        Poles of the filter transfer function.
    k : float
        System gain.
    wo : float
        Desired cutoff frequency (e.g. wo=2 --> twice the unity cutoff
        frequency).
    bw : float, optional
        If given, specifies that the resulting filter should have a
        -3dB point at `wo` + `bw`.  Otherwise, the -3dB point will be
        at `wo`.
    
    Returns
    -------
    z2 : ndarray
        Zeros of the transformed filter transfer function.
    p2 : ndarray
        Poles of the transformed filter transfer function.
    k2 : float
        System gain of the transformed filter.
    
    """
    # pre-warp frequencies
    if bw is None:
        bw = wo
    else:
        bw = wo + bw
    w1 = 2 * wo
    w2 = 2 * bw
    # transform
    z2 = sig.bilinear(z, p, k, w2)
    p2 = sig.bilinear(z, p, k, w1)
    # gain
    k2 = k * (w2/w1)**(len(z) - len(p))
    return z2, p2, k2
Generated code for scipy.signal.normalize


def normalize(x, axis=None):
    """Normalize an array to unit length along the specified axis.

    Parameters
    ----------
    x : array_like
        Input array.
    axis : int, optional
        Axis along which the normalization is performed. Default is None,
        which normalizes the entire array.

    Returns
    -------
    x_norm : ndarray
        The normalized array.

    """
    x_norm = np.linalg.norm(x, axis=axis, keepdims=True)
    x_norm[x_norm == 0] = 1
    return x / x_norm
Generated code for scipy.signal.butter


import numpy as np
from scipy.signal import butter, lfilter

def butter_lowpass(cutoff, fs, order=5):
    nyq = 0.5 * fs
    normal_cutoff = cutoff / nyq
    b, a = butter(order, normal_cutoff, btype='low', analog=False)
    return b, a

def butter_lowpass_filter(data, cutoff, fs, order=5):
    b, a = butter_lowpass(cutoff, fs, order=order)
    y = lfilter(b, a, data)
    return y

# Sample rate and desired cutoff frequencies (in Hz).
fs = 5000.0
cutoff = 500.0

# Filter a noisy signal.
T = 5.0         # seconds
n = int(T * fs) # total number of samples
t = np.linspace(0, T, n, endpoint=False)
# "Noisy" data.  We want to recover the 1.2 Hz signal from this.
data = np.sin(1.2*2*np.pi*t) + 1.5*np.cos(9*2*np.pi*t) + 0.5*np.sin(12.0*2*np.pi*t)

# Filter the data, and plot both the original and filtered signals.
y = butter_lowpass_filter(data, cutoff, fs, order=6)

import matplotlib.pyplot as plt
plt.subplot(2, 1, 2)
plt.plot(t, data, 'b-', label='data')
plt.plot(t, y, 'g-', linewidth=2, label='filtered data')
plt.xlabel('Time [sec]')
plt.grid()
plt.legend()

plt.subplots_adjust(hspace=0.35)
plt.show()
Generated code for scipy.signal.buttord


import numpy as np
from scipy import signal

# Define filter parameters
Wp = 0.2  # Passband frequency
Ws = 0.3  # Stopband frequency
Rp = 3    # Passband ripple
Rs = 40   # Stopband attenuation

# Calculate filter order and cutoff frequencies
N, Wn = signal.buttord(Wp, Ws, Rp, Rs)

# Create the filter
b, a = signal.butter(N, Wn, 'low')
Generated code for scipy.signal.cheby1


import numpy as np
from scipy import signal

def cheby1(N, rp, Wn, btype='low', analog=False, output='ba'):
    """
    Chebyshev type I digital and analog filter design.

    Design an Nth order digital or analog Chebyshev type I filter and return
    the filter coefficients.

    Parameters
    ----------
    N : int
        The order of the filter.
    rp : float
        The maximum ripple allowed below unity gain in the passband.  Specified
        in decibels, as a positive number.
    Wn : array_like
        A scalar or length-2 sequence giving the critical frequencies.
        For a lowpass filter, this is the upper cutoff frequency.
        For a highpass filter, this is the lower cutoff frequency.
        For a bandpass filter, this is the two-element vector giving the lower
        and upper cutoff frequencies.
        For a bandstop filter, this is the two-element vector giving the lower
        and upper stopband frequencies.
    btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
        The type of filter.  Default is 'lowpass'.
    analog : bool, optional
        When True, return an analog filter, otherwise a digital filter is
        returned.
    output : {'ba', 'zpk', 'sos'}, optional
        Type of output:  numerator/denominator ('ba') or pole-zero ('zpk') or
        second-order sections ('sos'). Default is 'ba'.

    Returns
    -------
    b, a : ndarray, ndarray
        Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
        Only returned if ``output='ba'``.
    z, p, k : ndarray, ndarray, float
        Zeros, poles, and system gain of the IIR filter transfer
        function.  Only returned if ``output='zpk'``.
    sos : ndarray
        Second-order sections representation of the IIR filter.
       
Generated code for scipy.signal.cheb1ord


import numpy as np
from scipy.signal import cheb1ord

# Define the filter parameters
wp = 0.2  # Passband frequency
ws = 0.3  # Stopband frequency
gpass = 1  # Passband maximum loss (dB)
gstop = 40  # Stopband minimum attenuation (dB)

# Calculate the order and cutoff frequencies of the Chebyshev Type I filter
N, Wn = cheb1ord(wp, ws, gpass, gstop)

print('Filter order =', N)
print('Cutoff frequency =', Wn)
Generated code for scipy.signal.cheby2


import numpy as np
from scipy import signal

# Chebyshev Type II filter
b, a = signal.cheby2(N=4, rp=3, Wn=0.2, btype='low', analog=False, output='ba')

# Generate a test signal
t = np.linspace(0, 1, 1000, False)
x = np.sin(2 * np.pi * 5 * t) + np.sin(2 * np.pi * 10 * t)

# Apply the filter
y = signal.lfilter(b, a, x)

# Plot the original and filtered signals
import matplotlib.pyplot as plt
plt.plot(t, x, 'b-', label='x')
plt.plot(t, y, 'g-', linewidth=2, label='y')
plt.legend()
plt.grid()
plt.show()
Generated code for scipy.signal.cheb2ord


import scipy.signal

def cheb2ord(wp, ws, gpass, gstop):
    """
    Calculate the order and critical frequencies of a Chebyshev type II filter.
    
    Parameters
    ----------
    wp : float
        Passband cutoff frequency.
    ws : float
        Stopband cutoff frequency.
    gpass : float
        The maximum loss in the passband (dB).
    gstop : float
        The minimum attenuation in the stopband (dB).
    
    Returns
    -------
    n : int
        Filter order.
    Wn : ndarray
        Critical frequencies.
    """
    # Pre-warp frequencies
    wp = 2 * scipy.signal.tan(scipy.pi * wp / 2)
    ws = 2 * scipy.signal.tan(scipy.pi * ws / 2)
    
    # Compute the order from the parameters using the bilinear transform
    eps = scipy.sqrt(10**(0.1 * gpass) - 1)
    delta = 10**(0.1 * gstop) - 1
    order = scipy.log(delta / eps) / scipy.log(ws / wp)
    n = scipy.ceil(order)
    
    # Compute the critical frequencies
    Wn = wp / scipy.power(delta / eps, 1.0 / n)
    
    return n, Wn
Generated code for scipy.signal.ellip


import numpy as np
from scipy import signal

def ellip(N, rp, rs, Wn, btype='low', analog=False, output='ba'):
    """
    Elliptic (Cauer) IIR filter design.

    Design an Nth-order digital or analog elliptic filter and return the
    filter coefficients.

    Parameters
    ----------
    N : int
        The order of the filter.
    rp : float
        The maximum ripple in the passband (dB).
    rs : float
        The minimum attenuation in the stopband (dB).
    Wn : array_like
        A scalar or length-2 sequence giving the critical frequencies.
        For a lowpass filter, this is the cutoff frequency.
        For a highpass filter, this is the cutoff frequency.
        For a bandpass filter, this is the two cutoff frequencies.
        For a bandstop filter, this is the two corner frequencies.
    btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional
        The type of filter. Default is 'lowpass'.
    analog : bool, optional
        When True, return an analog filter, otherwise a digital filter is
        returned.
    output : {'ba', 'zpk', 'sos'}, optional
        Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'),
        or second-order sections ('sos'). Default is 'ba'.

    Returns
    -------
    b, a : ndarray, ndarray
        Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.
        Only returned if ``output='ba'``.
    z, p, k : ndarray, ndarray, float
        Zeros, poles, and system gain of the IIR filter transfer
        function.  Only returned if ``output='zpk'``.
    sos : ndarray
        Second-order sections representation of the IIR filter.
        Only returned if ``output=='sos'``.

    See Also
    --------
    buttord, cheb
Generated code for scipy.signal.ellipord


def ellipord(wp, ws, gpass, gstop, analog=False):
    """
    Compute the order and critical frequencies of an elliptic filter.

    This function computes the order of an elliptic filter, given the
    passband and stopband edge frequencies and the passband and stopband
    gains.

    Parameters
    ----------
    wp : float
        Passband edge frequency.
    ws : float
        Stopband edge frequency.
    gpass : float
        The maximum loss in the passband (dB).
    gstop : float
        The minimum attenuation in the stopband (dB).
    analog : bool, optional
        When True, return an analog filter, otherwise a digital filter is
        returned.

    Returns
    -------
    ord : int
        The lowest order for an elliptic filter which meets specs.
    wn : ndarray
        The critical frequencies.

    See Also
    --------
    ellip, ellip_zeros, ellip_pole, ellip_gain

    Notes
    -----
    The filter is described by the following equations:

        .. math::
            |H(s)| &= 1 \\
            |H(j\\omega)| &= \\sqrt{\\frac{1}{(1+(\\frac{\\omega}{\\omega_p})^{2n})}
            \\frac{1}{(1+(\\frac{\\omega}{\\omega_s})^{2n})}} \\
            \\text{where: } \\omega_p &= \\text{the passband edge frequency} \\\\
            \\omega_s &= \\text{the stopband edge frequency} \\\\
            n &= \\text{the filter order}

    Examples
    --------
    Design an order 3 lowpass filter with a passband of 0.2 $\pi$
    rad/sample and a stopband of 0.3 $\pi$ rad/sample:

    >>> from scipy.signal import ellipord, ellip
    >>> ellipord(0.2, 0.3, 1, 60)
    (3, array([ 0.2,  0.3]
Generated code for scipy.signal.bessel


import scipy.signal as signal

def bessel(order, cutoff, fs):
    # Calculate the filter coefficients
    b, a = signal.bessel(order, cutoff, btype='low', analog=False, fs=fs)
    # Return the filter coefficients
    return b, a

# Example usage
order = 4
cutoff = 0.2
fs = 44100
b, a = bessel(order, cutoff, fs)
Generated code for scipy.signal.iirnotch


import numpy as np
from scipy import signal

# Sample rate
fs = 1000

# Frequency of the signal
f0 = 50

# Create a notch filter
b, a = signal.iirnotch(f0, fs)

# Generate a signal
t = np.linspace(0, 1, fs)
x = np.sin(2 * np.pi * f0 * t)

# Apply the filter
y = signal.lfilter(b, a, x)

# Plot the signals
import matplotlib.pyplot as plt
plt.plot(t, x, label='Original signal')
plt.plot(t, y, label='Filtered signal')
plt.xlabel('Time [s]')
plt.ylabel('Amplitude')
plt.legend()
plt.show()
Generated code for scipy.signal.iirpeak


import scipy.signal as signal

# Define filter parameters
f0 = 0.2  # Center frequency
Q = 30.0  # Quality factor

# Design filter
b, a = signal.iirpeak(f0, Q)

# Plot frequency response
w, h = signal.freqz(b, a)

# Plot
import matplotlib.pyplot as plt
plt.plot(w, 20 * np.log10(abs(h)))
plt.xscale('log')
plt.title('IIR peak filter frequency response')
plt.xlabel('Frequency [radians / second]')
plt.ylabel('Amplitude [dB]')
plt.margins(0, 0.1)
plt.grid(which='both', axis='both')
plt.axvline(f0, color='green') # cutoff frequency
plt.show()
Generated code for scipy.signal.iircomb


import scipy.signal as sig

def iircomb(N, F, btype='lowpass', fs=2):
    """
    Design an IIR comb filter.

    Parameters
    ----------
    N : int
        The order of the filter.
    F : float
        The cutoff frequency of the filter.
    btype : {'lowpass', 'highpass'}, optional
        The type of filter. Default is 'lowpass'.
    fs : float, optional
        The sampling frequency of the filter. Default is 2.

    Returns
    -------
    b : ndarray
        The numerator of the filter.
    a : ndarray
        The denominator of the filter.
    """
    # Calculate the filter coefficients
    if btype == 'lowpass':
        b, a = sig.iircomb(N, F/fs, btype=btype)
    elif btype == 'highpass':
        b, a = sig.iircomb(N, F/fs, btype=btype, ftype='highpass')
    else:
        raise ValueError('btype must be either "lowpass" or "highpass"')

    return b, a
Generated code for scipy.signal.lti


import scipy.signal as sig

# Create a linear time-invariant (LTI) system
num = [1, 2, 3]
den = [1, 4, 5, 6]
sys = sig.lti(num, den)

# Compute the frequency response
w, mag, phase = sys.freqresp()

# Plot the magnitude and phase of the frequency response
import matplotlib.pyplot as plt
plt.figure()
plt.title('Magnitude and Phase')
plt.plot(w, mag, label='Magnitude')
plt.plot(w, phase, label='Phase')
plt.xlabel('Frequency [rad/s]')
plt.ylabel('Magnitude/Phase [dB]')
plt.legend()
plt.show()
Generated code for scipy.signal.StateSpace


import numpy as np
from scipy import signal

# Define the state-space system
A = np.array([[0, 1], [-2, -3]])
B = np.array([[0], [1]])
C = np.array([[1, 0]])
D = np.array([[0]])

# Create the state-space system
sys = signal.StateSpace(A, B, C, D)

# Compute the response to an input
t = np.linspace(0, 10, 1000)
u = np.ones_like(t)
t, y = signal.dlsim(sys, u, t)
Generated code for scipy.signal.TransferFunction


import scipy.signal as sig

# Create a transfer function
num = [1, 2, 3]
den = [1, 4, 5, 6]
sys = sig.TransferFunction(num, den)

# Compute the frequency response
w, mag, phase = sys.bode()

# Plot the magnitude and phase
import matplotlib.pyplot as plt
plt.figure()
plt.semilogx(w, mag)    # Bode magnitude plot
plt.figure()
plt.semilogx(w, phase)  # Bode phase plot
plt.show()
Generated code for scipy.signal.ZerosPolesGain


import scipy.signal

zeros, poles, gain = scipy.signal.ZerosPolesGain(zeros=[-1, -2], poles=[1, 2], gain=3)

print(zeros)
print(poles)
print(gain)
Generated code for scipy.signal.lsim


import numpy as np
from scipy.signal import lsim

# Define the system
num = [1, 2]
den = [1, 4, 3]

# Define the input
t = np.linspace(0, 10, 1000)
u = np.ones_like(t)

# Compute the response
t, y = lsim(num, den, u, t)

# Plot the response
import matplotlib.pyplot as plt
plt.plot(t, y)
plt.xlabel('Time [s]')
plt.ylabel('Amplitude')
plt.show()
Generated code for scipy.signal.lsim2


import numpy as np
from scipy.signal import lsim2

# Define system parameters
A = np.array([[0, 1], [-2, -3]])
B = np.array([[0], [1]])
C = np.array([[1, 0]])
D = np.array([[0]])

# Define input signal
t = np.linspace(0, 10, 100)
u = np.sin(t)

# Compute the response
tout, y, x = lsim2(A, B, C, D, u, t)

# Plot the response
import matplotlib.pyplot as plt
plt.plot(tout, y)
plt.xlabel('Time [s]')
plt.ylabel('Response')
plt.show()
Generated code for scipy.integrate.odeint


import numpy as np
from scipy.integrate import odeint

def f(y, t):
    return y**2 + t

t = np.linspace(0, 5, 100)
y0 = 0

y = odeint(f, y0, t)

print(y)
Generated code for scipy.signal.impulse


import numpy as np
from scipy import signal

# Generate a test signal
t = np.linspace(0, 10, 500)
x = np.sin(2 * np.pi * 0.5 * t)

# Generate the impulse response
impulse_response = signal.impulse(x, N=20)

# Plot the impulse response
plt.plot(t, impulse_response)
plt.xlabel('Time [s]')
plt.ylabel('Amplitude')
plt.title('Impulse Response')
plt.show()
Generated code for scipy.signal.impulse2


import numpy as np
from scipy.signal import impulse2

# Generate a signal with two impulses
t = np.arange(0, 10, 0.01)
x = np.zeros(len(t))
x[50] = 1
x[150] = -1

# Generate the impulse response
impulse_response = impulse2(x, t)

# Plot the impulse response
import matplotlib.pyplot as plt
plt.plot(t, impulse_response)
plt.show()
Generated code for scipy.signal.step


import numpy as np
from scipy import signal

def step(t, t_on=0, t_off=np.inf, y_on=1, y_off=0):
    """
    Generate a step signal.

    Parameters
    ----------
    t : array_like
        Time points.
    t_on : float, optional
        Time when the signal turns on.
    t_off : float, optional
        Time when the signal turns off.
    y_on : float, optional
        Value when the signal is on.
    y_off : float, optional
        Value when the signal is off.

    Returns
    -------
    y : ndarray
        The step signal.
    """
    y = np.zeros_like(t)
    y[t >= t_on] = y_on
    y[t >= t_off] = y_off
    return y

# Generate a step signal
t = np.linspace(0, 10, 1000)
y = step(t, t_on=2, t_off=8, y_on=1, y_off=0)

# Plot the signal
import matplotlib.pyplot as plt
plt.plot(t, y)
plt.xlabel('Time (s)')
plt.ylabel('Signal')
plt.show()
Generated code for scipy.signal.step2


import numpy as np
from scipy import signal

# Generate a step signal
t = np.linspace(0, 10, 500)
x = signal.step2(t)

# Plot the signal
import matplotlib.pyplot as plt
plt.plot(t, x)
plt.title('Step Signal')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.show()
Generated code for scipy.signal.freqresp


import numpy as np
from scipy import signal

# Generate a test signal
t = np.linspace(0, 1, 1000)
x = np.sin(2 * np.pi * 5 * t)

# Compute the frequency response
w, h = signal.freqresp(x, t)

# Plot the frequency response
import matplotlib.pyplot as plt
plt.plot(w, h)
plt.xlabel('Frequency [rad/s]')
plt.ylabel('Amplitude [dB]')
plt.grid()
plt.show()
Generated code for scipy.signal.bode


import numpy as np
from scipy import signal

# Generate a test signal
t = np.linspace(0, 10, 1000)
x = np.sin(2*np.pi*t)

# Compute the bode plot
w, mag, phase = signal.bode(x, t)

# Plot the magnitude and phase
import matplotlib.pyplot as plt
plt.figure()
plt.semilogx(w, mag)    # Bode magnitude plot
plt.figure()
plt.semilogx(w, phase)  # Bode phase plot
plt.show()
Generated code for scipy.signal.dlti


import scipy.signal as sig

# Create a discrete-time linear time-invariant (DLTI) system
num = [1, 2, 3]
den = [1, 4, 5]
sys = sig.dlti(num, den)

# Compute the impulse response of the system
t, y = sig.dimpulse(sys)

# Plot the impulse response
import matplotlib.pyplot as plt
plt.plot(t, y)
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('Impulse Response of DLTI System')
plt.show()
Generated code for scipy.signal.StateSpace


import numpy as np
from scipy import signal

# Define the state-space system
A = np.array([[0, 1], [-2, -3]])
B = np.array([[0], [1]])
C = np.array([[1, 0]])
D = np.array([[0]])

# Create the state-space system
sys = signal.StateSpace(A, B, C, D)

# Compute the response
t, y = signal.step(sys)

# Plot the response
import matplotlib.pyplot as plt
plt.plot(t, y)
plt.xlabel('Time [s]')
plt.ylabel('y(t)')
plt.show()
Generated code for scipy.signal.TransferFunction


import scipy.signal as sig

# Create a transfer function
num = [1, 2, 3]
den = [4, 5, 6]
tf = sig.TransferFunction(num, den)

# Compute the frequency response
w, mag, phase = sig.bode(tf)

# Plot the magnitude and phase
plt.figure()
plt.semilogx(w, mag)    # Bode magnitude plot
plt.figure()
plt.semilogx(w, phase)  # Bode phase plot
plt.show()
Generated code for scipy.signal.ZerosPolesGain


import scipy.signal

zeros, poles, gain = scipy.signal.ZerosPolesGain(zeros=[-1, -2], poles=[1, 2], gain=3)

print(zeros)
print(poles)
print(gain)
Generated code for scipy.signal.dlsim


import scipy.signal as sig
import numpy as np

# Define system parameters
num = [1, 2, 3]
den = [1, 4, 5, 6]

# Create input signal
t = np.linspace(0, 10, 1000)
u = np.sin(t)

# Simulate system
tout, y, x = sig.dlsim(sig.lti(num, den), u, t)

# Plot results
import matplotlib.pyplot as plt
plt.plot(tout, y)
plt.xlabel('Time (s)')
plt.ylabel('Output (y)')
plt.show()
Generated code for scipy.signal.dimpulse


import numpy as np
from scipy import signal

# Generate a unit impulse
impulse = np.zeros(10)
impulse[0] = 1

# Generate the response of a system to the impulse
response = signal.dimpulse(system=(1, [1, 1, 0, 0]), n=10)

# Plot the impulse and response
import matplotlib.pyplot as plt

plt.plot(impulse, label='Impulse')
plt.plot(response, label='Response')
plt.legend()
plt.show()
Generated code for scipy.signal.dstep


import numpy as np
from scipy import signal

def dstep(t,t0,y0,y1):
    """
    Generate a discrete step signal.

    Parameters
    ----------
    t : array_like
        Time points of the output signal.
    t0 : float
        Time point of the step.
    y0 : float
        Value of the signal before the step.
    y1 : float
        Value of the signal after the step.

    Returns
    -------
    y : ndarray
        The values of the step signal at the given time points.
    """
    y = np.ones_like(t) * y0
    y[t >= t0] = y1
    return y

# Generate a discrete step signal
t = np.arange(0, 10, 0.1)
y = dstep(t, 5, 0, 1)

# Plot the signal
plt.plot(t, y)
plt.title('Discrete Step Signal')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.show()
Generated code for scipy.signal.dfreqresp


import numpy as np
from scipy import signal

def dfreqresp(b, a, worN=None, whole=False):
    """
    Compute the frequency response of a digital filter.
    
    The frequency response is evaluated for digital filters, by computing the
    filter's transfer function at a number of frequencies.  The frequency
    response is returned as a complex array.
    
    Parameters
    ----------
    b : array_like
        Numerator polynomial of the filter.
    a : array_like
        Denominator polynomial of the filter.
    worN : {None, int, array_like}, optional
        If `None`, then compute at 512 frequencies around the unit circle.
        If a single integer, then compute at that many frequencies.
        If an array_like, compute the response at the frequencies given
        (in radians/sample).
    whole : bool, optional
        Normally, frequencies are computed from 0 to pi (upper-half of
        unit-circle.  If `whole` is True, compute frequencies from 0 to 2*pi.

    Returns
    -------
    w : ndarray
        The frequencies at which h was computed, in radians/sample.
    h : ndarray
        The frequency response.
    
    """
    b, a = map(np.atleast_1d, (b, a))
    if worN is None:
        worN = 512
    if np.isscalar(worN):
        w = np.linspace(0, np.pi, worN, endpoint=False)
        if whole:
            w = np.concatenate((w, w[-2:0:-1]))
    else:
        w = np.asarray(worN)
    zm1 = np.exp(-1j * w)
    h = np.polyval(b[::-1], zm1) / np.polyval(a[::-1], zm1)
    return w, h
Generated code for scipy.signal.dbode


import scipy.signal as sig
import numpy as np

def dbode(sys, w):
    """
    Compute the dB magnitude and phase of a system at a given frequency.

    Parameters
    ----------
    sys : tuple
        A tuple of (num, den) containing the numerator and denominator
        polynomials of the system transfer function.
    w : float
        The frequency at which to compute the magnitude and phase.

    Returns
    -------
    mag : float
        The magnitude of the system at the given frequency in dB.
    phase : float
        The phase of the system at the given frequency in degrees.
    """
    # Compute the transfer function
    num, den = sys
    H = sig.lti(num, den)

    # Compute the frequency response
    w, mag, phase = H.freqresp(w)

    # Convert to dB
    mag = 20 * np.log10(mag)

    return mag, phase
Generated code for scipy.signal.tf2zpk


import numpy as np
from scipy.signal import tf2zpk

# Define transfer function
num = [1, 2, 3]
den = [1, 4, 6, 4]

# Convert to zeros, poles, and gain
z, p, k = tf2zpk(num, den)

# Print results
print('Zeros:', z)
print('Poles:', p)
print('Gain:', k)
Generated code for scipy.signal.tf2sos


import scipy.signal as signal

# Define transfer function
num = [1, 2, 3]
den = [4, 5, 6, 7]

# Convert to SOS form
sos = signal.tf2sos(num, den)

# Print SOS form
print(sos)
Generated code for scipy.signal.tf2ss


import numpy as np
from scipy import signal

def tf2ss(num, den):
    """
    Convert a transfer function to state-space form.

    Parameters
    ----------
    num : array_like
        numerator polynomial coefficients in descending powers
    den : array_like
        denominator polynomial coefficients in descending powers

    Returns
    -------
    A : ndarray
        State-space representation of transfer function
    B : ndarray
        State-space representation of transfer function
    C : ndarray
        State-space representation of transfer function
    D : ndarray
        State-space representation of transfer function

    """
    # Get the order of the numerator and denominator
    n_num = len(num)
    n_den = len(den)

    # Compute the state-space matrices
    A = np.zeros((n_den-1, n_den-1))
    B = np.zeros((n_den-1, 1))
    C = np.zeros((1, n_den-1))
    D = np.zeros((1, 1))

    # Fill in the A matrix
    for i in range(n_den-1):
        for j in range(n_den-1):
            if i == j+1:
                A[i, j] = den[j+1]
            else:
                A[i, j] = 0

    # Fill in the B matrix
    for i in range(n_den-1):
        B[i, 0] = -den[i+1]

    # Fill in the C matrix
    for i in range(n_den-1):
        C[0, i] = num[i]

    # Fill in the D matrix
    D[0, 0] = num[n_num-1]

    return A, B, C, D
Generated code for scipy.signal.zpk2tf


import numpy as np
from scipy.signal import zpk2tf

# Define the zeros, poles, and gain of the transfer function
zeros = np.array([-2, -3, -4])
poles = np.array([0.5, 1.2, 3.1])
gain = 5

# Convert the zeros, poles, and gain to a transfer function
num, den = zpk2tf(zeros, poles, gain)

# Print the transfer function
print('Transfer function:')
print('num =', num)
print('den =', den)
Generated code for scipy.signal.zpk2sos


import scipy.signal

def zpk2sos(z, p, k):
    sos = scipy.signal.zpk2sos(z, p, k)
    return sos

z = [1, 2, 3]
p = [4, 5, 6]
k = 7

sos = zpk2sos(z, p, k)
print(sos)
Generated code for scipy.signal.zpk2ss


import numpy as np
from scipy.signal import zpk2ss

# Define the zeros, poles, and gain of the system
zeros = np.array([-2, -3, -4])
poles = np.array([0.5, -0.5, -1.5])
gain = 5

# Convert the zpk to state-space
A, B, C, D = zpk2ss(zeros, poles, gain)

# Print the state-space matrices
print('A = \n', A)
print('B = \n', B)
print('C = \n', C)
print('D = \n', D)
Generated code for scipy.signal.ss2tf


import numpy as np
from scipy import signal

# Define the numerator and denominator polynomials
num = [1, 2, 3]
den = [1, 4, 5, 6]

# Convert the polynomials to transfer function
tf = signal.ss2tf(num, den)

# Print the transfer function
print(tf)
Generated code for scipy.signal.ss2zpk


import scipy.signal as sig

def ss2zpk(A, B, C, D):
    """
    Convert a state-space representation of a system to zero-pole-gain form.

    Parameters
    ----------
    A, B, C, D : array_like
        State-space representation of linear system.

    Returns
    -------
    z : ndarray
        Zeros of the system.
    p : ndarray
        Poles of the system.
    k : float
        System gain.

    """
    z, p, k = sig.tf2zpk(sig.ss2tf(A, B, C, D))
    return z, p, k
Generated code for scipy.signal.sos2zpk


import scipy.signal as sig

def sos2zpk(sos):
    """
    Convert a second-order section representation to zero-pole-gain form.

    Parameters
    ----------
    sos : array_like
        Array of second-order filter coefficients, must have shape (n_sections, 6).

    Returns
    -------
    z : ndarray
        Zeros of the transfer function.
    p : ndarray
        Poles of the transfer function.
    k : float
        System gain.
    """
    # Check input
    sos = sig.asarray(sos)
    if sos.ndim != 2 or sos.shape[1] != 6:
        raise ValueError('sos array must be shape (n_sections, 6)')

    # Pre-allocate output
    z = np.empty(0, dtype=complex)
    p = np.empty(0, dtype=complex)

    # Convert each section
    for section in sos:
        b = section[:3]
        a = section[3:]
        z_section, p_section, k_section = sig.tf2zpk(b, a)
        z = np.concatenate((z, z_section))
        p = np.concatenate((p, p_section))

    # Compute overall gain
    k = np.prod(sos[:, 0])

    return z, p, k
Generated code for scipy.signal.sos2tf


import numpy as np
from scipy.signal import sos2tf

# Define the SOS matrix
sos = np.array([[1, 2, 1, 1, 0, 0],
                [1, -2, 1, 0, 0, 0]])

# Convert SOS to transfer function
num, den = sos2tf(sos)

print('Numerator:', num)
print('Denominator:', den)
Generated code for scipy.signal.cont2discrete


import numpy as np
from scipy.signal import cont2discrete

# Define the continuous-time system
num = [1, 2]
den = [1, 4, 3]

# Define the sampling time
dt = 0.1

# Convert the system to discrete-time
[numd, dend] = cont2discrete((num, den), dt)

# Print the discrete-time system
print('Discrete-time system:')
print('Numerator:', numd)
print('Denominator:', dend)
Generated code for scipy.signal.place_poles


import numpy as np
from scipy import signal

def place_poles(A, B, poles):
    """
    Place the poles of a linear system.

    Parameters
    ----------
    A : array_like
        Numerator polynomial of the linear system.
    B : array_like
        Denominator polynomial of the linear system.
    poles : array_like
        Desired poles of the linear system.

    Returns
    -------
    A_new : ndarray
        Numerator polynomial of the linear system with the desired poles.
    B_new : ndarray
        Denominator polynomial of the linear system with the desired poles.

    """
    # Compute the transfer function
    s = signal.lti(A, B)
    # Compute the zeros and poles of the transfer function
    z, p, k = signal.tf2zpk(s.num, s.den)
    # Compute the new zeros and poles
    z_new, p_new, k_new = signal.zpk2tf(z, poles, k)
    # Compute the new numerator and denominator polynomials
    A_new, B_new = signal.zpk2tf(z_new, p_new, k_new)
    return A_new, B_new
Generated code for scipy.signal.chirp


import numpy as np
from scipy.signal import chirp

# Generate a linear chirp of 1 second duration that starts at 0 Hz and ends at 500 Hz
t = np.linspace(0, 1, 500)
w = chirp(t, f0=0, f1=500, t1=1, method='linear')

# Generate a logarithmic chirp of 1 second duration that starts at 0 Hz and ends at 500 Hz
t = np.linspace(0, 1, 500)
w = chirp(t, f0=0, f1=500, t1=1, method='logarithmic')
Generated code for scipy.signal.gausspulse


import numpy as np
from scipy import signal

def gausspulse(t, fc, bw, bwr=-6, tpr=-60, retquad=False, retenv=False):
    """
    Return a Gaussian modulated sinusoid:
    
    .. math::
        x(t) = A \\cos(2 \\pi f_c t + \\phi) \\exp \\left(-\\frac{t^2}{2 \\tau^2}\\right)
    
    where :math:`\\tau = \\frac{1}{2\\pi b_w}` is the Gaussian width,
    :math:`f_c` is the center frequency, and :math:`b_w` is the fractional
    bandwidth in octaves (between -3 dB points of the Gaussian).
    
    Parameters
    ----------
    t : array_like
        Time vector or scalar.
    fc : float
        Center frequency of sinusoid.
    bw : float
        Fractional bandwidth in octaves (between -3 dB points of the
        Gaussian).
    bwr : float, optional
        Reference level at which fractional bandwidth is calculated (dB).
    tpr : float, optional
        Peak level of Gaussian envelope (dB).
    retquad : bool, optional
        If True, return the real and imaginary parts of the complex
        sinusoid.
    retenv : bool, optional
        If True, return the envelope of the sinusoid.
    
    Returns
    -------
    x : ndarray
        The modulated sinusoid.
    xa : ndarray
        Real part of `x` (if `retquad` is True).
    xb : ndarray
        Imaginary part of `x` (if `retquad` is True).
    env : ndarray
        The envelope of the sinusoid (if `retenv` is True).
    
    See Also
    --------
    chirp : Frequency-swept cosine generator.
    gauss : Gaussian pulse generator.
    sweep_poly : Frequency-swept cosine generator (polynom
Generated code for scipy.signal.max_len_seq


import numpy as np
from scipy.signal import max_len_seq

# Generate a maximum length sequence
x = max_len_seq(7)

# Print the sequence
print(x)

# Compute the autocorrelation of the sequence
r = np.correlate(x, x, mode='full')

# Print the autocorrelation
print(r)
Generated code for scipy.signal.sawtooth


import numpy as np
from scipy.signal import sawtooth

# Generate a sawtooth waveform with a frequency of 1 Hz
t = np.linspace(0, 1, 500, endpoint=False)
saw = sawtooth(2 * np.pi * 1 * t)

# Plot the waveform
import matplotlib.pyplot as plt
plt.plot(t, saw)
plt.xlabel("Time [s]")
plt.ylabel("Amplitude")
plt.show()
Generated code for scipy.signal.square


import numpy as np
from scipy import signal

def square(t, duty):
    """
    Generate a square wave with given duty cycle.

    Parameters
    ----------
    t : array_like
        Time.
    duty : float
        Duty cycle, must be in the interval [0,1].

    Returns
    -------
    y : ndarray
        Square wave of the given duty cycle.

    """
    y = signal.square(2 * np.pi * t, duty)
    return y
Generated code for scipy.signal.sweep_poly


import numpy as np
from scipy.signal import sweep_poly

# Define the numerator and denominator polynomials
num = [1, 0, 0]
den = [1, 0.2, 0.3]

# Generate the sweep signal
t, x = sweep_poly(num, den)

# Plot the sweep signal
plt.plot(t, x)
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('Sweep Signal')
plt.show()
Generated code for scipy.signal.unit_impulse


import numpy as np
from scipy.signal import unit_impulse

# Generate a unit impulse signal
impulse_signal = unit_impulse(10, 'mid')

# Print the signal
print(impulse_signal)

# Output:
# [0. 0. 0. 1. 0. 0. 0. 0. 0. 0.]
Generated code for scipy.signal.get_window


import numpy as np
from scipy.signal import get_window

def get_window(window, Nx, fftbins=True):
    """
    Return a window of length Nx and type window.
    
    Parameters
    ----------
    window : string, float, or tuple
        The type of window to create. See `scipy.signal.get_window`
        for a list of windows and required parameters.
    Nx : int
        The number of samples in the window.
    fftbins : bool, optional
        If True, create a periodic window for use with FFT
        (creates a Hanning window by default).
    
    Returns
    -------
    w : ndarray
        The window of length Nx
    """
    if fftbins:
        return get_window(window, Nx, fftbins=True)
    else:
        return get_window(window, Nx)
Generated code for scipy.signal.cascade


import scipy.signal as sig

def cascade(b, a):
    """
    Cascade two IIR filter stages.

    Parameters
    ----------
    b : array_like
        Numerator coefficients of the first stage.
    a : array_like
        Denominator coefficients of the first stage.

    Returns
    -------
    b_out : ndarray
        Numerator coefficients of the output filter.
    a_out : ndarray
        Denominator coefficients of the output filter.

    """
    # Get the numerator and denominator coefficients of the first stage
    b1, a1 = sig.tf2zpk(b, a)

    # Get the numerator and denominator coefficients of the second stage
    b2, a2 = sig.tf2zpk(b, a)

    # Cascade the two stages
    b_out, a_out = sig.cascade(b1, a1, b2, a2)

    return b_out, a_out
Generated code for scipy.signal.daub


import numpy as np
from scipy.signal import daub

# Define the length of the signal
N = 64

# Generate a random signal
x = np.random.randn(N)

# Compute the Daubechies wavelet transform of the signal
coeffs = daub(x, 4)

# Reconstruct the signal from the wavelet coefficients
x_rec = daub(coeffs, 4, inverse=True)

# Compare the original and reconstructed signals
print(np.allclose(x, x_rec))
Generated code for scipy.signal.morlet


import numpy as np
from scipy.signal import morlet

def morlet_wavelet(M, w=5.0, s=1.0):
    """
    Morlet wavelet function.
    
    Parameters
    ----------
    M : int
        Length of the wavelet.
    w : float, optional
        Omega0. Default is 5.
    s : float, optional
        Scaling factor, default is 1.
        
    Returns
    -------
    morlet_wavelet : (M,) ndarray
        Morlet wavelet.
    """
    x = np.linspace(-np.pi, np.pi, M)
    y = np.exp(1j * w * x)
    y *= np.exp(-0.5 * (x ** 2))
    return y / np.sqrt(s * np.sum(np.abs(y) ** 2))

# Generate the Morlet wavelet
morlet_wavelet = morlet_wavelet(M=128, w=5.0, s=1.0)

# Plot the Morlet wavelet
plt.plot(morlet_wavelet.real)
plt.title('Morlet Wavelet')
plt.xlabel('Time (samples)')
plt.ylabel('Amplitude')
plt.show()
Generated code for scipy.signal.qmf


def qmf(x, h):
    """
    Compute the Quadrature Mirror Filter (QMF) of a signal.
    
    Parameters
    ----------
    x : array_like
        Input signal.
    h : array_like
        Filter coefficients.
    
    Returns
    -------
    y : ndarray
        The QMF of the signal.
    
    """
    # Make sure x and h are numpy arrays
    x = np.asarray(x)
    h = np.asarray(h)
    
    # Compute the length of the input signal
    N = len(x)
    
    # Compute the length of the filter
    M = len(h)
    
    # Compute the length of the output signal
    L = N + M - 1
    
    # Compute the QMF of the signal
    y = np.zeros(L)
    for n in range(L):
        for m in range(M):
            if n-m >= 0 and n-m < N:
                y[n] += h[m] * x[n-m]
    
    return y
Generated code for scipy.signal.ricker


import numpy as np
from scipy.signal import ricker

def ricker_wavelet(points, a):
    """
    Return a Ricker wavelet, also known as the Mexican hat wavelet.
    
    It models the function:
    
        ``A (1 - x^2/a^2) exp (-t^2/a^2)``,
    
    where ``A = 2/sqrt(3a)pi^1/4``
    
    Parameters
    ----------
    points : int
        Number of points in `vector`.
    a : scalar
        Width parameter of the wavelet.
    
    Returns
    -------
    vector : (N,) ndarray
        Array of length `points` in the form of a Ricker wavelet.
    
    Examples
    --------
    >>> from scipy.signal import ricker_wavelet
    >>> import matplotlib.pyplot as plt
    >>> points = 100
    >>> a = 4.0
    >>> vec = ricker_wavelet(points, a)
    >>> plt.plot(vec)
    >>> plt.show()
    """
    A = 2 / np.sqrt(3 * a) * np.pi**(1/4)
    wsq = a**2
    vec = np.arange(points) - (points - 1.0) / 2
    xsq = vec**2
    mod = (1 - xsq / wsq)
    ricker = A * mod * np.exp(-xsq / (2 * wsq))
    return ricker
Generated code for scipy.signal.morlet2


import numpy as np
from scipy.signal import morlet2

def morlet2(M, w=5.0, s=1.0):
    """
    Morlet wavelet function.
    
    Parameters
    ----------
    M : int
        Length of the wavelet.
    w : float, optional
        Omega0. Default is 5.
    s : float, optional
        Scaling factor, default 1.
        
    Returns
    -------
    x : ndarray
        Wavelet function.
    
    """
    x = np.arange(0, M) - (M - 1.0) / 2.0
    x = x / s
    y = np.exp(1j * w * x)
    y = y * np.exp(-0.5 * (x ** 2))
    return y
Generated code for scipy.signal.cwt


import numpy as np
from scipy import signal

# Generate a signal with two frequencies
t = np.linspace(0, 10, 500)
sig = np.sin(2 * np.pi * t) + np.sin(4 * np.pi * t)

# Compute the continuous wavelet transform
widths = np.arange(1, 31)
cwtmatr = signal.cwt(sig, signal.ricker, widths)

# Plot the CWT
plt.imshow(cwtmatr, extent=[-1, 1, 1, 31], cmap='PRGn', aspect='auto',
           vmax=abs(cwtmatr).max(), vmin=-abs(cwtmatr).max())
plt.show()
Generated code for scipy.signal.cwt


import numpy as np
from scipy import signal

# Generate a signal with two frequencies
t = np.linspace(0, 10, 500)
sig = np.sin(2 * np.pi * t) + np.sin(4 * np.pi * t)

# Compute the continuous wavelet transform
widths = np.arange(1, 31)
cwtmatr = signal.cwt(sig, signal.ricker, widths)

# Plot the CWT
plt.imshow(cwtmatr, extent=[-1, 1, 1, 31], cmap='PRGn', aspect='auto',
           vmax=abs(cwtmatr).max(), vmin=-abs(cwtmatr).max())
plt.show()
Generated code for scipy.signal.argrelmin


import numpy as np
from scipy.signal import argrelmin

# Create a sample array
x = np.array([2, 1, 2, 3, 2, 0, 1, 0, 1, 0, 2, 1])

# Find the indices of the local minima
min_indices = argrelmin(x)[0]

# Print the indices
print(min_indices)
Generated code for scipy.signal.argrelmax


import numpy as np
from scipy.signal import argrelmax

# Create a sample array
x = np.array([2, 1, 2, 3, 2, 0, 1, 0, 1, 0, 2, 1])

# Find the relative maxima
maxima = argrelmax(x)

# Print the indices of the maxima
print(maxima[0])

# Output:
# array([3, 10])
Generated code for scipy.signal.argrelextrema


import numpy as np
from scipy.signal import argrelextrema

# Create a sample array
arr = np.array([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])

# Find the local maxima
maxima = argrelextrema(arr, np.greater)

# Print the maxima
print(maxima)
Generated code for scipy.signal.find_peaks


import numpy as np
from scipy.signal import find_peaks

# Generate some data
x = np.linspace(0, 10, 1000)
y = np.sin(x)

# Find peaks
peaks, _ = find_peaks(y, height=0)

# Plot the data
import matplotlib.pyplot as plt
plt.plot(x, y)
plt.plot(x[peaks], y[peaks], "x")
plt.show()
Generated code for scipy.signal.find_peaks_cwt


import numpy as np
from scipy.signal import find_peaks_cwt

# Generate some data
x = np.linspace(0, 10, 1000)
y = np.sin(x)

# Find peaks
peaks = find_peaks_cwt(y, np.arange(1, 10))

# Print the peaks
print(peaks)
Generated code for scipy.signal.peak_prominences


import numpy as np
from scipy.signal import peak_prominences

# Generate a signal
x = np.linspace(0, 10, 1000)
y = np.sin(x)

# Find the peak prominences
prominences, _ = peak_prominences(y, x)

# Print the prominences
print(prominences)
Generated code for scipy.signal.peak_widths


import numpy as np
from scipy.signal import peak_widths

# Generate a noisy peak
x = np.linspace(0, 10, 100)
y = np.exp(-x/2) + np.random.randn(100)/10

# Calculate peak widths
widths, _ = peak_widths(y, x, rel_height=0.5)

# Print peak widths
print(widths)
Generated code for scipy.signal.periodogram


import numpy as np
from scipy import signal

# Generate a test signal
fs = 10e3
N = 1e5
amp = 2*np.sqrt(2)
freq = 1234.0
noise_power = 0.001 * fs / 2
time = np.arange(N) / fs
x = amp*np.sin(2*np.pi*freq*time)
x += np.random.normal(scale=np.sqrt(noise_power), size=time.shape)

# Compute and plot the periodogram
f, Pxx_den = signal.periodogram(x, fs)

# Plot the power spectral density
import matplotlib.pyplot as plt
plt.semilogy(f, Pxx_den)
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
Generated code for scipy.signal.welch


import numpy as np
from scipy import signal

# Generate a test signal, a 2 Vrms sine wave at 1234 Hz, corrupted by 0.001 V**2/Hz of white noise sampled at 10 kHz.

fs = 10e3
N = 1e5
amp = 2*np.sqrt(2)
freq = 1234.0
noise_power = 0.001 * fs / 2
time = np.arange(N) / fs
x = amp*np.sin(2*np.pi*freq*time)
x += np.random.normal(scale=np.sqrt(noise_power), size=time.shape)

# Compute and plot the power spectral density.

f, Pxx_den = signal.welch(x, fs, nperseg=1024)
plt.semilogy(f, Pxx_den)
plt.ylim([0.5e-3, 1])
plt.xlabel('frequency [Hz]')
plt.ylabel('PSD [V**2/Hz]')
plt.show()
Generated code for scipy.signal.csd


import numpy as np
from scipy import signal

def csd(x, y, fs=1.0, window='boxcar', nperseg=None, noverlap=None,
        nfft=None, detrend='constant', return_onesided=True,
        scaling='density', axis=-1):
    """
    Estimate the cross spectral density, Pxy, using Welch's method.
    Parameters
    ----------
    x : array_like
        Time series of measurement values
    y : array_like
        Time series of measurement values
    fs : float, optional
        Sampling frequency of the `x` and `y` time series. Defaults
        to 1.0.
    window : str or tuple or array_like, optional
        Desired window to use. If `window` is a string or tuple, it is
        passed to `get_window` to generate the window values, which are
        DFT-even by default. See `get_window` for a list of windows and
        required parameters. If `window` is array_like it will be used
        directly as the window and its length must be nperseg. Defaults
        to 'boxcar'.
    nperseg : int, optional
        Length of each segment. Defaults to None, but if window is str or
        tuple, is set to 256, and if window is array_like, is set to the
        length of the window.
    noverlap : int, optional
        Number of points to overlap between segments. If `None`,
        ``noverlap = nperseg // 2``. Defaults to `None`.
    nfft : int, optional
        Length of the FFT used, if a zero padded FFT is desired. If
        `None`, the FFT length is `nperseg`. Defaults to `None`.
    detrend : str or function or `False`, optional
        Specifies how to detrend each segment. If `detrend` is a
        string, it is passed as the `type` argument to the `detrend`
        function. If it is a function, it takes a segment and returns a
        detrended segment. If
Generated code for scipy.signal.coherence


import numpy as np
from scipy import signal

def coherence(x, y, fs=1.0, window='hanning', nperseg=256, noverlap=None, nfft=None, detrend='constant', return_onesided=True, scaling='density', axis=-1):
    """
    Estimate the magnitude squared coherence estimate, Cxy, of discrete-time signals x and y.
    
    Parameters
    ----------
    x : array_like
        Array of at least two dimensions. The cross-spectral density is estimated
        along the last axis.
    y : array_like
        Array of at least two dimensions. The cross-spectral density is estimated
        along the last axis.
    fs : float, optional
        Sampling frequency of the `x` and `y` time series. Defaults to 1.0.
    window : str or tuple or array_like, optional
        Desired window to use. See `scipy.signal.get_window` for a list of windows
        and required parameters. If `window` is array_like it will be used directly
        as the window and its length will be used for nperseg. Defaults to 'hanning'.
    nperseg : int, optional
        Length of each segment. Defaults to 256.
    noverlap : int, optional
        Number of points to overlap between segments. If `None`,
        ``noverlap = nperseg // 2``. Defaults to `None`.
    nfft : int, optional
        Length of the FFT used, if a zero padded FFT is desired. If `None`,
        the FFT length is `nperseg`. Defaults to `None`.
    detrend : str or function or `False`, optional
        Specifies how to detrend each segment. If `detrend` is a string, it is
        passed as the `type` argument to the `scipy.signal.detrend` function.
        If it is a function, it takes a segment and returns a detrended segment.
        If `detrend` is `False`, no detrending is done. Defaults to 'constant'.
Generated code for scipy.signal.spectrogram


import numpy as np
from scipy import signal

# Generate a test signal, a 2 Vrms sine wave at 1234 Hz, corrupted by
# 0.001 V**2/Hz of white noise sampled at 10 kHz.
fs = 10e3
N = 1e5
amp = 2*np.sqrt(2)
freq = 1234.0
noise_power = 0.001 * fs / 2
time = np.arange(N) / fs
x = amp*np.sin(2*np.pi*freq*time)
x += np.random.normal(scale=np.sqrt(noise_power), size=time.shape)

# Compute and plot the spectrogram.
f, t, Sxx = signal.spectrogram(x, fs)

# Plot the spectrogram
import matplotlib.pyplot as plt
plt.pcolormesh(t, f, Sxx)
plt.ylabel('Frequency [Hz]')
plt.xlabel('Time [sec]')
plt.show()
Generated code for scipy.signal.lombscargle


import numpy as np
from scipy.signal import lombscargle

# Generate some data
x = np.linspace(0, 10, 100)
y = np.sin(x)

# Compute the Lomb-Scargle periodogram
frequency, power = lombscargle(x, y, normalize=True)

# Plot the results
import matplotlib.pyplot as plt
plt.plot(frequency, power)
plt.xlabel('Frequency')
plt.ylabel('Power')
plt.show()
Generated code for scipy.signal.vectorstrength


import numpy as np
from scipy.signal import vectorstrength

# Generate a signal with a known period
fs = 1000
t = np.arange(0, 2, 1/fs)
x = np.sin(2*np.pi*t*10)

# Calculate the vector strength
periods, vector_strength = vectorstrength(x, fs)

# Print the results
print('Periods:', periods)
print('Vector Strength:', vector_strength)
Generated code for scipy.signal.stft


import numpy as np
from scipy import signal

def stft(x, fs, framesz, hop):
    framesamp = int(framesz*fs)
    hopsamp = int(hop*fs)
    w = signal.hann(framesamp)
    X = np.array([np.fft.rfft(w*x[i:i+framesamp]) 
                  for i in range(0, len(x)-framesamp, hopsamp)])
    return X
Generated code for scipy.signal.istft


import numpy as np
from scipy.signal import istft

# Input signal
x = np.random.randn(1024)

# Parameters
nperseg = 256
noverlap = 128

# Compute the STFT
f, t, X = istft(x, fs=1.0, window='hann', nperseg=nperseg, noverlap=noverlap, boundary=True)

# Plot the signal
plt.plot(f, np.abs(X))
plt.xlabel('Frequency [Hz]')
plt.ylabel('STFT Magnitude')
plt.show()
Generated code for scipy.signal.check_COLA


import scipy.signal as sig

def check_COLA(x, fs):
    """
    Check if a signal satisfies the Constant OverLap Add (COLA)
    constraint.

    Parameters
    ----------
    x : array_like
        Input signal.
    fs : float
        Sampling frequency of the `x` signal.

    Returns
    -------
    cola : bool
        True if `x` satisfies the COLA constraint, False otherwise.

    """
    # Compute the frame length
    N = len(x)
    # Compute the hop size
    H = int(N/2)
    # Compute the number of frames
    n_frames = int(N/H)
    # Initialize the cola flag
    cola = True
    # Iterate over the frames
    for i in range(n_frames):
        # Compute the start and end indices of the frame
        start = i*H
        end = start + N
        # Compute the frame
        frame = x[start:end]
        # Compute the frame energy
        energy = sig.linalg.norm(frame)
        # Check if the energy is constant
        if energy != N:
            cola = False
            break
    return cola
Generated code for scipy.signal.check_NOLA


import scipy.signal as signal

def check_NOLA(x, fs):
    """
    Checks if a signal is non-overlapping and linear-amplitude (NOLA).
    
    Parameters
    ----------
    x : array_like
        Input signal.
    fs : float
        Sampling frequency of the `x` signal.
    
    Returns
    -------
    bool
        True if the signal is NOLA, False otherwise.
    
    """
    # Compute the autocorrelation of the signal
    rxx = signal.correlate(x, x, mode='full')
    
    # Compute the maximum value of the autocorrelation
    max_rxx = max(rxx)
    
    # Compute the maximum value of the signal
    max_x = max(abs(x))
    
    # Compute the minimum value of the signal
    min_x = min(abs(x))
    
    # Compute the ratio between the maximum and minimum values
    ratio = max_x / min_x
    
    # Check if the signal is NOLA
    if (max_rxx < (fs * max_x)) and (ratio < 1.1):
        return True
    else:
        return False
Generated code for scipy.signal.czt


import numpy as np
from scipy.signal import czt

def czt_func(x, M, w):
    """
    Computes the chirp z-transform of a signal x using the
    chirp z-transform algorithm.
    
    Parameters
    ----------
    x : array_like
        Input signal.
    M : int
        Length of the output.
    w : array_like
        Chirp rate.
    
    Returns
    -------
    out : ndarray
        Chirp z-transform of x.
    """
    N = len(x)
    out = np.zeros(M, dtype=np.complex)
    for k in range(M):
        for n in range(N):
            out[k] += x[n] * np.exp(-1j * w[k] * n)
    return out

# Example
x = np.array([1, 2, 3, 4, 5, 6, 7, 8])
M = 8
w = np.linspace(0, np.pi, M)

# Compare with scipy.signal.czt
out1 = czt_func(x, M, w)
out2 = czt(x, M, w)

print(np.allclose(out1, out2))
# True
Generated code for scipy.signal.zoom_fft


import numpy as np
from scipy.signal import get_window

def zoom_fft(x, M, N, window=None):
    """
    Zoom the FFT of a signal.
    
    Parameters
    ----------
    x : array_like
        Input signal.
    M : int
        Length of the FFT.
    N : int
        Length of the output signal.
    window : array_like, optional
        Window to apply to the signal.
        If None, no window is applied.
    
    Returns
    -------
    y : ndarray
        The zoomed FFT of the input signal.
    
    """
    # Get window
    if window is None:
        window = np.ones(M)
    else:
        window = get_window(window, M)
    
    # Compute FFT
    X = np.fft.fft(x * window, M)
    
    # Zoom FFT
    Y = np.zeros(N, dtype=np.complex)
    Y[:M//2] = X[:M//2]
    Y[N-M//2:] = X[M//2:]
    
    # Compute inverse FFT
    y = np.fft.ifft(Y).real
    
    return y
Generated code for scipy.signal.CZT


import numpy as np
from scipy.signal import czt

def CZT(x, M, w):
    """
    Computes the Chirp Z-Transform of a signal x.
    
    Parameters
    ----------
    x : array_like
        Input signal.
    M : int
        Length of the output.
    w : array_like
        Chirp rate.
    
    Returns
    -------
    X : ndarray
        Chirp Z-Transform of x.
    """
    N = len(x)
    X = np.zeros(M, dtype=np.complex)
    for m in range(M):
        for n in range(N):
            X[m] += x[n] * np.exp(-1j * w[m] * n)
    return X
Generated code for scipy.signal.ZoomFFT


import numpy as np
from scipy import signal

def ZoomFFT(x, fs, zoom_factor):
    """
    Computes the zoomed FFT of a signal.
    
    Parameters
    ----------
    x : array_like
        Input signal.
    fs : float
        Sampling frequency of the x time series.
    zoom_factor : float
        Zoom factor.
    
    Returns
    -------
    f : array_like
        Array of sample frequencies.
    X : array_like
        Zoomed FFT of x.
    """
    # Compute the FFT of the signal
    X = np.fft.fft(x)
    # Compute the corresponding frequencies
    f = np.fft.fftfreq(len(x), 1/fs)
    # Zoom the FFT
    X_zoomed = signal.resample(X, int(len(X)*zoom_factor))
    # Compute the corresponding frequencies
    f_zoomed = np.fft.fftfreq(len(X_zoomed), 1/fs)
    return f_zoomed, X_zoomed
Generated code for scipy.signal.czt_points


import numpy as np
from scipy.signal import czt_points

# Define the parameters
N = 10  # Number of points
a = 0.5  # Lower bound
b = 1.5  # Upper bound

# Generate the points
points = czt_points(N, a, b)

# Print the points
print(points)
Generated code for numpy.ma.MaskType


import numpy as np

class MaskType:
    """
    A class for representing a type of mask in a numpy masked array.
    
    Attributes
    ----------
    name : str
        The name of the mask type.
    value : int
        The numerical value of the mask type.
    description : str
        A description of the mask type.
    """
    
    def __init__(self, name, value, description):
        """
        Initialize a MaskType object.
        
        Parameters
        ----------
        name : str
            The name of the mask type.
        value : int
            The numerical value of the mask type.
        description : str
            A description of the mask type.
        """
        self.name = name
        self.value = value
        self.description = description
        
    def __repr__(self):
        """
        Return a string representation of the MaskType object.
        """
        return f"MaskType(name={self.name}, value={self.value}, description={self.description})"
    
    def __eq__(self, other):
        """
        Check if two MaskType objects are equal.
        """
        if isinstance(other, MaskType):
            return (self.name == other.name and
                    self.value == other.value and
                    self.description == other.description)
        else:
            return False
    
    def __ne__(self, other):
        """
        Check if two MaskType objects are not equal.
        """
        return not self.__eq__(other)
    
    def to_mask(self):
        """
        Convert the MaskType object to a numpy mask.
        """
        return np.ma.masked_equal(np.arange(self.value), self.value)
Generated code for numpy.bool_


import numpy as np

def bool_func(x):
    return np.array(x, dtype=bool)

x = [True, False, 0, 1]

bool_func(x)
Generated code for numpy.ma.masked_array


import numpy as np

# Create a masked array
x = np.ma.masked_array(np.arange(10), fill_value=-999)

# Mask the first three elements
x[:3] = np.ma.masked

# Print the masked array
print(x)

# Output:
# masked_array(data=[--, --, --, 3, 4, 5, 6, 7, 8, 9],
#              mask=[ True,  True,  True, False, False, False, False,
#                     False, False, False],
#        fill_value=-999)
Generated code for numpy.ma.array


import numpy as np

# Create a masked array
x = np.ma.array([1,2,3,4], mask=[0,1,0,1])

# Print the masked array
print(x)

# Access the elements of the array
print(x[0])
print(x[1])
print(x[2])
print(x[3])

# Access the mask of the array
print(x.mask)

# Change the mask of the array
x.mask = [1,0,1,0]

# Print the new mask
print(x.mask)
Generated code for numpy.ma.copy


import numpy as np

def copy(a):
    """
    Return a copy of an array.

    Parameters
    ----------
    a : array_like
        Input data, in any form that can be converted to an array.  This
        includes lists, lists of tuples, tuples, tuples of tuples, tuples
        of lists and ndarrays.

    Returns
    -------
    arr : ndarray
        A copy of `a`.

    """
    arr = np.ma.array(a, copy=True)
    return arr
Generated code for numpy.ma.frombuffer


import numpy as np

def frombuffer(buffer, dtype=float, count=-1, offset=0):
    """
    Construct an array from a buffer object.

    Parameters
    ----------
    buffer : buffer_like
        An object that exposes the buffer interface.
    dtype : data-type, optional
        Data type of the returned array.
    count : int, optional
        Number of items to read. -1 means all data in the buffer.
    offset : int, optional
        Start position to read from.

    Returns
    -------
    arr : ndarray
        The constructed array.
    """
    arr = np.frombuffer(buffer, dtype, count, offset)
    return np.ma.masked_array(arr)
Generated code for numpy.ma.fromfunction


import numpy as np

def my_function(x, y):
    return x*y

x, y = np.meshgrid(np.arange(0,2), np.arange(0,3))

result = np.ma.fromfunction(my_function, (x, y))

print(result)
Generated code for numpy.ma.MaskedArray.copy


import numpy as np

def copy(arr):
    """
    Return a copy of a MaskedArray.

    Parameters
    ----------
    arr : MaskedArray
        The array to be copied.

    Returns
    -------
    out : MaskedArray
        A copy of `arr`.

    """
    out = np.ma.MaskedArray(arr.data.copy(), mask=arr.mask.copy())
    return out
Generated code for numpy.ma.empty


import numpy as np

# Create an empty masked array
empty_ma = np.ma.empty(shape=(3,3))

# Mask all elements
empty_ma.mask = True

# Print the masked array
print(empty_ma)
Generated code for numpy.ma.empty_like


import numpy as np

# Create an empty array with the same shape and type as the given array
def empty_like(arr):
    return np.ma.empty_like(arr)

# Example
arr = np.array([[1,2,3], [4,5,6]])
empty_arr = empty_like(arr)
print(empty_arr)

# Output
# [[-- -- --]
#  [-- -- --]]
Generated code for numpy.ma.masked_all


import numpy as np

masked_array = np.ma.masked_all((3,3))

print(masked_array)

# Output
[[-- -- --]
 [-- -- --]
 [-- -- --]]
Generated code for numpy.ma.masked_all_like


import numpy as np

masked_all_like = np.ma.masked_all_like(np.zeros((3,3)))
print(masked_all_like)
Generated code for numpy.ma.ones


import numpy as np

# Create a 2x3 array of ones
arr = np.ma.ones((2,3))

# Print the array
print(arr)
Generated code for numpy.ma.ones_like


import numpy as np

# Create a numpy array
arr = np.array([[1, 2, 3], [4, 5, 6]])

# Create a masked array with the same shape as arr
masked_arr = np.ma.ones_like(arr)

# Print the masked array
print(masked_arr)
Generated code for numpy.ma.zeros


import numpy as np

# Create a masked array of zeros
masked_zeros = np.ma.zeros(shape=(3,3))

# Print the masked array
print(masked_zeros)
Generated code for numpy.ma.zeros_like


import numpy as np

# Create a numpy array
arr = np.array([[1, 2, 3], [4, 5, 6]])

# Create a masked array with zeros
masked_arr = np.ma.zeros_like(arr)

# Print the masked array
print(masked_arr)
Generated code for numpy.ma.all
close

import numpy as np

def allclose(a, b, rtol=1e-5, atol=1e-8):
    """
    Returns True if two arrays are element-wise equal within a tolerance.

    The tolerance values are positive, typically very small numbers. The
    relative difference (`rtol` * abs(`b`)) and the absolute difference
    `atol` are added together to compare against the absolute difference
    between `a` and `b`.

    Parameters
    ----------
    a, b : array_like
        Input arrays to compare.
    rtol : float
        The relative tolerance parameter (see Notes).
    atol : float
        The absolute tolerance parameter (see Notes).

    Returns
    -------
    allclose : bool
        Returns True if the two arrays are equal within the given
        tolerance; False otherwise.

    See Also
    --------
    all, any, where

    Notes
    -----
    If the following equation is element-wise True, then allclose returns
    True.

        absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))

    The above equation is not symmetric in `a` and `b`, so that
    `allclose(a, b)` might be different from `allclose(b, a)` in
    some rare cases.

    Examples
    --------
    >>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])
    False
    >>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])
    True
    >>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])
    False
    >>> np.allclose([1.0, np.nan], [1.0, np.nan])
    True

    """
    a = np.asanyarray(a)
    b = np.asanyarray(b)
    return np.all(np.less_equal(np.abs(a - b
Generated code for numpy.ma.any


import numpy as np

def numpy_ma_any(arr):
    """
    Returns True if any of the elements of the array are non-zero, False otherwise.
    """
    return np.ma.any(arr)
Generated code for numpy.ma.count


import numpy as np

def count(arr):
    # Create a mask of valid values
    mask = np.ma.masked_invalid(arr).mask
    # Count the number of valid values
    return np.sum(~mask)

# Example
arr = np.array([1, 2, np.nan, 3, 4])
print(count(arr)) # Output: 4
Generated code for numpy.ma.count_masked


import numpy as np

def count_masked(arr):
    """
    Counts the number of masked elements in a numpy.ma array.
    Parameters
    ----------
    arr : numpy.ma array
        The array to count the masked elements in.
    Returns
    -------
    int
        The number of masked elements in the array.
    """
    return np.sum(arr.mask)
Generated code for numpy.ma.getmask
array

import numpy as np

def getmaskarray(mask):
    """
    Return a boolean array from a mask.

    Parameters
    ----------
    mask : array_like
        Mask array.

    Returns
    -------
    result : ndarray
        Boolean array with the same shape as `mask`.

    Examples
    --------
    >>> x = np.ma.array([1, 2, 3], mask=[0, 1, 0])
    >>> np.ma.getmaskarray(x)
    array([False,  True, False])

    """
    return np.array(mask, dtype=bool)
Generated code for numpy.ma.getmaskarray


import numpy as np

def getmaskarray(mask):
    """
    Return a boolean array from a mask.

    Parameters
    ----------
    mask : array_like
        Mask array.

    Returns
    -------
    result : ndarray
        Boolean array with the same shape as `mask`.

    Examples
    --------
    >>> x = np.ma.array([1, 2, 3], mask=[0, 1, 0])
    >>> np.ma.getmaskarray(x)
    array([False,  True, False])

    """
    return np.array(mask, dtype=bool)
Generated code for numpy.ma.getdata


import numpy as np

def getdata(arr):
    return np.ma.getdata(arr)

#Example
arr = np.ma.array([1,2,3,4], mask=[0,1,0,1])
print(getdata(arr))
# Output: [1 3]
Generated code for numpy.ma.nonzero


import numpy as np

def nonzero(arr):
    # Create a boolean array
    bool_arr = np.ma.masked_equal(arr, 0).mask
    # Get indices of non-zero elements
    non_zero_indices = np.nonzero(bool_arr)
    # Return the indices
    return non_zero_indices
Generated code for numpy.ma.shape


import numpy as np

arr = np.ma.array([[1,2,3], [4,5,6], [7,8,9]])

shape = np.ma.shape(arr)

print(shape)
Generated code for numpy.ma.size


import numpy as np

# Create a masked array
x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[[0,1,0], [1,0,1], [0,1,0]])

# Get the size of the masked array
np.ma.size(x)
Generated code for numpy.ma.is_masked


import numpy as np

def is_masked(a):
    """
    Checks if an array is masked.

    Parameters
    ----------
    a : array_like
        Input array.

    Returns
    -------
    result : bool
        True if `a` is a masked array, False otherwise.

    """
    return isinstance(a, np.ma.MaskedArray)
Generated code for numpy.ma.is_mask


import numpy as np

def is_mask(a):
    """
    Returns True if a is a valid mask array, False otherwise.

    Parameters
    ----------
    a : array_like
        Input array.

    Returns
    -------
    out : bool
        True if `a` is a valid mask array, False otherwise.

    See Also
    --------
    numpy.ma.make_mask
    """
    a = np.asarray(a)
    if a.dtype != np.bool_:
        return False
    if a.ndim == 0:
        return False
    if a.ndim > 1 and a.shape[0] != a.shape[1]:
        return False
    return True
Generated code for numpy.ma.isMaskedArray


import numpy as np

def isMaskedArray(arr):
    """
    Checks if the given array is a masked array.

    Parameters
    ----------
    arr : array_like
        The array to check.

    Returns
    -------
    bool
        True if the array is a masked array, False otherwise.
    """
    return isinstance(arr, np.ma.MaskedArray)
Generated code for numpy.ma.isMA


import numpy as np

def isMA(x):
    """
    Checks if an array is a MaskedArray.

    Parameters
    ----------
    x : array_like
        Input array.

    Returns
    -------
    out : bool
        True if `x` is a MaskedArray, False otherwise.

    """
    return isinstance(x, np.ma.MaskedArray)
Generated code for numpy.ma.isarray


def isarray(x):
    """
    Checks if x is a numpy array.

    Parameters
    ----------
    x : object
        The object to check.

    Returns
    -------
    bool
        True if x is a numpy array, False otherwise.
    """
    return isinstance(x, np.ndarray) or isinstance(x, np.ma.MaskedArray)
Generated code for numpy.ma.MaskedArray.all


import numpy as np

def all(arr):
    """
    Returns True if all elements of the array are non-zero, False otherwise.
    
    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to be tested.
    
    Returns
    -------
    bool
        True if all elements of the array are non-zero, False otherwise.
    """
    # Check if array is empty
    if arr.size == 0:
        return False
    
    # Check if all elements are non-zero
    for element in np.ma.MaskedArray.compressed(arr):
        if element == 0:
            return False
    
    return True
Generated code for numpy.ma.MaskedArray.any


import numpy as np

def any(a, axis=None):
    """
    Test whether any array element along a given axis evaluates to True.

    Parameters
    ----------
    a : array_like
        Input array or object that can be converted to an array.
    axis : int, optional
        Axis along which a logical OR reduction is performed.
        The default (axis = None) is to perform a logical OR over all
        the dimensions of the input array.

    Returns
    -------
    any : bool or ndarray
        A new boolean or `numpy.ndarray` is returned.

    See Also
    --------
    numpy.ma.MaskedArray.all : Test whether all array elements along a given
                               axis evaluate to True.
    numpy.ma.MaskedArray.any : Test whether any array element along a given
                               axis evaluates to True.

    Examples
    --------
    >>> x = np.ma.array([[1, 0], [0, 0]], mask=[[0, 1], [1, 1]])
    >>> np.ma.any(x)
    True
    >>> np.ma.any(x, axis=0)
    array([ True, False], dtype=bool)
    >>> np.ma.any(x, axis=1)
    array([ True, False], dtype=bool)

    """
    a = np.ma.asarray(a)
    if axis is None:
        axis = 0
    return np.ma.MaskedArray.any(a, axis=axis)
Generated code for numpy.ma.MaskedArray.count


import numpy as np

def count(arr):
    """
    Count the number of non-masked elements in a numpy.ma.MaskedArray.

    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to count elements in.

    Returns
    -------
    int
        The number of non-masked elements in the array.
    """
    return np.sum(~arr.mask)
Generated code for numpy.ma.MaskedArray.nonzero


import numpy as np

def nonzero(arr):
    """
    Return the indices of the elements that are non-zero.
    
    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        Input array.
    
    Returns
    -------
    tuple
        Indices of the elements that are non-zero.
    """
    # Get the indices of the non-masked elements
    non_masked_indices = np.where(~arr.mask)
    
    # Get the values of the non-masked elements
    non_masked_values = arr[non_masked_indices]
    
    # Get the indices of the non-zero elements
    non_zero_indices = np.where(non_masked_values != 0)
    
    # Return the indices of the non-zero elements
    return non_masked_indices[non_zero_indices]
Generated code for numpy.ma.shape


import numpy as np

arr = np.ma.array([[1,2,3], [4,5,6], [7,8,9]])

shape = np.ma.shape(arr)

print(shape)
Generated code for numpy.ma.size


import numpy as np

# Create a masked array
x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[[0,1,0], [1,0,1], [0,1,0]])

# Get the size of the masked array
np.ma.size(x)
Generated code for numpy.ma.MaskedArray.data


import numpy as np

# Create a masked array
x = np.ma.MaskedArray(data=[1,2,3,4,5], mask=[False, False, True, False, True])

# Access the data
data = x.data

# Print the data
print(data)

# Output:
# [1 2 -- 4 --]
Generated code for numpy.ma.MaskedArray.mask


import numpy as np

def mask(arr, mask):
    """
    Mask an array with a given mask.

    Parameters
    ----------
    arr : array_like
        The array to be masked.
    mask : array_like
        The mask to be applied.

    Returns
    -------
    masked_array : numpy.ma.MaskedArray
        The masked array.
    """
    return np.ma.MaskedArray(arr, mask=mask)
Generated code for numpy.ma.MaskedArray.recordmask


def recordmask(arr, axis=None):
    """
    Return a boolean array of the same shape as `arr` that is True
    wherever the mask of `arr` is True.

    Parameters
    ----------
    arr : array_like
        Input array.
    axis : int, optional
        Axis along which to perform the operation.  By default, the
        flattened input is used.

    Returns
    -------
    recordmask : ndarray
        Boolean array of the same shape as `arr` that is True wherever
        the mask of `arr` is True.

    Examples
    --------
    >>> x = np.ma.array([1, 2, 3], mask=[0, 1, 0])
    >>> np.ma.recordmask(x)
    array([False,  True, False])

    """
    m = np.ma.getmaskarray(arr)
    if axis is None:
        return m.ravel()
    else:
        return m.take(axis, axis=axis)
Generated code for numpy.ma.ravel


import numpy as np

def ravel(arr):
    # Create a new array to store the flattened array
    new_arr = np.empty(arr.size, dtype=arr.dtype)
    
    # Iterate through the array and flatten it
    for i in range(arr.shape[0]):
        for j in range(arr.shape[1]):
            new_arr[i*arr.shape[1] + j] = arr[i, j]
    
    return new_arr

# Test
arr = np.ma.array([[1, 2, 3], [4, 5, 6]])
print(ravel(arr)) # [1. 2. 3. 4. 5. 6.]
Generated code for numpy.ma.reshape


import numpy as np

# reshape a numpy array
arr = np.arange(12).reshape(3,4)

# use numpy.ma.reshape
reshaped_arr = np.ma.reshape(arr, (2,6))

# print the reshaped array
print(reshaped_arr)
Generated code for numpy.ma.resize


import numpy as np

def resize(a, new_shape):
    """
    Resize an array to a new shape using numpy.ma.resize.
    
    Parameters
    ----------
    a : array_like
        Input array.
    new_shape : tuple
        Tuple of integers giving the new shape.
    
    Returns
    -------
    resized_array : ndarray
        Resized array with the same dtype as the input array.
    
    Examples
    --------
    >>> a = np.array([[1, 2, 3], [4, 5, 6]])
    >>> np.ma.resize(a, (3, 2))
    array([[1, 2],
           [3, 4],
           [5, 6]])
    """
    return np.ma.resize(a, new_shape)
Generated code for numpy.ma.MaskedArray.flatten


import numpy as np

def flatten(arr):
    """
    Flatten a numpy.ma.MaskedArray into a 1D array.
    
    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to be flattened.
    
    Returns
    -------
    out : numpy.ndarray
        The flattened array.
    """
    # Get the shape of the array
    shape = arr.shape
    # Calculate the total number of elements
    n_elements = np.prod(shape)
    # Create an empty array of the same type as the input array
    out = np.empty(n_elements, dtype=arr.dtype)
    # Iterate over the elements of the array
    for i in range(n_elements):
        # Get the indices of the element
        indices = np.unravel_index(i, shape)
        # Get the value of the element
        value = arr[indices]
        # Set the value in the output array
        out[i] = value
    # Return the flattened array
    return out
Generated code for numpy.ma.MaskedArray.ravel


import numpy as np

def ravel(arr):
    """
    Flattens a MaskedArray into a 1-D array.
    
    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to be flattened.
    
    Returns
    -------
    numpy.ndarray
        A 1-D array containing the flattened elements of the MaskedArray.
    """
    # Create a new array to store the flattened elements
    flat_arr = np.empty(arr.size, dtype=arr.dtype)
    
    # Iterate over the array and store the non-masked elements in the new array
    idx = 0
    for element in np.nditer(arr):
        if not element.mask:
            flat_arr[idx] = element
            idx += 1
    
    # Return the flattened array
    return flat_arr
Generated code for numpy.ma.MaskedArray.reshape


import numpy as np

# Create a MaskedArray
arr = np.ma.MaskedArray(np.arange(12).reshape(3,4))

# Reshape the MaskedArray
arr_reshaped = np.ma.MaskedArray.reshape(arr, (2,6))

# Print the reshaped MaskedArray
print(arr_reshaped)
Generated code for numpy.ma.MaskedArray.resize


import numpy as np

def resize(arr, new_shape, order=3):
    """
    Resize a MaskedArray to a new shape.
    
    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to be resized.
    new_shape : tuple
        The new shape of the array.
    order : int, optional
        The order of the spline interpolation, default is 3.
    
    Returns
    -------
    numpy.ma.MaskedArray
        The resized array.
    """
    # Get the original shape
    old_shape = arr.shape
    # Calculate the ratio of the new and old shapes
    ratio = np.divide(new_shape, old_shape)
    # Resize the array using spline interpolation
    resized_arr = np.ma.masked_array(
        np.array(
            [np.interp(
                np.arange(0, old_shape[i], ratio[i]),
                np.arange(0, old_shape[i]),
                arr[:, i],
                period=old_shape[i],
                order=order
            ) for i in range(arr.shape[1])]
        ).T
    )
    # Return the resized array
    return resized_arr
Generated code for numpy.ma.swapaxes


import numpy as np

def swapaxes(a, axis1, axis2):
    """
    Swap two axes of an array.

    Parameters
    ----------
    a : array_like
        Input array.
    axis1 : int
        First axis.
    axis2 : int
        Second axis.

    Returns
    -------
    out : ndarray
        Array with `axis1` and `axis2` swapped.

    Examples
    --------
    >>> a = np.array([[1,2,3]])
    >>> np.ma.swapaxes(a,0,1)
    array([[1],
           [2],
           [3]])

    """
    a = np.asanyarray(a)
    if axis1 == axis2:
        return a
    if axis1 < 0:
        axis1 += a.ndim
    if axis2 < 0:
        axis2 += a.ndim
    if (axis1 >= a.ndim) or (axis2 >= a.ndim):
        raise ValueError("axis1 and axis2 should be within range (-a.ndim, a.ndim)")
    b = np.swapaxes(a, axis1, axis2)
    return np.ma.array(b, mask=np.ma.getmaskarray(a))
Generated code for numpy.ma.transpose


import numpy as np

def transpose(arr):
    return np.ma.transpose(arr)

# Example
arr = np.array([[1,2,3], [4,5,6], [7,8,9]])
print(transpose(arr))

# Output
# [[1 4 7]
#  [2 5 8]
#  [3 6 9]]
Generated code for numpy.ma.MaskedArray.swapaxes


import numpy as np

def swapaxes(arr, axis1, axis2):
    """
    Swap two axes of a MaskedArray.

    Parameters
    ----------
    arr : MaskedArray
        Input array.
    axis1 : int
        First axis.
    axis2 : int
        Second axis.

    Returns
    -------
    MaskedArray
        Array with two axes swapped.

    """
    arr = np.ma.asarray(arr)
    arr = np.swapaxes(arr, axis1, axis2)
    return np.ma.MaskedArray(arr, mask=arr.mask)
Generated code for numpy.ma.MaskedArray.transpose


import numpy as np

def transpose(arr):
    """
    Transpose a numpy.ma.MaskedArray.
    
    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to be transposed.
    
    Returns
    -------
    numpy.ma.MaskedArray
        The transposed array.
    """
    # Get the shape of the array
    shape = arr.shape
    # Create a new array with the transposed shape
    new_arr = np.ma.masked_array(np.empty(shape[::-1]), mask=arr.mask)
    # Iterate over the elements of the array
    for i in range(shape[0]):
        for j in range(shape[1]):
            # Set the transposed element
            new_arr[j, i] = arr[i, j]
    # Return the transposed array
    return new_arr
Generated code for numpy.ma.atleast_1d


import numpy as np

def atleast_1d(a):
    a = np.asarray(a)
    if a.ndim == 0:
        a = a[np.newaxis]
    return a

# Usage
x = np.ma.atleast_1d(3)
print(x)
# Output: array([3])
Generated code for numpy.ma.atleast_2d


import numpy as np

def atleast_2d(a):
    if np.ndim(a) == 0:
        result = a[np.newaxis, np.newaxis]
    elif np.ndim(a) == 1:
        result = a[:, np.newaxis]
    else:
        result = a
    return result

# Usage example
x = np.array([1, 2, 3])
y = np.ma.atleast_2d(x)
print(y)
# Output:
# [[1]
#  [2]
#  [3]]
Generated code for numpy.ma.atleast_3d


import numpy as np

def atleast_3d(arr):
    arr = np.asarray(arr)
    if arr.ndim < 3:
        return np.atleast_3d(arr)
    else:
        return arr
    
# Usage
arr = np.array([[1,2,3],[4,5,6]])
arr_3d = atleast_3d(arr)
print(arr_3d.shape) # (2, 3, 1)
Generated code for numpy.ma.expand_dims


import numpy as np

def expand_dims(a, axis):
    """
    Expand the shape of an array.
    Insert a new axis that will appear at the `axis` position in the expanded array shape.
    
    Parameters
    ----------
    a : array_like
        Input array.
    axis : int
        Position in the expanded axes where the new axis is placed.
    
    Returns
    -------
    res : ndarray
        Output array. The number of dimensions is one greater than that of
        the input array.
    """
    return np.ma.expand_dims(a, axis)
Generated code for numpy.ma.squeeze


import numpy as np

def squeeze(a):
    """
    Remove single-dimensional entries from the shape of an array.

    Parameters
    ----------
    a : array_like
        Input data.

    Returns
    -------
    squeezed : ndarray
        The input array, but with all or a subset of the
        dimensions of length 1 removed.

    Examples
    --------
    >>> x = np.array([[[0], [1], [2]]])
    >>> x.shape
    (1, 3, 1)
    >>> np.ma.squeeze(x).shape
    (3,)

    """
    a = np.asanyarray(a)
    if a.ndim == 0:
        return a
    squeezed = np.squeeze(a)
    if a.shape == squeezed.shape:
        return a
    return squeezed
Generated code for numpy.ma.MaskedArray.squeeze


import numpy as np

def squeeze(arr):
    """
    Squeeze a MaskedArray.

    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to be squeezed.

    Returns
    -------
    numpy.ma.MaskedArray
        The squeezed array.
    """
    # Get the shape of the array
    shape = arr.shape

    # Create a list of axes to squeeze
    axes = []
    for i in range(len(shape)):
        if shape[i] == 1:
            axes.append(i)

    # Squeeze the array
    return np.ma.masked_array(arr.data.squeeze(axis=tuple(axes)),
                              mask=arr.mask.squeeze(axis=tuple(axes)))
Generated code for numpy.ma.stack


import numpy as np

def stack(arrays, axis=0):
    """
    Stack the given arrays along the given axis.

    Parameters
    ----------
    arrays : sequence of ndarrays
        The arrays must have the same shape along all but the specified axis.
    axis : int, optional
        The axis along which the arrays will be stacked. Default is 0.

    Returns
    -------
    stacked : ndarray
        The stacked array has one more dimension than the input arrays.

    Examples
    --------
    >>> a = np.array([1, 2, 3])
    >>> b = np.array([2, 3, 4])
    >>> np.ma.stack([a, b], axis=0)
    array([[1, 2, 3],
           [2, 3, 4]])
    """
    stacked = np.ma.array(np.stack(arrays, axis=axis))
    return stacked
Generated code for numpy.ma.column_stack


import numpy as np

def column_stack(arrays):
    """
    Stack 1-D arrays as columns into a 2-D array.
    
    Parameters
    ----------
    arrays : sequence of 1-D arrays
        All arrays must have the same first dimension.
    
    Returns
    -------
    stacked : 2-D array
        The array contains columns that are constructed from the input
        arrays.
    """
    arrays = [np.asarray(arr) for arr in arrays]
    if not all(arr.ndim == 1 for arr in arrays):
        raise ValueError('all input arrays must be 1-D')
    dtype = np.find_common_type([arr.dtype for arr in arrays], [])
    stacked = np.empty((arrays[0].shape[0], len(arrays)), dtype=dtype)
    for i, arr in enumerate(arrays):
        stacked[:, i] = arr
    return stacked
Generated code for numpy.ma.concatenate


import numpy as np

def concatenate(arrays, axis=0):
    """
    Concatenate a sequence of arrays along an existing axis.

    Parameters
    ----------
    arrays : sequence of array_like
        The arrays must have the same shape, except in the dimension
        corresponding to `axis` (the first, by default).
    axis : int, optional
        The axis along which the arrays will be joined. Default is 0.

    Returns
    -------
    res : ndarray
        The concatenated array.
    """
    res = np.ma.concatenate(arrays, axis=axis)
    return res
Generated code for numpy.ma.dstack


import numpy as np

def dstack(arrays):
    """
    Stack arrays in sequence depth wise (along third axis).
    Parameters
    ----------
    arrays : sequence of array_like
        Each array must have the same shape.
    Returns
    -------
    stacked : ndarray
        The array formed by stacking the given arrays, will be at least 3-D.
    """
    arrays = [np.asanyarray(arr) for arr in arrays]
    if not arrays:
        raise ValueError('need at least one array to stack')

    shapes = set(arr.shape for arr in arrays)
    if len(shapes) != 1:
        raise ValueError('all input arrays must have the same shape')

    result_ndim = max(arr.ndim for arr in arrays)
    result_shape = arrays[0].shape

    if result_ndim == 0:
        # special case for 0-d arrays
        return np.array(arrays, dtype=arrays[0].dtype)

    # we need to pad the shape of the arrays with ones
    # so that the result is at least 2-d
    if result_ndim == 1:
        result_shape = (1,) + result_shape

    # create an array of python lists of length equal to the number of arrays
    result_list = [[] for _ in arrays]

    # fill the lists with the arrays
    for arr in arrays:
        # we need to pad the shape of the array with ones
        # so that the result is at least 2-d
        arr_shape = arr.shape
        if arr.ndim == 1:
            arr_shape = (1,) + arr_shape

        # fill the list with the flattened array
        result_list[0].extend(arr.flatten())

    # stack the lists into an array
    stacked = np.ma.dstack(result_list)

    # reshape the array to the desired shape
    return stacked.reshape(result_shape)
Generated code for numpy.ma.hstack


import numpy as np

def hstack(arrays):
    """
    Stack arrays in sequence horizontally (column wise).
    Parameters
    ----------
    arrays : sequence of ndarrays
        Input arrays.
    Returns
    -------
    stacked : ndarray
        The array formed by stacking the given arrays.
    """
    arrays = [np.asanyarray(arr) for arr in arrays]
    shapes = [arr.shape for arr in arrays]
    result_ndim = np.max([arr.ndim for arr in arrays])
    result_shape = np.zeros(result_ndim, int)
    for shape in shapes:
        result_shape[:len(shape)] += shape
    result = np.empty(result_shape, dtype=np.ma.result_type(*arrays))
    slices = [slice(None)] * result_ndim
    for arr in arrays:
        slices[-arr.ndim:] = arr.shape
        result[tuple(slices)] = arr
        slices[-arr.ndim:] = 0
    return result
Generated code for numpy.ma.hsplit


import numpy as np

# Create a 2D array
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# Split the array into 3 parts horizontally
split_arr = np.ma.hsplit(arr, 3)

# Print the split array
print(split_arr)

# Output
[array([[1],
        [4],
        [7]]), array([[2],
        [5],
        [8]]), array([[3],
        [6],
        [9]])]
Generated code for numpy.ma.mr_


import numpy as np

def mr_ (arr, axis=None):
    """
    Computes the mean of the absolute values of the elements of the array along the given axis.
    
    Parameters
    ----------
    arr : array_like
        Input array.
    axis : int, optional
        Axis along which the mean is computed. The default is to compute the mean of the flattened array.
    
    Returns
    -------
    mr : ndarray
        Mean of the absolute values of the array elements.
    """
    return np.mean(np.abs(arr), axis=axis)
Generated code for numpy.ma.row_stack


import numpy as np

def row_stack(arrays):
    """
    Stack 1-D arrays as rows into a 2-D array.

    Parameters
    ----------
    arrays : sequence of 1-D arrays
        Each array must have the same shape.

    Returns
    -------
    stacked : 2-D array
        The array formed by stacking the given arrays.

    Examples
    --------
    >>> a = np.array([1, 2, 3])
    >>> b = np.array([2, 3, 4])
    >>> np.ma.row_stack((a, b))
    array([[1, 2, 3],
           [2, 3, 4]])
    """
    return np.ma.array(np.row_stack(arrays))
Generated code for numpy.ma.vstack


import numpy as np

def vstack(arrays):
    """
    Stack arrays in sequence vertically (row wise).
    This is equivalent to `np.concatenate(arrays, axis=0)`.
    
    Parameters
    ----------
    arrays : sequence of ndarrays
        The arrays must have the same shape along all but the first axis.
        1-D arrays must have the same length.
    
    Returns
    -------
    stacked : ndarray
        The array formed by stacking the given arrays.
    """
    arrays = [np.asanyarray(arr) for arr in arrays]
    shapes = [arr.shape for arr in arrays]
    result_ndim = arrays[0].ndim
    if not all(shape == shapes[0] for shape in shapes):
        raise ValueError('all input arrays must have the same shape')
    if result_ndim == 0:
        # special case for 0-dim arrays
        if not all(arr.ndim == 0 for arr in arrays):
            raise ValueError('all input scalar arrays must have the same shape')
        result_shape = (len(arrays),)
    else:
        result_shape = (len(arrays),) + shapes[0][1:]
    result = np.empty(result_shape, dtype=arrays[0].dtype)
    for i, arr in enumerate(arrays):
        result[i] = arr
    return result
Generated code for numpy.ma.concatenate


import numpy as np

def concatenate(arrays, axis=0):
    """
    Concatenate a sequence of arrays along an existing axis.

    Parameters
    ----------
    arrays : sequence of array_like
        The arrays must have the same shape, except in the dimension
        corresponding to `axis` (the first, by default).
    axis : int, optional
        The axis along which the arrays will be joined. Default is 0.

    Returns
    -------
    res : ndarray
        The concatenated array.
    """
    res = np.ma.concatenate(arrays, axis=axis)
    return res
Generated code for numpy.ma.stack


import numpy as np

def stack(arrays, axis=0):
    """
    Stack the given arrays along the given axis.

    Parameters
    ----------
    arrays : sequence of ndarrays
        The arrays must have the same shape along all but the specified axis.
    axis : int, optional
        The axis along which the arrays will be stacked. Default is 0.

    Returns
    -------
    stacked : ndarray
        The stacked array has one more dimension than the input arrays.

    Examples
    --------
    >>> a = np.array([1, 2, 3])
    >>> b = np.array([2, 3, 4])
    >>> np.ma.stack([a, b], axis=0)
    array([[1, 2, 3],
           [2, 3, 4]])
    """
    stacked = np.ma.array(np.stack(arrays, axis=axis))
    return stacked
Generated code for numpy.ma.vstack


import numpy as np

def vstack(arrays):
    """
    Stack arrays in sequence vertically (row wise).
    This is equivalent to `np.concatenate(arrays, axis=0)`.
    
    Parameters
    ----------
    arrays : sequence of ndarrays
        The arrays must have the same shape along all but the first axis.
        1-D arrays must have the same length.
    
    Returns
    -------
    stacked : ndarray
        The array formed by stacking the given arrays.
    """
    arrays = [np.asanyarray(arr) for arr in arrays]
    shapes = [arr.shape for arr in arrays]
    result_ndim = arrays[0].ndim
    if not all(shape == shapes[0] for shape in shapes):
        raise ValueError('all input arrays must have the same shape')
    if result_ndim == 0:
        # special case for 0-dim arrays
        if not all(arr.ndim == 0 for arr in arrays):
            raise ValueError('all input scalar arrays must have the same shape')
        result_shape = (len(arrays),)
    else:
        result_shape = (len(arrays),) + shapes[0][1:]
    result = np.empty(result_shape, dtype=arrays[0].dtype)
    for i, arr in enumerate(arrays):
        result[i] = arr
    return result
Generated code for numpy.ma.hstack


import numpy as np

def hstack(arrays):
    """
    Stack arrays in sequence horizontally (column wise).
    Parameters
    ----------
    arrays : sequence of ndarrays
        Input arrays.
    Returns
    -------
    stacked : ndarray
        The array formed by stacking the given arrays.
    """
    arrays = [np.asanyarray(arr) for arr in arrays]
    shapes = [arr.shape for arr in arrays]
    result_ndim = np.max([arr.ndim for arr in arrays])
    result_shape = np.zeros(result_ndim, int)
    for shape in shapes:
        result_shape[:len(shape)] += shape
    result = np.empty(result_shape, dtype=np.ma.result_type(*arrays))
    slices = [slice(None)] * result_ndim
    for arr in arrays:
        slices[-arr.ndim:] = arr.shape
        result[tuple(slices)] = arr
        slices[-arr.ndim:] = 0
    return result
Generated code for numpy.ma.dstack


import numpy as np

def dstack(arrays):
    """
    Stack arrays in sequence depth wise (along third axis).
    Parameters
    ----------
    arrays : sequence of array_like
        Each array must have the same shape.
    Returns
    -------
    stacked : ndarray
        The array formed by stacking the given arrays, will be at least 3-D.
    """
    arrays = [np.asanyarray(arr) for arr in arrays]
    if not arrays:
        raise ValueError('need at least one array to stack')

    shapes = set(arr.shape for arr in arrays)
    if len(shapes) != 1:
        raise ValueError('all input arrays must have the same shape')

    result_ndim = max(arr.ndim for arr in arrays)
    result_shape = arrays[0].shape

    if result_ndim == 0:
        # special case for 0-d arrays
        return np.array(arrays, dtype=arrays[0].dtype)

    # we need to pad the shape of the arrays with ones
    # so that the result is at least 2-d
    if result_ndim == 1:
        result_shape = (1,) + result_shape

    # create an array of python lists of length equal to the number of arrays
    result_list = [[] for _ in arrays]

    # fill the lists with the arrays
    for arr in arrays:
        # we need to pad the shape of the array with ones
        # so that the result is at least 2-d
        arr_shape = arr.shape
        if arr.ndim == 1:
            arr_shape = (1,) + arr_shape

        # fill the list with the flattened array
        result_list[0].extend(arr.flatten())

    # stack the lists into an array
    stacked = np.ma.dstack(result_list)

    # reshape the array to the desired shape
    return stacked.reshape(result_shape)
Generated code for numpy.ma.column_stack


import numpy as np

def column_stack(arrays):
    """
    Stack 1-D arrays as columns into a 2-D array.
    
    Parameters
    ----------
    arrays : sequence of 1-D arrays
        All arrays must have the same first dimension.
    
    Returns
    -------
    stacked : 2-D array
        The array contains columns that are constructed from the input
        arrays.
    """
    arrays = [np.asarray(arr) for arr in arrays]
    if not all(arr.ndim == 1 for arr in arrays):
        raise ValueError('all input arrays must be 1-D')
    dtype = np.find_common_type([arr.dtype for arr in arrays], [])
    stacked = np.empty((arrays[0].shape[0], len(arrays)), dtype=dtype)
    for i, arr in enumerate(arrays):
        stacked[:, i] = arr
    return stacked
Generated code for numpy.ma.append


import numpy as np

def append(arr1, arr2, axis=None):
    """
    Append two numpy.ma arrays along the given axis.

    Parameters
    ----------
    arr1 : numpy.ma array
        The first array to append.
    arr2 : numpy.ma array
        The second array to append.
    axis : int, optional
        The axis along which to append the arrays. If not provided, the arrays
        will be flattened and appended along the first axis.

    Returns
    -------
    numpy.ma array
        The appended array.
    """
    if axis is None:
        # Flatten the arrays and append along the first axis
        arr1 = arr1.flatten()
        arr2 = arr2.flatten()
        return np.ma.append(arr1, arr2, axis=0)
    else:
        # Append along the given axis
        return np.ma.append(arr1, arr2, axis=axis)
Generated code for numpy.ma.make_mask


import numpy as np

def make_mask(data, fill_value=None):
    """
    Create a mask for the given data array.

    Parameters
    ----------
    data : array_like
        The data array.
    fill_value : scalar, optional
        The value to be masked. If None, all non-zero values are masked.

    Returns
    -------
    mask : ndarray
        A boolean mask of the same shape as `data`, with entries
        True where `data` is equal to `fill_value`.

    Examples
    --------
    >>> data = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> np.ma.make_mask(data)
    array([[False, False, False],
           [False, False, False],
           [False, False, False]], dtype=bool)
    >>> np.ma.make_mask(data, 5)
    array([[False, False, False],
           [False,  True, False],
           [False, False, False]], dtype=bool)
    """
    if fill_value is None:
        mask = np.zeros_like(data, dtype=bool)
    else:
        mask = np.equal(data, fill_value)
    return mask
Generated code for numpy.ma.make_mask_none


import numpy as np

def make_mask_none(arr):
    """
    Create a mask of all False values for a given array.
    
    Parameters
    ----------
    arr : array_like
        Input array.
    
    Returns
    -------
    mask : numpy.ma.MaskedArray
        Masked array with all False values.
    """
    return np.ma.MaskedArray(arr, mask=np.zeros_like(arr, dtype=bool))
Generated code for numpy.ma.mask_or


import numpy as np

def mask_or(a, b, copy=True):
    """
    Perform a logical_or operation on two masked arrays.

    Parameters
    ----------
    a, b : array_like
        Input arrays.
    copy : bool, optional
        Whether to return a copy of `a` or to perform in-place
        operations. Default is True.

    Returns
    -------
    result : MaskedArray
        Logical_or of `a` and `b`.

    Examples
    --------
    >>> a = np.ma.array([1, 2, 3], mask=[0, 1, 0])
    >>> b = np.ma.array([4, 5, 6], mask=[1, 0, 0])
    >>> np.ma.mask_or(a, b)
    masked_array(data=[--, 5, 6],
                 mask=[ True, False, False],
           fill_value=999999)

    """
    a = np.ma.array(a, copy=copy)
    b = np.ma.array(b, copy=copy)
    a.mask = np.logical_or(a.mask, b.mask)
    a[~a.mask] = np.logical_or(a[~a.mask], b[~a.mask])
    return a
Generated code for numpy.ma.make_mask_descr


import numpy as np

def make_mask_descr(mask):
    """
    Create a mask description from a boolean mask array.

    Parameters
    ----------
    mask : array_like
        Boolean mask array.

    Returns
    -------
    descr : dict
        Dictionary containing the mask description.
    """
    # Check if mask is a boolean array
    if not np.issubdtype(mask.dtype, np.bool_):
        raise TypeError('mask must be a boolean array')

    # Get the shape of the mask
    shape = mask.shape

    # Initialize the description
    descr = {'shape': shape, 'fortran_order': False, 'descr': []}

    # Iterate over the mask and create the description
    for i in range(shape[0]):
        for j in range(shape[1]):
            if mask[i, j]:
                descr['descr'].append((i, j))

    return descr
Generated code for numpy.ma.getmask
array

import numpy as np

def getmaskarray(mask):
    """
    Return a boolean array from a mask.

    Parameters
    ----------
    mask : array_like
        Mask array.

    Returns
    -------
    result : ndarray
        Boolean array with the same shape as `mask`.

    Examples
    --------
    >>> x = np.ma.array([1, 2, 3], mask=[0, 1, 0])
    >>> np.ma.getmaskarray(x)
    array([False,  True, False])

    """
    return np.array(mask, dtype=bool)
Generated code for numpy.ma.getmaskarray


import numpy as np

def getmaskarray(mask):
    """
    Return a boolean array from a mask.

    Parameters
    ----------
    mask : array_like
        Mask array.

    Returns
    -------
    result : ndarray
        Boolean array with the same shape as `mask`.

    Examples
    --------
    >>> a = np.ma.array([1, 2, 3], mask=[0, 1, 0])
    >>> np.ma.getmaskarray(a)
    array([False,  True, False])
    """
    return np.array(mask, dtype=bool)
Generated code for numpy.ma.masked_array.mask


import numpy as np

# Create a masked array
x = np.ma.masked_array([1, 2, 3, 4, 5], mask=[0, 0, 1, 0, 0])

# Mask the array
x.mask = [1, 1, 0, 1, 1]

# Print the masked array
print(x)
Generated code for numpy.ma.ndenumerate


import numpy as np

# Create a 2D array
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# Use ndenumerate to iterate over the array
for index, value in np.ma.ndenumerate(arr):
    print(index, value)
Generated code for numpy.ma.flatnotmasked_contiguous


import numpy as np

def flatnotmasked_contiguous(a):
    """
    Find contiguous unmasked data in a masked array along the given axis.
    Returns a 1-D array of indices, with each subarray containing
    the indices along the given axis of the contiguous unmasked data.
    """
    a = np.ma.asarray(a)
    m = np.ma.getmaskarray(a)
    if m is np.ma.nomask:
        return np.arange(a.shape[0])
    else:
        # Find the indices of the unmasked data
        idx = np.where(~m)[0]
        # Find the start and end indices of each contiguous block
        sidx = np.concatenate([[0], np.where(np.diff(idx) > 1)[0] + 1, [len(idx)]])
        return [idx[s:e] for s, e in zip(sidx[:-1], sidx[1:])]
Generated code for numpy.ma.flatnotmasked_edges


import numpy as np

def flatnotmasked_edges(a):
    """
    Find the indices of the first and last non-masked elements
    along the given axis of a masked array.

    Parameters
    ----------
    a : array_like
        Input array.

    Returns
    -------
    edges : tuple of ints
        Indices of the first and last non-masked elements along
        the given axis.
    """
    a = np.ma.asarray(a)
    m = np.ma.getmaskarray(a)
    if m is np.ma.nomask:
        return (0, a.shape[0] - 1)
    else:
        i = np.ma.flatnotmasked_edges(m)
        return (i[0], i[-1])
Generated code for numpy.ma.notmasked_contiguous


import numpy as np

def notmasked_contiguous(mask):
    """
    Find contiguous unmasked regions of a masked array.

    Parameters
    ----------
    mask : array_like
        Mask array.

    Returns
    -------
    regions : list of slices
        List of slices corresponding to contiguous unmasked regions.
    """
    # Convert mask to a numpy array
    mask = np.asarray(mask)
    # Check if mask is a boolean array
    if not np.issubdtype(mask.dtype, np.bool_):
        raise TypeError('mask must be a boolean array')
    # Initialize list of regions
    regions = []
    # Find indices of unmasked elements
    unmasked_indices = np.where(~mask)[0]
    # Loop over unmasked indices
    for i in range(len(unmasked_indices)):
        # Get start and end indices of current region
        start = unmasked_indices[i]
        if i == len(unmasked_indices) - 1:
            end = len(mask)
        else:
            end = unmasked_indices[i + 1]
        # Append slice to list of regions
        regions.append(slice(start, end))
    # Return list of regions
    return regions
Generated code for numpy.ma.notmasked_edges


import numpy as np

def notmasked_edges(mask):
    """
    Find the edges of a masked array.

    Parameters
    ----------
    mask : numpy.ma.MaskedArray
        The masked array to find the edges of.

    Returns
    -------
    edges : tuple
        A tuple of the form (row_edges, col_edges) containing the
        row and column edges of the masked array.
    """
    # Get the shape of the mask
    shape = mask.shape

    # Initialize the row and column edges
    row_edges = []
    col_edges = []

    # Iterate over the rows and columns
    for i in range(shape[0]):
        for j in range(shape[1]):
            # If the current element is not masked
            if not mask[i, j]:
                # Check if the element is on the edge
                if (i == 0 or not mask[i - 1, j]) and (i == shape[0] - 1 or not mask[i + 1, j]):
                    row_edges.append(i)
                if (j == 0 or not mask[i, j - 1]) and (j == shape[1] - 1 or not mask[i, j + 1]):
                    col_edges.append(j)

    # Return the edges
    return (row_edges, col_edges)
Generated code for numpy.ma.clump_masked


import numpy as np

def clump_masked(data, axis=None):
    """
    Clump together adjacent masked elements of an array.

    Parameters
    ----------
    data : array_like
        Input array.
    axis : int, optional
        Axis along which to operate.  By default, the flattened input
        is used.

    Returns
    -------
    clumped : ndarray
        Output array of same shape as `data`, with clumped elements
        indicated by True values.

    Examples
    --------
    >>> x = np.ma.array([1, 2, 3, 4, 5, 6], mask=[0, 0, 0, 1, 1, 0])
    >>> np.ma.clump_masked(x)
    array([False, False, False,  True,  True, False])

    """
    data = np.ma.asarray(data)
    if axis is None:
        data = np.ma.ravel(data)
        axis = 0
    else:
        data = np.ma.swapaxes(data, axis, 0)
    clumped = np.ma.zeros(data.shape, dtype=bool)
    start = 0
    for i in range(1, len(data)):
        if data.mask[i] != data.mask[i-1]:
            clumped[start:i] = True
            start = i
    clumped[start:] = True
    if axis > 0:
        clumped = np.ma.swapaxes(clumped, axis, 0)
    return clumped
Generated code for numpy.ma.clump_unmasked


import numpy as np

def clump_unmasked(a, mask):
    """
    Clump unmasked elements of an array.

    Parameters
    ----------
    a : array_like
        Input array.
    mask : array_like
        Mask array.

    Returns
    -------
    clumps : ndarray
        An array of the same shape as `a` containing the clump
        numbers of the unmasked elements.
    """
    # Make sure the mask is a boolean array
    mask = np.array(mask, dtype=bool)

    # Find the unmasked elements
    unmasked = np.where(~mask)

    # Initialize the clump array
    clumps = np.zeros_like(a)

    # Initialize the clump counter
    clump_num = 1

    # Iterate over the unmasked elements
    for i, j in zip(*unmasked):
        # If the element is already part of a clump, skip it
        if clumps[i, j] != 0:
            continue

        # Otherwise, start a new clump
        clumps[i, j] = clump_num

        # Find the neighbors of the current element
        neighbors = np.array([[i-1, j], [i+1, j], [i, j-1], [i, j+1]])

        # Iterate over the neighbors
        for ni, nj in neighbors:
            # If the neighbor is unmasked and not part of a clump,
            # add it to the current clump
            if (ni >= 0 and ni < a.shape[0] and
                    nj >= 0 and nj < a.shape[1] and
                    ~mask[ni, nj] and clumps[ni, nj] == 0):
                clumps[ni, nj] = clump_num

        # Increment the clump counter
        clump_num += 1

    return clumps
Generated code for numpy.ma.mask_cols


import numpy as np

def mask_cols(arr, mask):
    """
    Mask columns of a 2D array using a boolean mask.

    Parameters
    ----------
    arr : array_like
        Input array.
    mask : array_like
        Boolean mask, with the same number of elements as the number of columns
        in `arr`.

    Returns
    -------
    result : numpy.ma.MaskedArray
        Masked array with masked columns.

    Examples
    --------
    >>> arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> mask = np.array([True, False, True])
    >>> np.ma.mask_cols(arr, mask)
    masked_array(
      data=[[--, 2, --],
            [--, 5, --],
            [--, 8, --]],
      mask=[[ True, False,  True],
            [ True, False,  True],
            [ True, False,  True]],
      fill_value=999999)
    """
    arr = np.asarray(arr)
    mask = np.asarray(mask)
    if arr.ndim != 2:
        raise ValueError('Input array must be 2D.')
    if mask.ndim != 1:
        raise ValueError('Mask array must be 1D.')
    if arr.shape[1] != mask.shape[0]:
        raise ValueError('Mask array must have the same number of elements as the number of columns in the input array.')
    return np.ma.masked_array(arr, mask=np.tile(mask, (arr.shape[0], 1)))
Generated code for numpy.ma.mask_or


import numpy as np

def mask_or(a, b, copy=True):
    """
    Perform a logical_or operation on two masked arrays.

    Parameters
    ----------
    a, b : array_like
        Input arrays.
    copy : bool, optional
        Whether to return a copy of `a` or to perform in-place
        operations. Default is True.

    Returns
    -------
    result : MaskedArray
        Logical_or of `a` and `b`.

    Examples
    --------
    >>> a = np.ma.array([1, 2, 3], mask=[0, 1, 0])
    >>> b = np.ma.array([4, 5, 6], mask=[1, 0, 0])
    >>> np.ma.mask_or(a, b)
    masked_array(data=[--, 5, 6],
                 mask=[ True, False, False],
           fill_value=999999)

    """
    a = np.ma.array(a, copy=copy)
    b = np.ma.array(b, copy=copy)
    a.mask = np.logical_or(a.mask, b.mask)
    a[~a.mask] = np.logical_or(a[~a.mask], b[~a.mask])
    return a
Generated code for numpy.ma.mask_rowcols


import numpy as np

def mask_rowcols(arr, row_mask, col_mask):
    """
    Mask rows and columns of a 2D array.

    Parameters
    ----------
    arr : array_like
        Input array.
    row_mask : array_like
        Boolean array with shape (M,) where M is the number of rows of `arr`.
    col_mask : array_like
        Boolean array with shape (N,) where N is the number of columns of `arr`.

    Returns
    -------
    masked_arr : numpy.ma.MaskedArray
        Masked array with the same shape as `arr`.
    """
    # Convert input arrays to numpy arrays
    arr = np.asarray(arr)
    row_mask = np.asarray(row_mask)
    col_mask = np.asarray(col_mask)

    # Check shapes
    if row_mask.shape[0] != arr.shape[0]:
        raise ValueError('row_mask has incorrect shape')
    if col_mask.shape[0] != arr.shape[1]:
        raise ValueError('col_mask has incorrect shape')

    # Create mask
    mask = np.zeros_like(arr, dtype=bool)
    mask[row_mask, :] = True
    mask[:, col_mask] = True

    # Create masked array
    masked_arr = np.ma.masked_array(arr, mask=mask)

    return masked_arr
Generated code for numpy.ma.mask_rows


import numpy as np

def mask_rows(arr, row_mask):
    """
    Mask rows of a 2D array using a boolean mask.

    Parameters
    ----------
    arr : array_like
        Input array of shape (M, N).
    row_mask : array_like
        Boolean mask of shape (M,).

    Returns
    -------
    masked_arr : numpy.ma.MaskedArray
        Masked array of shape (M, N).
    """
    # Convert input array to a masked array
    masked_arr = np.ma.masked_array(arr)

    # Mask the rows
    masked_arr.mask[row_mask] = True

    return masked_arr
Generated code for numpy.ma.harden_mask


import numpy as np

def harden_mask(mask):
    """
    Harden a mask by setting all elements of the mask to True
    where any element of the mask is True.

    Parameters
    ----------
    mask : array_like
        A boolean array.

    Returns
    -------
    hardened_mask : ndarray
        A boolean array with all elements set to True where any
        element of the input mask is True.

    Examples
    --------
    >>> a = np.ma.array([1, 2, 3], mask=[0, 1, 0])
    >>> np.ma.harden_mask(a.mask)
    array([False,  True, False], dtype=bool)
    """
    hardened_mask = np.zeros_like(mask, dtype=bool)
    hardened_mask[mask] = True
    return hardened_mask
Generated code for numpy.ma.soften_mask


import numpy as np

def soften_mask(mask, radius):
    """
    Soften a boolean mask by replacing each True value with a
    circular region of radius `radius`.

    Parameters
    ----------
    mask : array_like
        A boolean mask.
    radius : int
        The radius of the circular region.

    Returns
    -------
    softened_mask : ndarray
        The softened mask.
    """
    # Create a meshgrid of coordinates
    x, y = np.meshgrid(np.arange(mask.shape[1]), np.arange(mask.shape[0]))

    # Create a circular region
    circle = (x - mask.shape[1]//2)**2 + (y - mask.shape[0]//2)**2 < radius**2

    # Combine the mask and the circle
    softened_mask = np.logical_or(mask, circle)

    return softened_mask
Generated code for numpy.ma.MaskedArray.harden_mask


def harden_mask(masked_array):
    """
    Harden the mask of a MaskedArray.
    
    Parameters
    ----------
    masked_array : numpy.ma.MaskedArray
        The MaskedArray whose mask should be hardened.
    
    Returns
    -------
    numpy.ma.MaskedArray
        The MaskedArray with a hardened mask.
    """
    # Get the mask of the MaskedArray
    mask = masked_array.mask
    
    # Harden the mask by setting all masked values to True
    mask[mask] = True
    
    # Return the MaskedArray with the hardened mask
    return numpy.ma.MaskedArray(masked_array.data, mask=mask)
Generated code for numpy.ma.MaskedArray.soften_mask


def soften_mask(masked_array):
    """
    Soften the mask of a numpy.ma.MaskedArray.
    This function will replace any masked values that are surrounded by
    unmasked values with the average of the surrounding unmasked values.
    Parameters
    ----------
    masked_array : numpy.ma.MaskedArray
        The array to soften the mask of.
    Returns
    -------
    numpy.ma.MaskedArray
        The softened array.
    """
    # Get the mask and data from the array
    mask = masked_array.mask
    data = masked_array.data

    # Create a new array to store the softened mask
    softened_mask = np.zeros_like(mask)

    # Iterate over the mask
    for i in range(mask.shape[0]):
        for j in range(mask.shape[1]):
            # If the current value is masked
            if mask[i, j]:
                # Get the surrounding values
                surrounding_values = []
                for x in range(i-1, i+2):
                    for y in range(j-1, j+2):
                        # Make sure the indices are valid
                        if 0 <= x < mask.shape[0] and 0 <= y < mask.shape[1]:
                            # Make sure the value is not masked
                            if not mask[x, y]:
                                surrounding_values.append(data[x, y])
                # If there are surrounding values, replace the masked value
                # with the average of the surrounding values
                if len(surrounding_values) > 0:
                    softened_mask[i, j] = np.mean(surrounding_values)

    # Create a new array with the softened mask
    softened_array = np.ma.MaskedArray(data, softened_mask)

    return softened_array
Generated code for numpy.ma.MaskedArray.shrink_mask


def shrink_mask(masked_array):
    """
    Shrinks the mask of a numpy.ma.MaskedArray.

    Parameters
    ----------
    masked_array : numpy.ma.MaskedArray
        The array whose mask should be shrunk.

    Returns
    -------
    numpy.ma.MaskedArray
        The array with the shrunken mask.
    """
    # Get the mask of the array
    mask = masked_array.mask

    # Create a new mask with the same shape as the original
    new_mask = np.zeros_like(mask)

    # Iterate over the array and shrink the mask
    for i in range(mask.shape[0]):
        for j in range(mask.shape[1]):
            # If the current element is masked, check the surrounding elements
            if mask[i, j]:
                # Check the elements above and below
                if i > 0 and mask[i - 1, j]:
                    new_mask[i, j] = True
                if i < mask.shape[0] - 1 and mask[i + 1, j]:
                    new_mask[i, j] = True

                # Check the elements to the left and right
                if j > 0 and mask[i, j - 1]:
                    new_mask[i, j] = True
                if j < mask.shape[1] - 1 and mask[i, j + 1]:
                    new_mask[i, j] = True

    # Set the new mask on the array
    masked_array.mask = new_mask

    return masked_array
Generated code for numpy.ma.MaskedArray.unshare_mask


def unshare_mask(masked_array):
    """
    Unshare the mask of a MaskedArray.
    
    Parameters
    ----------
    masked_array : numpy.ma.MaskedArray
        The MaskedArray whose mask should be unshared.
    
    Returns
    -------
    numpy.ma.MaskedArray
        A new MaskedArray with an unshared mask.
    """
    # Create a new MaskedArray with the same data as the original
    new_masked_array = np.ma.MaskedArray(masked_array.data)
    
    # Copy the mask from the original MaskedArray
    new_masked_array.mask = np.copy(masked_array.mask)
    
    return new_masked_array
Generated code for numpy.ma.asarray


import numpy as np

def numpy_ma_asarray(input_array):
    """
    Convert an input array to a masked array.

    Parameters
    ----------
    input_array : array_like
        Input array to be converted.

    Returns
    -------
    output_array : numpy.ma.MaskedArray
        Masked array version of the input array.
    """
    output_array = np.ma.asarray(input_array)
    return output_array
Generated code for numpy.ma.asanyarray


import numpy as np

def asanyarray(a, dtype=None, order=None):
    """
    Convert the input to a masked array of the given data type.
    
    Parameters
    ----------
    a : array_like
        Input data, in any form that can be converted to an array.  This
        includes lists, lists of tuples, tuples, tuples of tuples, tuples
        of lists and ndarrays.
    dtype : data-type, optional
        By default, the data-type is inferred from the input data.
    order : {'C', 'F'}, optional
        Whether to use row-major (C-style) or column-major
        (Fortran-style) memory representation.  Defaults to 'C'.

    Returns
    -------
    out : ndarray
        The converted masked array.
    
    """
    a = np.asarray(a, dtype=dtype, order=order)
    return np.ma.masked_array(a, mask=np.isnan(a))
Generated code for numpy.ma.fix_invalid


import numpy as np

def fix_invalid(data):
    # Replace invalid values with the mean of the valid values
    valid_mask = np.ma.masked_invalid(data).mask
    data[valid_mask] = np.ma.masked_invalid(data).mean()
    return data
Generated code for numpy.ma.masked_equal


import numpy as np

# Create a sample array
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# Mask all elements equal to 5
masked_arr = np.ma.masked_equal(arr, 5)

# Print the masked array
print(masked_arr)

# Output:
# [[1 2 3]
#  [4 -- 6]
#  [7 8 9]]
Generated code for numpy.ma.masked_greater


import numpy as np

def masked_greater(a, value):
    return np.ma.masked_where(a > value, a)

# Usage
a = np.array([1, 2, 3, 4, 5])
masked_greater(a, 3)
# masked_array(data=[1, 2, --, --, --],
#              mask=[False, False,  True,  True,  True],
#        fill_value=999999)
Generated code for numpy.ma.masked_greater_equal


import numpy as np

# Create an array
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# Mask elements greater than or equal to 5
masked_arr = np.ma.masked_greater_equal(arr, 5)

# Print the masked array
print(masked_arr)
Generated code for numpy.ma.masked_inside


import numpy as np

def masked_inside(arr, vmin, vmax):
    """
    Mask elements of an array that are inside a given range.

    Parameters
    ----------
    arr : array_like
        Input array.
    vmin : scalar
        Lower bound of the range.
    vmax : scalar
        Upper bound of the range.

    Returns
    -------
    result : MaskedArray
        Output array, with elements inside the range masked.
    """
    result = np.ma.masked_array(arr, copy=True)
    result[(arr >= vmin) & (arr <= vmax)] = np.ma.masked
    return result
Generated code for numpy.ma.masked_invalid


import numpy as np

def masked_invalid(arr):
    return np.ma.masked_invalid(arr)

# Example
arr = np.array([1, 2, np.nan, 3, 4])
masked_arr = masked_invalid(arr)
print(masked_arr)
# Output:
# [1.0 2.0 -- 3.0 4.0]
Generated code for numpy.ma.masked_less


import numpy as np

def masked_less(x, value):
    return np.ma.masked_where(x < value, x)

# Usage
x = np.array([1, 2, 3, 4, 5])
masked_less(x, 3)
# masked_array(data=[--, --, 3, 4, 5],
#              mask=[ True,  True, False, False, False],
#        fill_value=999999)
Generated code for numpy.ma.masked_less_equal


import numpy as np

def masked_less_equal(x, value):
    """
    Return a masked array where all elements of x less than or equal to value are masked.

    Parameters
    ----------
    x : array_like
        Input array.
    value : scalar
        Threshold value.

    Returns
    -------
    out : MaskedArray
        Output array.
    """
    x = np.asarray(x)
    mask = x <= value
    return np.ma.masked_array(x, mask)
Generated code for numpy.ma.masked_not_equal


import numpy as np

# Create a sample array
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# Mask all elements not equal to 5
masked_arr = np.ma.masked_not_equal(arr, 5)

# Print the masked array
print(masked_arr)
Generated code for numpy.ma.masked_object


import numpy as np

def masked_object(data, mask):
    """
    Mask an object array with a boolean array.

    Parameters
    ----------
    data : array_like
        Input data.
    mask : array_like
        Boolean array used to mask the data. Must be the same shape as `data`.

    Returns
    -------
    masked_data : numpy.ma.MaskedArray
        Masked array containing the masked data.
    """
    # Convert data to a numpy array
    data = np.asarray(data)

    # Create a masked array from the data and mask
    masked_data = np.ma.masked_array(data, mask)

    return masked_data
Generated code for numpy.ma.masked_outside


import numpy as np

# Create a sample array
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# Mask values outside the range [2, 8]
masked_arr = np.ma.masked_outside(arr, 2, 8)

# Print the masked array
print(masked_arr)
Generated code for numpy.ma.masked_values


import numpy as np

# Create a masked array with masked values
masked_array = np.ma.masked_values([1, 2, 3, 4, 5, 6], 3)

# Print the masked array
print(masked_array)

# Output:
# [1 2 -- 4 5 6]
Generated code for numpy.ma.masked_where


import numpy as np

def masked_where(condition, a, copy=True):
    """
    Return a masked array, where the condition is True.

    Parameters
    ----------
    condition : array_like
        A boolean array with the same shape as `a`
    a : array_like
        The data to mask
    copy : bool, optional
        Whether to return a copy of `a` (True) or to return a view
        (False).  Defaults to True.

    Returns
    -------
    result : MaskedArray
        A masked array containing the data in `a`, masked where
        `condition` is True.

    Examples
    --------
    >>> x = np.arange(5)
    >>> np.ma.masked_where(x < 3, x)
    masked_array(data = [-- -- -- 3 4],
                 mask = [ True  True  True False False],
           fill_value = 999999)
    """
    result = np.ma.array(a, copy=copy)
    result[condition] = np.ma.masked
    return result
Generated code for numpy.ma.compress_cols


import numpy as np

def compress_cols(arr):
    """
    Compress columns of a 2D array using numpy.ma.compress_cols.

    Parameters
    ----------
    arr : array_like
        Input array of shape (m, n).

    Returns
    -------
    out : ndarray
        Output array of shape (m, k) where k <= n.
    """
    # Mask out columns with all zeros
    mask = np.all(arr == 0, axis=0)
    # Compress columns
    out = np.ma.compress_cols(arr, mask)
    return out
Generated code for numpy.ma.compress_rowcols


import numpy as np

def compress_rowcols(arr):
    # Get the shape of the array
    shape = arr.shape
    # Create a mask of the array
    mask = np.ma.make_mask(arr)
    # Create a new array with the same shape as the original
    new_arr = np.zeros(shape)
    # Iterate through the rows and columns of the array
    for i in range(shape[0]):
        for j in range(shape[1]):
            # If the mask is False, set the value in the new array to the value in the original array
            if not mask[i, j]:
                new_arr[i, j] = arr[i, j]
    # Return the new array
    return new_arr
Generated code for numpy.ma.compress_rows


import numpy as np

def compress_rows(arr):
    # Create a mask of valid rows
    mask = np.any(arr != 0, axis=1)
    # Compress the array using the mask
    return np.ma.compress_rows(arr, mask)

# Example
arr = np.array([[1, 0, 0],
                [0, 0, 0],
                [0, 2, 3]])

compress_rows(arr)
# array([[1, 0, 0],
#        [0, 2, 3]])
Generated code for numpy.ma.compressed


import numpy as np

def compressed(arr):
    return np.ma.compressed(arr)

# example
arr = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[[0,1,0], [1,0,1], [0,1,0]])

print(compressed(arr))
# Output: [1, 3, 4, 6, 7, 9]
Generated code for numpy.ma.filled


import numpy as np

def numpy_ma_filled(arr):
    """
    This function takes a numpy masked array and returns a new array with all
    masked values filled with a given value.
    
    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to be filled.
    
    Returns
    -------
    numpy.ndarray
        A new array with all masked values filled.
    """
    # Create a copy of the array
    filled_arr = arr.copy()
    
    # Get the indices of the masked values
    mask_indices = np.where(filled_arr.mask)
    
    # Fill the masked values with the given value
    filled_arr[mask_indices] = np.ma.filled(arr)
    
    return filled_arr
Generated code for numpy.ma.MaskedArray.compressed


import numpy as np

def compressed(arr):
    """
    Return a 1-D array of all the non-masked elements of the input array.
    
    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to be compressed.
    
    Returns
    -------
    numpy.ndarray
        A 1-D array of all the non-masked elements of the input array.
    """
    return np.ma.MaskedArray.compressed(arr)
Generated code for numpy.ma.MaskedArray.filled


import numpy as np

def filled(self):
    """
    Return a copy of the masked array, with the masked values filled with
    a given fill_value.
    
    Parameters
    ----------
    fill_value : scalar
        Value used to fill in the masked values.
        Default is 0.
    
    Returns
    -------
    filled_array : ndarray
        A copy of the original array, with the masked entries replaced
        by `fill_value`.
    
    Examples
    --------
    >>> x = np.ma.array(np.arange(5), mask=[0, 0, 1, 0, 0])
    >>> x.filled()
    array([0, 1, 9, 3, 4])
    >>> x.filled(99)
    array([ 0,  1, 99,  3,  4])
    """
    fill_value = 0
    filled_array = np.copy(self.data)
    filled_array[self.mask] = fill_value
    return filled_array
Generated code for numpy.ma.MaskedArray.tofile


import numpy as np

def tofile(self, fname, sep="", format="%s"):
    """
    Save a masked array to a file.
    
    Parameters
    ----------
    fname : str
        The file name.
    sep : str, optional
        The separator between array elements.
    format : str, optional
        The format of the array elements.
    
    Returns
    -------
    None
    
    """
    # Open the file
    f = open(fname, 'w')
    
    # Write the data
    for i in range(self.shape[0]):
        for j in range(self.shape[1]):
            if not self.mask[i, j]:
                f.write(format % self[i, j])
                f.write(sep)
        f.write('\n')
    
    # Close the file
    f.close()
Generated code for numpy.ma.MaskedArray.tolist


import numpy as np

def tolist(arr):
    if isinstance(arr, np.ma.MaskedArray):
        return arr.filled(np.nan).tolist()
    else:
        return arr.tolist()

# Usage
arr = np.ma.MaskedArray([1,2,3,4], mask=[True, False, False, True])
print(tolist(arr)) # [nan, 2.0, 3.0, nan]
Generated code for numpy.ma.MaskedArray.torecords


import numpy as np

def torecords(self):
    """
    Return a record array view of the masked array.
    
    Returns
    -------
    rec : numpy.recarray
        A record array view of the masked array.
    """
    # Create a record array from the masked array
    rec = np.rec.fromarrays(self.data, names=self.dtype.names)
    
    # Mask the record array
    for name in self.dtype.names:
        rec[name] = np.ma.masked_array(rec[name], self.mask[name])
    
    return rec
Generated code for numpy.ma.MaskedArray.tobytes


import numpy as np

def tobytes(arr):
    """
    Convert a numpy.ma.MaskedArray to a bytes object.

    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to convert.

    Returns
    -------
    bytes
        The bytes object representing the array.
    """
    # Get the data type of the array
    dtype = arr.dtype

    # Get the data as a numpy array
    data = np.asarray(arr)

    # Get the mask as a numpy array
    mask = np.asarray(arr.mask)

    # Create a bytes object from the data and mask
    return np.concatenate((data.astype(dtype).tobytes(), mask.astype(np.bool).tobytes())).tobytes()
Generated code for numpy.ma.common_fill_value


import numpy as np

def common_fill_value(arrays):
    """
    Find the common fill value for a list of numpy arrays.

    Parameters
    ----------
    arrays : list of numpy arrays
        List of numpy arrays to find the common fill value for.

    Returns
    -------
    fill_value : scalar
        The common fill value for the list of arrays.
    """
    # Get the fill values for each array
    fill_values = [np.ma.getfillvalue(arr) for arr in arrays]

    # Find the most common fill value
    fill_value, count = np.unique(fill_values, return_counts=True)
    fill_value = fill_value[np.argmax(count)]

    return fill_value
Generated code for numpy.ma.default_fill_value


import numpy as np

# Set the default fill value for masked array
np.ma.default_fill_value = -999
Generated code for numpy.ma.maximum_fill_value


import numpy as np

# Create a masked array
arr = np.ma.masked_array([1, 2, 3, 4, 5], mask=[False, False, True, False, True])

# Set the maximum fill value
np.ma.maximum_fill_value(arr, 10)

# Print the array
print(arr)

# Output:
# [1 2 10 4 10]
Generated code for numpy.ma.minimum_fill_value


import numpy as np

def minimum_fill_value(arr):
    """
    Returns the minimum fill value for a given array.
    Parameters
    ----------
    arr : array_like
        Input array.
    Returns
    -------
    min_fill_value : float
        The minimum fill value for the array.
    """
    min_fill_value = np.ma.minimum_fill_value(arr)
    return min_fill_value
Generated code for numpy.ma.set_fill_value


import numpy as np

# Create a masked array
arr = np.ma.masked_array([1, 2, 3, 4], mask=[False, True, False, True])

# Set the fill value
np.ma.set_fill_value(arr, 0)

# Print the array
print(arr)

# Output:
# [1 -- 3 --]
Generated code for numpy.ma.MaskedArray.get_fill_value


import numpy as np

def get_fill_value(arr):
    """
    Returns the fill value of a numpy.ma.MaskedArray.
    
    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to get the fill value from.
    
    Returns
    -------
    fill_value : float
        The fill value of the array.
    """
    return np.ma.MaskedArray.fill_value(arr)
Generated code for numpy.ma.MaskedArray.set_fill_value


import numpy as np

# Create a masked array
arr = np.ma.MaskedArray(data=[1, 2, 3, 4],
                        mask=[False, True, False, True])

# Set the fill value
arr.set_fill_value(0)

# Print the array
print(arr)

# Output:
# [1 -- 3 --]
Generated code for numpy.ma.MaskedArray.fill_value


import numpy as np

def fill_value(arr, fill_value):
    """
    Fill the masked elements of a numpy.ma.MaskedArray with the given fill_value.

    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to fill.
    fill_value : scalar
        The value to fill the masked elements with.

    Returns
    -------
    numpy.ma.MaskedArray
        The array with the masked elements filled.
    """
    # Create a copy of the array
    filled_arr = np.ma.copy(arr)
    # Get the indices of the masked elements
    masked_indices = np.ma.getmaskarray(arr)
    # Fill the masked elements with the given fill_value
    filled_arr[masked_indices] = fill_value
    # Return the filled array
    return filled_arr
Generated code for numpy.ma.anom


import numpy as np

def anom(x):
    """
    Calculate the anomaly of an array x.
    
    Parameters
    ----------
    x : array_like
        Input array.
    
    Returns
    -------
    anom : ndarray
        Anomaly of the input array.
    
    """
    mean = np.mean(x)
    anom = x - mean
    return anom
Generated code for numpy.ma.anomalies


import numpy as np

def anomalies(data):
    """
    Calculates the anomalies of a given array of data.
    
    Parameters
    ----------
    data : array_like
        The array of data to calculate the anomalies of.
    
    Returns
    -------
    anomalies : numpy.ma.MaskedArray
        The anomalies of the given data.
    """
    mean = np.mean(data)
    anomalies = np.ma.masked_array(data - mean, mask=np.isnan(data))
    return anomalies
Generated code for numpy.ma.average


import numpy as np

def numpy_ma_average(arr):
    # Create a masked array from the input array
    masked_arr = np.ma.masked_array(arr)
    
    # Calculate the average of the masked array
    avg = np.ma.average(masked_arr)
    
    # Return the average
    return avg
Generated code for numpy.ma.conjugate


import numpy as np

def conjugate(x):
    """
    Computes the complex conjugate of a numpy array.

    Parameters
    ----------
    x : numpy array
        Input array.

    Returns
    -------
    numpy array
        Complex conjugate of the input array.
    """
    return np.ma.conjugate(x)
Generated code for numpy.ma.corrcoef


import numpy as np

def corrcoef(x, y):
    x_mean = np.mean(x)
    y_mean = np.mean(y)
    x_std = np.std(x)
    y_std = np.std(y)
    xy_cov = np.sum((x - x_mean) * (y - y_mean)) / (len(x) - 1)
    return xy_cov / (x_std * y_std)

# Example
x = np.array([1, 2, 3, 4, 5])
y = np.array([2, 3, 4, 5, 6])

print(corrcoef(x, y)) # 0.98198050606
Generated code for numpy.ma.cov


import numpy as np

def cov(x, y, bias=True):
    """
    Computes the covariance matrix of two arrays.

    Parameters
    ----------
    x : array_like
        A 1-D or 2-D array containing multiple variables and observations.
    y : array_like
        A 1-D or 2-D array containing multiple variables and observations.
    bias : bool, optional
        If False, normalization is by (N - 1) where N is the number of observations given (unbiased estimate).
        If True, then normalization is by N.

    Returns
    -------
    out : ndarray
        A 2-D array containing the covariance matrix of the two arrays.

    """
    x = np.asarray(x)
    y = np.asarray(y)
    xmean = np.mean(x, axis=0)
    ymean = np.mean(y, axis=0)
    xm, ym = x - xmean, y - ymean
    if bias:
        fact = x.shape[0] * 1.0
    else:
        fact = x.shape[0] - 1.0
    return np.dot(xm.T, ym) / fact
Generated code for numpy.ma.cumsum


import numpy as np

def cumsum(arr):
    """
    Calculates the cumulative sum of the elements in the array.
    
    Parameters
    ----------
    arr : array_like
        Input array.
    
    Returns
    -------
    cumsum : ndarray
        A new array holding the result.
    
    Examples
    --------
    >>> arr = np.array([1, 2, 3])
    >>> np.ma.cumsum(arr)
    array([1, 3, 6])
    """
    return np.cumsum(arr)
Generated code for numpy.ma.cumprod


import numpy as np

def cumprod(arr):
    result = np.ones(arr.shape)
    for i in range(arr.shape[0]):
        for j in range(arr.shape[1]):
            result[i,j] = np.prod(arr[:i+1,j])
    return result

arr = np.array([[1,2,3],[4,5,6],[7,8,9]])
print(cumprod(arr))
Generated code for numpy.ma.mean


import numpy as np

def numpy_ma_mean(arr):
    """
    Calculates the mean of a numpy masked array.
    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array for which the mean should be calculated.
    Returns
    -------
    mean : float
        The mean of the array.
    """
    # Calculate the sum of the array
    sum_arr = np.ma.sum(arr)
    # Calculate the number of elements in the array
    num_elements = np.ma.count(arr)
    # Calculate the mean
    mean = sum_arr / num_elements
    return mean
Generated code for numpy.ma.median


import numpy as np

def median(a, axis=None, out=None, overwrite_input=False):
    """
    Compute the median along the specified axis.

    Returns the median of the array elements.

    Parameters
    ----------
    a : array_like
        Input array or object that can be converted to an array.
    axis : int, optional
        Axis along which the medians are computed. The default (axis=None)
        is to compute the median along a flattened version of the array.
    out : ndarray, optional
        Alternative output array in which to place the result. It must
        have the same shape and buffer length as the expected output,
        but the type (of the output) will be cast if necessary.
    overwrite_input : bool, optional
       If True, then allow use of memory of input array (a) for
       calculations. The input array will be modified by the call to
       median. This will save memory when you do not need to preserve
       the contents of the input array. Treat the input as undefined,
       but it will probably be fully or partially sorted. Default is
       False. Note that, if `overwrite_input` is True and the input
       is not already an ndarray, an error will be raised.

    Returns
    -------
    median : ndarray
        A new array holding the result. If the input contains
        integers, or floats of smaller precision than 64, then the output
        data-type is float64.  Otherwise, the output data-type is the same
        as that of the input.

    See Also
    --------
    mean, percentile

    Notes
    -----
    Given a vector V of length N, the median of V is the middle value of
    a sorted copy of V, ``V_sorted`` - i.e., ``V_sorted[(N-1)/2]``, when N
    is odd, and the average of the two middle values of ``V_sorted`` when N
    is even.

    Examples
    --------
    >>> a = np.array([[10, 7, 4], [3, 2, 1]])
    >>> np.ma.median
Generated code for numpy.ma.power


import numpy as np

def power(x, y):
    return np.ma.power(x, y)

x = np.array([1, 2, 3, 4])
y = np.array([2, 3, 4, 5])

result = power(x, y)

print(result)
Generated code for numpy.ma.prod


import numpy as np

def prod(a, axis=None, dtype=None, out=None, keepdims=False):
    """
    Return the product of array elements over a given axis.

    Parameters
    ----------
    a : array_like
        Input array.
    axis : None or int or tuple of ints, optional
        Axis or axes along which a product is performed.  The default,
        axis=None, will calculate the product of all the elements in the
        input array.  If axis is negative it counts from the last to the
        first axis.
    dtype : data-type, optional
        The data-type of the returned array, as well as of the accumulator
        in which the elements are multiplied.  By default, if `a` is of
        integer type, `dtype` is set to `np.int64`; otherwise, it is
        set to `np.float64`.  Note that `dtype` is always the same as the
        output array type.
    out : ndarray, optional
        Alternative output array in which to place the result. It must have
        the same shape as the expected output, but the type of the output
        values will be cast if necessary.
    keepdims : bool, optional
        If this is set to True, the axes which are reduced are left in the
        result as dimensions with size one. With this option, the result
        will broadcast correctly against the original `arr`.

    Returns
    -------
    product_along_axis : ndarray
        An array shaped as `a` but with the specified axis removed.
        Returns a reference to `out` if specified.

    See Also
    --------
    numpy.prod : equivalent function

    Examples
    --------
    >>> a = np.array([1,2,3])
    >>> np.ma.prod(a)
    6
    >>> np.ma.prod(a, dtype=np.float64)
    6.0
    >>> b = np.arange(24).reshape(2,3,4)
    >>> np.ma.prod(b, axis=1)
    array
Generated code for numpy.ma.std


import numpy as np

def numpy_ma_std(arr):
    return np.ma.std(arr, axis=None, dtype=None, out=None, ddof=0, keepdims=False)

#Example
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(numpy_ma_std(arr))
# Output: 2.581988897471611
Generated code for numpy.ma.sum


import numpy as np

def numpy_ma_sum(arr):
    return np.ma.sum(arr, axis=None)

# Example
arr = np.array([[1, 2], [3, 4]])
print(numpy_ma_sum(arr)) # 10
Generated code for numpy.ma.var


import numpy as np

def ma_var(x):
    """
    Calculate the variance of a masked array.
    Parameters
    ----------
    x : array_like
        Input array or object that can be converted to an array.
    Returns
    -------
    var : ndarray
        Variance of the input array.
    """
    x = np.ma.array(x)
    n = x.count()
    if n == 0:
        return np.ma.masked
    m = np.ma.mean(x)
    s = np.ma.sum((x - m)**2)
    return s / (n - 1)

# Example
x = np.ma.array([1, 2, 3, 4, 5], mask=[0, 0, 0, 1, 1])
print(ma_var(x))  # Output: 2.5
Generated code for numpy.ma.MaskedArray.anom


import numpy as np

def anom(arr):
    """
    Calculates the anomaly of a given array.
    
    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to calculate the anomaly of.
    
    Returns
    -------
    numpy.ma.MaskedArray
        The anomaly of the given array.
    """
    # Calculate the mean of the array
    mean = np.ma.mean(arr)
    
    # Subtract the mean from each element in the array
    anom = arr - mean
    
    # Return the anomaly
    return anom
Generated code for numpy.ma.MaskedArray.cumprod


import numpy as np

def cumprod(arr):
    """
    Computes the cumulative product of the elements of a numpy.ma.MaskedArray.
    
    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to compute the cumulative product of.
    
    Returns
    -------
    numpy.ma.MaskedArray
        The cumulative product of the elements of the array.
    """
    # Initialize the cumulative product array
    cumprod_arr = np.ma.MaskedArray(np.ones_like(arr))
    
    # Iterate over the array and compute the cumulative product
    for i in range(arr.shape[0]):
        cumprod_arr[i] = np.ma.prod(arr[:i+1])
    
    return cumprod_arr
Generated code for numpy.ma.MaskedArray.cumsum


import numpy as np

def cumsum(arr):
    """
    Calculates the cumulative sum of the elements of a numpy.ma.MaskedArray.
    
    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to calculate the cumulative sum of.
    
    Returns
    -------
    numpy.ma.MaskedArray
        The cumulative sum of the elements of the array.
    """
    # Create a copy of the array
    cumsum_arr = arr.copy()
    
    # Iterate over the array
    for i in range(1, arr.shape[0]):
        # Calculate the cumulative sum
        cumsum_arr[i] = cumsum_arr[i-1] + arr[i]
    
    # Return the cumulative sum
    return cumsum_arr
Generated code for numpy.ma.MaskedArray.mean


import numpy as np

def mean(arr):
    """
    Calculates the mean of a numpy.ma.MaskedArray.
    
    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array for which the mean is to be calculated.
    
    Returns
    -------
    mean : float
        The mean of the array.
    """
    # Get the sum of the array
    sum_arr = np.ma.sum(arr)
    
    # Get the number of elements in the array
    num_elements = np.ma.count(arr)
    
    # Calculate the mean
    mean = sum_arr / num_elements
    
    return mean
Generated code for numpy.ma.MaskedArray.prod


import numpy as np

def prod(arr, axis=None, dtype=None, out=None, keepdims=False):
    """
    Return the product of the array elements over the given axis.

    Parameters
    ----------
    arr : array_like
        Input array.
    axis : int, optional
        Axis along which the product is computed. The default (`axis` = `None`)
        is to compute the product of all the elements in the input array.
    dtype : data-type, optional
        The data-type of the returned array and of the accumulator in which
        the elements are multiplied.  By default, the dtype of `arr` is used.
    out : ndarray, optional
        Alternative output array in which to place the result. It must have
        the same shape as the expected output, but the type of the output
        values will be cast if necessary.
    keepdims : bool, optional
        If this is set to True, the axes which are reduced are left in the
        result as dimensions with size one. With this option, the result
        will broadcast correctly against the original `arr`.

    Returns
    -------
    prod : ndarray
        A new array holding the result is returned unless `out` is
        specified, in which case a reference to `out` is returned.

    See Also
    --------
    numpy.ma.MaskedArray.prod : equivalent function for masked arrays.

    Examples
    --------
    >>> arr = np.array([[1.,2.],[3.,4.]])
    >>> np.prod(arr)
    24.0
    >>> np.prod(arr, axis=0)
    array([ 3.,  8.])
    >>> np.prod(arr, axis=1)
    array([  2.,  12.])

    """
    arr = np.ma.MaskedArray(arr, copy=True)
    if dtype is None:
        dtype = arr.dtype
    if out is None:
        out = np.empty(arr.shape, dtype=dtype)
    np.ma.MaskedArray.prod(
Generated code for numpy.ma.MaskedArray.std


import numpy as np

def masked_array_std(arr, axis=None, dtype=None, out=None, ddof=0, keepdims=False):
    """
    Calculate the standard deviation of a masked array along the specified axis.

    Parameters
    ----------
    arr : array_like
        Input array or object that can be converted to an array.
    axis : int, optional
        Axis along which the standard deviation is computed. The default is to
        compute the standard deviation of the flattened array.
    dtype : data-type, optional
        Type to use in computing the standard deviation. For arrays of
        integer type the default is float64, for arrays of float types it is
        the same as the array type.
    out : ndarray, optional
        Alternative output array in which to place the result. It must have
        the same shape as the expected output, but the type of the output
        values will be cast if necessary.
    ddof : int, optional
        Means Delta Degrees of Freedom. The divisor used in calculations
        is N - ddof, where N represents the number of elements. By default
        ddof is zero.
    keepdims : bool, optional
        If this is set to True, the axes which are reduced are left in the
        result as dimensions with size one. With this option, the result
        will broadcast correctly against the original array.

    Returns
    -------
    standard_deviation : ndarray
        A new array holding the result is returned unless out is
        specified, in which case a reference to out is returned.

    Examples
    --------
    >>> x = np.ma.array([1, 2, 3, 4], mask=[0, 0, 1, 0])
    >>> np.ma.std(x)
    1.1180339887498949
    >>> np.ma.std(x, axis=0)
    1.1180339887498949
    >>> np.ma.std(x, axis=1)
    0.0

    """
    arr = np.ma.asarray(arr)
    if dtype is None:
        dtype = np.result
Generated code for numpy.ma.MaskedArray.sum


import numpy as np

def masked_array_sum(arr):
    """
    Calculates the sum of all elements in a numpy.ma.MaskedArray.
    
    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to sum.
    
    Returns
    -------
    float
        The sum of all elements in the array.
    """
    # Get the mask of the array
    mask = arr.mask
    
    # Initialize the sum
    sum = 0
    
    # Iterate over the array
    for i in range(arr.shape[0]):
        for j in range(arr.shape[1]):
            # If the element is not masked, add it to the sum
            if not mask[i, j]:
                sum += arr[i, j]
    
    return sum
Generated code for numpy.ma.MaskedArray.var


import numpy as np

def masked_array_var(arr):
    """
    Calculates the variance of a numpy.ma.MaskedArray.
    
    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array for which the variance is to be calculated.
    
    Returns
    -------
    float
        The variance of the array.
    """
    # Calculate the mean of the array
    mean = np.ma.mean(arr)
    
    # Calculate the sum of the squared differences from the mean
    sum_sq_diff = np.ma.sum((arr - mean)**2)
    
    # Calculate the variance
    var = sum_sq_diff / (arr.count() - 1)
    
    return var
Generated code for numpy.ma.argmax


import numpy as np

def numpy_ma_argmax(arr):
    # Get the maximum value from the array
    max_val = np.ma.max(arr)
    # Get the indices of the maximum value
    max_indices = np.where(arr == max_val)
    # Return the first index of the maximum value
    return max_indices[0][0]

# Example
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(numpy_ma_argmax(arr)) # Output: 8
Generated code for numpy.ma.argmin


import numpy as np

def numpy_ma_argmin(arr):
    return np.ma.argmin(arr)

# Usage
arr = np.array([[1,2,3], [4,5,6], [7,8,9]])
print(numpy_ma_argmin(arr)) # Output: 0
Generated code for numpy.ma.max


import numpy as np

def max_ma(arr):
    # Create a masked array from the input array
    ma_arr = np.ma.masked_array(arr)
    
    # Find the maximum value in the masked array
    max_val = np.ma.max(ma_arr)
    
    # Return the maximum value
    return max_val
Generated code for numpy.ma.min


import numpy as np

arr = np.ma.array([[1,2,3], [4,5,6], [7,8,9]])

min_val = np.ma.min(arr)

print(min_val)
Generated code for numpy.ma.ptp


import numpy as np

def ptp(a, axis=None):
    """
    Return the peak-to-peak (maximum - minimum) value along a given axis.
    
    Parameters
    ----------
    a : array_like
        Input array.
    axis : int, optional
        Axis along which to find the peak-to-peak (maximum - minimum) value.
        By default, flatten the array.

    Returns
    -------
    ptp : ndarray
        A new array holding the result, unless `out` was
        specified, in which case a reference to `out` is returned.

    Examples
    --------
    >>> x = np.ma.array([1, 2, 3, 4, 5, 6])
    >>> np.ma.ptp(x)
    5
    >>> np.ma.ptp(x, axis=0)
    5
    >>> np.ma.ptp(x, axis=1)
    0
    """
    a = np.ma.asanyarray(a)
    if axis is None:
        a = a.ravel()
        axis = 0
    return a.max(axis=axis) - a.min(axis=axis)
Generated code for numpy.ma.diff


import numpy as np

def diff(arr):
    """
    Calculates the difference between adjacent elements in a numpy array.
    
    Parameters
    ----------
    arr : numpy array
        The array to calculate the difference of.
    
    Returns
    -------
    numpy array
        The difference between adjacent elements in the array.
    """
    return np.ma.diff(arr)
Generated code for numpy.ma.MaskedArray.argmax


import numpy as np

def argmax(arr):
    """
    Returns the indices of the maximum values in a numpy.ma.MaskedArray.
    
    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to find the maximum values in.
    
    Returns
    -------
    indices : tuple
        A tuple of the indices of the maximum values in the array.
    """
    # Get the indices of the non-masked elements
    indices = np.where(~arr.mask)
    
    # Get the maximum value
    max_val = np.max(arr[indices])
    
    # Get the indices of the maximum value
    max_indices = np.where(arr == max_val)
    
    return max_indices
Generated code for numpy.ma.MaskedArray.argmin


import numpy as np

def argmin(arr):
    """
    Find the index of the minimum value in a numpy.ma.MaskedArray.
    
    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to search for the minimum value.
    
    Returns
    -------
    index : int
        The index of the minimum value in the array.
    """
    # Get the indices of the unmasked elements
    indices = np.where(~arr.mask)
    
    # Get the minimum value
    min_val = np.min(arr[indices])
    
    # Get the index of the minimum value
    index = np.where(arr == min_val)[0][0]
    
    return index
Generated code for numpy.ma.MaskedArray.max


import numpy as np

def max(arr):
    # Create a masked array from the input array
    masked_arr = np.ma.MaskedArray(arr)
    
    # Find the maximum value in the array
    max_val = np.ma.max(masked_arr)
    
    # Return the maximum value
    return max_val
Generated code for numpy.ma.MaskedArray.min


import numpy as np

def masked_array_min(arr):
    """
    Finds the minimum value of a numpy.ma.MaskedArray.
    
    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to find the minimum value of.
    
    Returns
    -------
    min_val : float
        The minimum value of the array.
    """
    # Get the data from the array
    data = arr.data
    
    # Get the mask from the array
    mask = arr.mask
    
    # Create a new array with only the unmasked values
    unmasked_data = data[~mask]
    
    # Find the minimum value of the unmasked data
    min_val = np.min(unmasked_data)
    
    return min_val
Generated code for numpy.ma.MaskedArray.ptp


import numpy as np

def ptp(arr, axis=None):
    """
    Return the range (maximum - minimum) of values along an axis.

    Parameters
    ----------
    arr : array_like
        Input array.
    axis : int, optional
        Axis along which to find the range of values.  By default,
        the range is computed over the entire array.

    Returns
    -------
    ptp : ndarray
        The range of values along the specified axis.

    See Also
    --------
    numpy.ptp : equivalent function
    """
    arr = np.ma.MaskedArray(arr)
    return np.ptp(arr, axis)
Generated code for numpy.ma.argsort


import numpy as np

# Create a numpy array
arr = np.array([[3, 2, 4], [5, 0, 1]])

# Use numpy.ma.argsort to sort the array
sorted_arr = np.ma.argsort(arr)

# Print the sorted array
print(sorted_arr)

# Output:
# [[1 2 0]
#  [2 0 1]]
Generated code for numpy.ma.sort


import numpy as np

# Create a numpy array
arr = np.array([[3, 2, 4],
                [5, 0, 1]])

# Sort the array using numpy.ma.sort
sorted_arr = np.ma.sort(arr)

# Print the sorted array
print(sorted_arr)

# Output
# [[2 3 4]
#  [0 1 5]]
Generated code for numpy.ma.MaskedArray.argsort


import numpy as np

def argsort(arr):
    # Create a copy of the array
    arr_copy = np.ma.MaskedArray(arr)
    # Sort the array
    arr_copy.sort()
    # Get the indices of the sorted array
    indices = np.argsort(arr_copy)
    # Return the indices
    return indices
Generated code for numpy.ma.MaskedArray.sort


import numpy as np

def masked_array_sort(arr):
    """
    Sort a numpy.ma.MaskedArray in-place.
    """
    # Get the indices of the unmasked elements
    unmasked_indices = np.where(~arr.mask)[0]
    # Sort the unmasked elements
    arr[unmasked_indices] = np.sort(arr[unmasked_indices])
    # Return the sorted array
    return arr
Generated code for numpy.ma.diag


import numpy as np

def np_ma_diag(v, k=0):
    """
    Return a 2-D array with the diagonal elements of v on the k-th diagonal.
    
    Parameters
    ----------
    v : array_like
        Input array.
    k : int, optional
        Diagonal in question. The default is 0. Use k>0 for diagonals above
        the main diagonal, and k<0 for diagonals below the main diagonal.
    
    Returns
    -------
    out : numpy.ma.MaskedArray
        The 2-D output array.
    """
    # Create a masked array from the input array
    out = np.ma.masked_array(v)
    
    # Get the shape of the array
    n = out.shape[0]
    
    # Create the mask
    mask = np.zeros((n, n), dtype=bool)
    mask[np.diag_indices(n, k=k)] = True
    out.mask = mask
    
    return out
Generated code for numpy.ma.dot


import numpy as np

def numpy_ma_dot(a, b):
    """
    Computes the dot product of two arrays using numpy.ma.dot.

    Parameters
    ----------
    a : array_like
        First argument.
    b : array_like
        Second argument.

    Returns
    -------
    dot : ndarray
        Dot product of `a` and `b`.
    """
    return np.ma.dot(a, b)
Generated code for numpy.ma.identity


import numpy as np

def numpy_ma_identity(n):
    return np.ma.masked_equal(np.eye(n), 0)

# Usage
numpy_ma_identity(3)
# Output
# masked_array(
#   data=[[1., 0., 0.],
#         [0., 1., 0.],
#         [0., 0., 1.]],
#   mask=[[False,  True,  True],
#         [ True, False,  True],
#         [ True,  True, False]],
#   fill_value=0.0,
#   dtype=float32)
Generated code for numpy.ma.inner


import numpy as np

def numpy_ma_inner(a, b):
    """
    Computes the inner product of two arrays using numpy.ma.inner.

    Parameters
    ----------
    a : array_like
        First array.
    b : array_like
        Second array.

    Returns
    -------
    out : float
        Inner product of the two arrays.
    """
    return np.ma.inner(a, b)
Generated code for numpy.ma.innerproduct


import numpy as np

def innerproduct(a, b):
    """
    Computes the inner product of two arrays using numpy.ma.innerproduct.
    
    Parameters
    ----------
    a : array_like
        The first array.
    b : array_like
        The second array.
    
    Returns
    -------
    out : float
        The inner product of the two arrays.
    """
    return np.ma.innerproduct(a, b)
Generated code for numpy.ma.outer


import numpy as np

def outer(a, b):
    """
    Compute the outer product of two arrays.

    Parameters
    ----------
    a : array_like
        First input array.
    b : array_like
        Second input array.

    Returns
    -------
    out : ndarray
        The outer product of `a` and `b`.

    Examples
    --------
    >>> a = np.array([1,2,3])
    >>> b = np.array([2,3,4])
    >>> np.ma.outer(a, b)
    array([[ 2,  3,  4],
           [ 4,  6,  8],
           [ 6,  9, 12]])
    """
    return np.ma.outer(a, b)
Generated code for numpy.ma.outerproduct


import numpy as np

def outerproduct(a, b):
    """
    Computes the outer product of two vectors a and b.
    
    Parameters
    ----------
    a : array_like
        First input vector.
    b : array_like
        Second input vector.
    
    Returns
    -------
    out : ndarray
        Outer product of a and b.
    """
    a = np.asarray(a)
    b = np.asarray(b)
    out = np.ma.empty((a.size, b.size))
    for i in range(a.size):
        out[i, :] = a[i] * b
    return out
Generated code for numpy.ma.trace


import numpy as np

def trace(a):
    """
    Return the sum along diagonals of the array.

    Parameters
    ----------
    a : array_like
        Input array, from which the diagonals are taken.

    Returns
    -------
    trace : ndarray
        The sum along the diagonals of the array.

    Examples
    --------
    >>> a = np.arange(4).reshape(2,2)
    >>> a
    array([[0, 1],
           [2, 3]])
    >>> np.ma.trace(a)
    array([3])
    """
    return np.ma.sum(np.diagonal(a))
Generated code for numpy.ma.transpose


import numpy as np

def transpose(arr):
    return np.ma.transpose(arr)

# Example
arr = np.array([[1,2,3], [4,5,6], [7,8,9]])
print(transpose(arr))

# Output
# [[1 4 7]
#  [2 5 8]
#  [3 6 9]]
Generated code for numpy.ma.MaskedArray.trace


import numpy as np

def trace(a, offset=0, axis1=0, axis2=1, dtype=None, out=None):
    """
    Return the sum along diagonals of the array.

    Parameters
    ----------
    a : array_like
        Array from which the diagonals are taken.
    offset : int, optional
        Offset of the diagonal from the main diagonal. Can be both
        positive and negative. Defaults to 0.
    axis1, axis2 : int, optional
        Axes to be used as the first and second axis of the 2-D sub-arrays
        from which the diagonals should be taken.  Defaults are the first
        two axes of `a`.
    dtype : dtype, optional
        Type of the returned array and of the accumulator in which the
        elements are summed.  If `dtype` is not specified, it defaults
        to the dtype of `a`, unless `a` has an integer dtype with a
        precision less than that of the default platform integer.  In
        that case, the default platform integer is used.
    out : ndarray, optional
        Array into which the output is placed. Its type is preserved
        and it must be of the right shape to hold the output.

    Returns
    -------
    sum_along_diagonals : ndarray
        If `out` is None, return a new array containing the sum along
        the diagonals, otherwise a reference to `out` is returned.

    See Also
    --------
    numpy.trace : equivalent function

    Examples
    --------
    >>> a = np.arange(4).reshape(2,2)
    >>> a
    array([[0, 1],
           [2, 3]])
    >>> np.ma.trace(a)
    3
    >>> np.ma.trace(a, offset=1)
    2
    >>> np.ma.trace(a, offset=-1)
    1

    """
    a = np.ma.asanyarray(a)
    if dtype is None:
        dtype = np.find_common_type
Generated code for numpy.ma.MaskedArray.transpose


import numpy as np

def transpose(arr):
    """
    Transpose a numpy.ma.MaskedArray.
    
    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to be transposed.
    
    Returns
    -------
    numpy.ma.MaskedArray
        The transposed array.
    """
    # Get the shape of the array
    shape = arr.shape
    # Create a new array with the transposed shape
    new_arr = np.ma.masked_array(np.empty(shape[::-1]), mask=arr.mask)
    # Iterate over the elements of the array
    for i in range(shape[0]):
        for j in range(shape[1]):
            # Set the transposed element
            new_arr[j, i] = arr[i, j]
    # Return the transposed array
    return new_arr
Generated code for numpy.ma.vander


import numpy as np

def np_ma_vander(x, N=None, increasing=False):
    """
    Return a Vandermonde matrix of given shape and order.

    Parameters
    ----------
    x : array_like
        1-D array of values for the Vandermonde matrix.
    N : int, optional
        Order of the matrix.  If `N` is not specified, then `N` is taken to be
        ``len(x)``.
    increasing : bool, optional
        Order of the powers of the columns.  If True, the powers increase from
        left to right, if False (the default) they are in reverse order.

    Returns
    -------
    out : ndarray
        Vandermonde matrix.  The shape of the returned matrix is ``(N, len(x))``.

    Examples
    --------
    >>> x = np.array([1, 2, 3, 5])
    >>> np.ma.vander(x)
    array([[  1,   1,   1,   1],
           [  8,   4,   2,   1],
           [ 27,   9,   3,   1],
           [125,  25,   5,   1]])

    >>> np.ma.vander(x, increasing=True)
    array([[  1,   1,   1,   1],
           [  1,   2,   4,   8],
           [  1,   3,   9,  27],
           [  1,   5,  25, 125]])

    """
    x = np.asarray(x)
    if N is None:
        N = len(x)

    v = np.empty((N, len(x)), dtype=np.ma.masked_array)
    tmp = x.reshape(x.shape[0], 1)
    if increasing:
        for i in range(N):
            v[i] = np.ma.masked_array(tmp**(N - i - 1), mask=x.mask)
    else:
        for i in range(N):
            v
Generated code for numpy.ma.polyfit


import numpy as np

def polyfit(x, y, degree):
    results = {}

    coeffs = np.ma.polyfit(x, y, degree)
    
    # Polynomial Coefficients
    results['polynomial'] = coeffs.tolist()

    # r-squared
    p = np.poly1d(coeffs)
    # fit values, and mean
    yhat = p(x)                         # or [p(z) for z in x]
    ybar = np.sum(y)/len(y)          # or sum(y)/len(y)
    ssreg = np.sum((yhat-ybar)**2)   # or sum([ (yihat - ybar)**2 for yihat in yhat])
    sstot = np.sum((y - ybar)**2)    # or sum([ (yi - ybar)**2 for yi in y])
    results['determination'] = ssreg / sstot

    return results

x = [1, 2, 3, 4, 5]
y = [2, 4, 5, 4, 5]

print(polyfit(x, y, 2))
Generated code for numpy.ma.around


import numpy as np

def np_ma_around(x, decimals=0):
    """
    Rounds the elements of an array to the given number of decimals.
    
    Parameters
    ----------
    x : array_like
        Input array.
    decimals : int, optional
        Number of decimals to round to (default is 0).
    
    Returns
    -------
    out : ndarray
        Output array.
    """
    return np.ma.around(x, decimals)
Generated code for numpy.ma.clip


import numpy as np

def clip(a, a_min, a_max, out=None):
    """
    Clip (limit) the values in an array.

    Given an interval, values outside the interval are clipped to
    the interval edges.  For example, if an interval of ``[0, 1]``
    is specified, values smaller than 0 become 0, and values larger
    than 1 become 1.

    Parameters
    ----------
    a : array_like
        Array containing elements to clip.
    a_min : scalar or array_like
        Minimum value. If `a_min` is scalar, the same `a_min` will
        be applied to all elements of `a`. If `a_min` is an array,
        it must be of the same shape as `a`.
    a_max : scalar or array_like
        Maximum value. If `a_max` is scalar, the same `a_max` will
        be applied to all elements of `a`. If `a_max` is an array,
        it must be of the same shape as `a`.
    out : ndarray, optional
        The results will be placed in this array. It may be the input
        array for in-place clipping.  `out` must be of the right shape
        to hold the output.  Its type is preserved.

    Returns
    -------
    clipped_array : ndarray
        An array with the elements of `a`, but clipped to the interval
        ``[a_min, a_max]``.

    See Also
    --------
    numpy.clip : equivalent function

    Examples
    --------
    >>> a = np.arange(10)
    >>> np.ma.clip(a, 1, 8)
    array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])

    >>> a = np.arange(10)
    >>> a_min = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
    >>> np.ma.clip(a, a_min, 8)
    array([1, 2,
Generated code for numpy.ma.round


import numpy as np

def np_ma_round(x, decimals=0):
    """
    Rounds the elements of an array to the given number of decimals.
    Parameters
    ----------
    x : array_like
        Input array.
    decimals : int, optional
        Number of decimals to round to (default: 0).
    Returns
    -------
    rounded_array : numpy.ma.core.MaskedArray
        Output array with rounded elements.
    """
    return np.ma.masked_array(np.round(x, decimals=decimals))
Generated code for numpy.ma.MaskedArray.clip


import numpy as np

def clip(arr, min_val, max_val):
    """
    Clip the values of a masked array to the given range.

    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to clip.
    min_val : float
        The minimum value to clip to.
    max_val : float
        The maximum value to clip to.

    Returns
    -------
    numpy.ma.MaskedArray
        The clipped array.
    """
    return np.ma.MaskedArray(np.clip(arr.data, min_val, max_val),
                             mask=arr.mask)
Generated code for numpy.ma.MaskedArray.round


import numpy as np

def round_masked_array(arr):
    """
    Rounds the elements of a numpy.ma.MaskedArray.
    
    Parameters
    ----------
    arr : numpy.ma.MaskedArray
        The array to round.
    
    Returns
    -------
    numpy.ma.MaskedArray
        The rounded array.
    """
    return np.ma.MaskedArray(np.round(arr.data), mask=arr.mask)
Generated code for numpy.ma.allequal


import numpy as np

def np_ma_allequal(arr1, arr2):
    """
    Checks if all elements of two numpy.ma arrays are equal.

    Parameters
    ----------
    arr1 : numpy.ma array
        First array to compare.
    arr2 : numpy.ma array
        Second array to compare.

    Returns
    -------
    bool
        True if all elements of the two arrays are equal, False otherwise.
    """
    if arr1.shape != arr2.shape:
        return False
    else:
        return np.all(arr1 == arr2)
Generated code for numpy.ma.allclose


import numpy as np

def allclose(a, b, rtol=1e-5, atol=1e-8):
    """
    Returns True if two arrays are element-wise equal within a tolerance.

    The tolerance values are positive, typically very small numbers. The
    relative difference (`rtol` * abs(`b`)) and the absolute difference
    `atol` are added together to compare against the absolute difference
    between `a` and `b`.

    Parameters
    ----------
    a, b : array_like
        Input arrays to compare.
    rtol : float
        The relative tolerance parameter (see Notes).
    atol : float
        The absolute tolerance parameter (see Notes).

    Returns
    -------
    allclose : bool
        Returns True if the two arrays are equal within the given
        tolerance; False otherwise.

    See Also
    --------
    all, any, where

    Notes
    -----
    If the following equation is element-wise True, then allclose returns
    True.

        absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))

    The above equation is not symmetric in `a` and `b`, so that
    `allclose(a, b)` might be different from `allclose(b, a)` in
    some rare cases.

    Examples
    --------
    >>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])
    False
    >>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])
    True
    >>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])
    False
    >>> np.allclose([1.0, np.nan], [1.0, np.nan])
    True

    """
    a = np.asanyarray(a)
    b = np.asanyarray(b)
    return np.all(np.less_equal(np.abs(a - b),
Generated code for numpy.ma.apply_along_axis


import numpy as np

def apply_along_axis(func1d, axis, arr, *args, **kwargs):
    """
    Apply a function to 1-D slices along the given axis.
    Execute `func1d(a, *args, **kwargs)` where `func1d` operates
    on 1-D arrays and `a` is a 1-D slice of `arr` along
    the given axis.
    Parameters
    ----------
    func1d : function
        This function should accept 1-D arrays. It is applied to 1-D
        slices of `arr` along the specified axis.
    axis : int
        Axis along which `arr` is sliced.
    arr : ndarray
        Array over which the function is applied.
    args : tuple
        Arguments passed to `func1d`.
    kwargs : dict
        Keyword arguments passed to `func1d`.
    Returns
    -------
    apply_along_axis : ndarray
        The output array.
    See Also
    --------
    numpy.apply_over_axes
    Examples
    --------
    >>> arr = np.arange(24).reshape(2,3,4)
    >>> np.ma.apply_along_axis(np.mean, 0, arr)
    array([[ 6.,  7.,  8.,  9.],
           [18., 19., 20., 21.]])
    """
    arr = np.asanyarray(arr)
    nd = arr.ndim
    ind = [0] * nd
    indlist = list(range(nd))
    indlist.remove(axis)
    ind = indlist + [axis]
    arr = arr.transpose(ind).copy()
    outshape = list(arr.shape)
    outshape[-1] = 1
    out = np.empty(outshape, dtype=arr.dtype)
    for i, a in enumerate(arr):
        out[..., i] = func1d(a, *args, **kwargs)
    return out.transpose(indlist + [nd - 1])
Generated code for numpy.ma.apply_over_axes


import numpy as np

def apply_over_axes(func, a, axes):
    # Create an iterator object
    it = np.nditer(a, flags=['multi_index'], op_flags=['readwrite'])
    # Iterate over all elements of the array
    while not it.finished:
        # Get the current element and its index
        element = it[0]
        index = it.multi_index
        # Apply the function to the element
        it[0] = func(element, index, axes)
        # Move to the next element
        it.iternext()
    return a

# Example usage
a = np.arange(24).reshape(2, 3, 4)
axes = (1, 2)

def func(element, index, axes):
    return np.sum(element[axes])

result = apply_over_axes(func, a, axes)
print(result)

# Output:
# [[[ 6  8 10 12]
#   [22 24 26 28]]
# 
#  [[38 40 42 44]
#   [54 56 58 60]]]
Generated code for numpy.ma.arange


import numpy as np

# Create a numpy array of size 10
arr = np.arange(10)

# Create a masked array from the array
masked_arr = np.ma.masked_array(arr)

# Create a range of values from the masked array
result = np.ma.arange(masked_arr)

# Print the result
print(result)
Generated code for numpy.ma.choose


import numpy as np

def choose(condlist, choicelist, default=0):
    """
    Return an array drawn from elements in choicelist, depending on conditions.
    Parameters
    ----------
    condlist : list of bool ndarrays
        Each boolean array corresponds to a choice array in choicelist.
    choicelist : sequence of ndarrays
        Choice arrays from which to draw the output array.
    default : scalar, optional
        Value to use when all conditions are False.
    Returns
    -------
    output : ndarray
        The output array has the same shape as that of the boolean
        arrays in condlist.
    """
    output = np.ma.array(default * np.ones(condlist[0].shape))
    for cond, choice in zip(condlist, choicelist):
        output = np.where(cond, choice, output)
    return output
Generated code for numpy.ma.ediff1d


import numpy as np

def ediff1d(arr):
    """
    Calculates the first order difference of an array.
    
    Parameters
    ----------
    arr : array_like
        Input array.
    
    Returns
    -------
    ediff1d : ndarray
        The differences. The length of the output is one less than the
        length of the input.
    
    Examples
    --------
    >>> x = np.array([1, 2, 4, 7, 0])
    >>> np.ma.ediff1d(x)
    array([ 1,  2,  3, -7])
    """
    return np.ma.diff(arr)
Generated code for numpy.ma.indices


import numpy as np

def indices(dimensions, dtype=np.int):
    """Return an array representing a grid of given dimensions.

    Parameters
    ----------
    dimensions : sequence of ints
        The dimensions of the grid.
    dtype : data-type, optional
        The desired data-type for the array.

    Returns
    -------
    grid : ndarray
        The array of grid coordinates,
        ``grid.shape = (len(dimensions),) + tuple(dimensions)``.

    Examples
    --------
    >>> np.ma.indices((2, 3))
    array([[[0, 0, 0],
            [1, 1, 1]],
           [[0, 1, 2],
            [0, 1, 2]]])
    """
    return np.indices(dimensions, dtype=dtype)
Generated code for numpy.ma.where


import numpy as np

# Create a numpy array
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# Use np.ma.where to find the indices of elements that meet a certain condition
indices = np.ma.where(arr > 5)

# Print the indices
print(indices)

# Output: (array([2, 2]), array([0, 1]))
Generated code for numpy.sin


import numpy as np 

# Calculate the sine of x 
x = np.pi/4 
y = np.sin(x) 

print(y)
Generated code for numpy.cos


import numpy as np

# Calculate cosine of an angle
angle = np.pi/4
cos_angle = np.cos(angle)

print("Cosine of angle is:", cos_angle)
Generated code for numpy.tan


import numpy as np

def tan(x):
  return np.tan(x)

# Usage
x = np.pi/4
print(tan(x))
Generated code for numpy.arcsin


import numpy as np

def arcsin(x):
    return np.arcsin(x)

x = 0.5
print(arcsin(x))
Generated code for numpy.arccos


import numpy as np

def arccos(x):
  return np.arccos(x)

x = 0.5
print(arccos(x))
Generated code for numpy.arctan


import numpy as np

def arctan(x):
    return np.arctan(x)

x = 1.0
print(arctan(x))
Generated code for numpy.hypot


import numpy as np

def numpy_hypot(x, y):
    return np.sqrt(x**2 + y**2)

# Usage
x = 3
y = 4
print(numpy_hypot(x, y)) # Output: 5.0
Generated code for numpy.arctan2


import numpy as np

def arctan2(y, x):
    """
    Computes the element-wise arc tangent of y/x choosing the quadrant correctly.
    Parameters
    ----------
    y : array_like
        The y-coordinates of the points.
    x : array_like
        The x-coordinates of the points.
    Returns
    -------
    angle : ndarray
        The angle of the vector (y, x) in radians, shaped as y.
    """
    angle = np.arctan2(y, x)
    return angle
Generated code for numpy.degrees


import numpy as np

def degrees(x):
    return x * (180/np.pi)

# Usage
radians = np.array([0, np.pi/2, np.pi])
degrees(radians)
# array([  0.,  90., 180.])
Generated code for numpy.radians


def numpy_radians(degrees):
  return degrees * np.pi / 180.0
Generated code for numpy.unwrap


import numpy as np

def unwrap(p, discont=np.pi, axis=-1):
    """
    Unwrap radian phase p by changing absolute jumps greater than discont
    to their 2*pi complement along the given axis.
    """
    p = np.asarray(p)
    ndim = p.ndim
    if ndim == 0:
        return p
    if axis < 0:
        axis += ndim
    # Find differences along the axis
    dp = np.diff(p, axis=axis)
    # Find jumps that are bigger than the threshold
    jump_mask = np.abs(dp) > discont
    # Check the sign of the jump and subtract or add 2*pi from the jump
    sign_mask = np.sign(dp[jump_mask])
    dp[jump_mask] -= sign_mask * 2 * np.pi
    # Integrate the differences to get the absolute phase along the axis
    p = np.cumsum(dp, axis=axis)
    # Add the initial value
    p = np.concatenate((np.expand_dims(p[0], axis=axis), p), axis=axis)
    return p
Generated code for numpy.deg2rad


import numpy as np

def deg2rad(degrees):
    return degrees * np.pi / 180.0

# Usage
radians = deg2rad(45)
print(radians) # 0.7853981633974483
Generated code for numpy.rad2deg


import numpy as np

def rad2deg(rad):
    return np.rad2deg(rad)

rad = np.array([0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi])
deg = rad2deg(rad)

print(deg)
# Output: [  0.  90. 180. 270. 360.]
Generated code for numpy.sinh


import numpy as np

# Calculate sinh of an array
arr = np.array([0, np.pi/2, np.pi])
sinh_arr = np.sinh(arr)

# Print the sinh of the array
print(sinh_arr)
Generated code for numpy.cosh


import numpy as np

def cosh(x):
    return (np.exp(x) + np.exp(-x)) / 2

# Test
x = np.array([0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi])
print(cosh(x))
# Output: [1.         1.54308063 3.76219569 11.59195327 74.20994862]
Generated code for numpy.tanh


import numpy as np

def tanh(x):
  return np.tanh(x)
Generated code for numpy.arcsinh


import numpy as np

def arcsinh(x):
  return np.log(x + np.sqrt(x**2 + 1))

# Usage
x = np.array([1, 2, 3])
print(arcsinh(x))
Generated code for numpy.arccosh


import numpy as np

def arccosh(x):
    return np.log(x + np.sqrt(x**2 - 1))

# Usage
x = 2
print(arccosh(x)) # 1.3169578969248166
Generated code for numpy.arctanh


import numpy as np

def arctanh(x):
    return np.log((1+x)/(1-x))/2

# Usage
x = 0.5
print(arctanh(x)) # 0.5493061443340549
Generated code for numpy.around


import numpy as np

# Round to the nearest integer
rounded_array = np.around(np.array([1.2, 3.4, 5.6, 7.8, 9.0]), 0)

# Round to two decimal places
rounded_array = np.around(np.array([1.2, 3.4, 5.6, 7.8, 9.0]), 2)

# Round to the nearest multiple of 10
rounded_array = np.around(np.array([1.2, 3.4, 5.6, 7.8, 9.0]), -1)
Generated code for numpy.rint


import numpy as np 

# Create an array 
arr = np.array([1.1, 2.2, 3.3, 4.4, 5.5]) 

# Round off the array elements 
rounded_arr = np.rint(arr) 

# Print the rounded array 
print(rounded_arr)
Generated code for numpy.fix


import numpy as np

def fix(x):
    """
    Rounds a numpy array to the nearest integer.
    
    Parameters
    ----------
    x : numpy array
        The array to be rounded.
    
    Returns
    -------
    numpy array
        The rounded array.
    """
    return np.round(x).astype(int)
Generated code for numpy.floor


import numpy as np

# Create an array
arr = np.array([1.2, 2.3, 3.4, 4.5])

# Use numpy.floor() to round down the elements of the array
np.floor(arr)

# Output: array([1., 2., 3., 4.])
Generated code for numpy.ceil


import numpy as np

def ceil(x):
  return np.ceil(x)

# Usage
x = 3.14
print(ceil(x)) # 4.0
Generated code for numpy.trunc


import numpy as np

def trunc(x):
    return np.trunc(x)

x = np.array([1.2, 3.4, 5.6, 7.8])

print(trunc(x))
Generated code for numpy.prod


import numpy as np 

def prod(arr): 
	
	# Initialize result 
	prod = 1
	
	# Multiply elements one by one 
	for i in range(0, len(arr)): 
		prod = prod * arr[i] 
	
	return prod 

# Driver Code 
arr = [1, 2, 3, 4] 
print(prod(arr))
Generated code for numpy.sum


import numpy as np 

# Create a numpy array 
arr = np.array([1, 2, 3, 4]) 

# Calculate sum of all elements 
total = np.sum(arr) 

# Print the result 
print("Sum of all elements in the array:", total)
Generated code for numpy.nanprod


import numpy as np 

def nanprod(arr): 
    # Replace NaN with 1 
    arr[np.isnan(arr)] = 1 
    # Calculate product 
    prod = np.prod(arr) 
    return prod 

# Driver code 
arr = np.array([1, 2, np.nan, 3, 4]) 
print(nanprod(arr))
Generated code for numpy.nansum


import numpy as np

def nan_sum(arr):
    return np.nansum(arr, axis=None)

arr = np.array([[1, np.nan, 2], [3, 4, np.nan]])

print(nan_sum(arr)) # 10.0
Generated code for numpy.cumprod


import numpy as np 

def cumprod(arr): 
	prod = 1
	cumprod_arr = [] 
	
	# Iterate over the array 
	for i in range(0, len(arr)): 
		prod = prod * arr[i] 
		cumprod_arr.append(prod) 
	
	return np.array(cumprod_arr) 

# Driver code 
arr = [1, 2, 3, 4] 
print(cumprod(arr))
Generated code for numpy.cumsum


import numpy as np 

# Create an array 
arr = np.array([1, 2, 3, 4]) 

# Calculate cumulative sum 
result = np.cumsum(arr) 

# Print the result 
print(result)
Generated code for numpy.nancumprod


import numpy as np 

def nanprod(arr): 
    result = np.cumprod(arr, dtype=float) 
    mask = np.isnan(arr) 
    result[mask] = np.nan 
    return result 
  
# Driver Code 
arr = np.array([1, 2, np.nan, 3, 4]) 
print(nanprod(arr))
Generated code for numpy.nancumsum


import numpy as np 

def nan_cumsum(arr): 
    # Create a copy of the array 
    arr_copy = np.copy(arr) 
  
    # Replace nan with 0 in the copy 
    arr_copy[np.isnan(arr_copy)] = 0
  
    # Calculate cumulative sum ignoring nan 
    return np.cumsum(arr_copy) 
  
# Driver code 
arr = np.array([1, np.nan, 2, 3, np.nan, 4]) 
print(nan_cumsum(arr))
Generated code for numpy.diff


import numpy as np

def numpy_diff(arr):
    return np.diff(arr)

#Example
arr = np.array([1,2,3,4,5])
print(numpy_diff(arr))
# Output: [1 1 1 1]
Generated code for numpy.ediff1d


import numpy as np

def ediff1d(arr):
    """
    Calculates the first order difference of an array.
    
    Parameters
    ----------
    arr : array_like
        Input array.
    
    Returns
    -------
    ediff1d : ndarray
        The differences. The length of the array is one less than the
        input array.
    
    Examples
    --------
    >>> x = np.array([1, 2, 4, 7, 0])
    >>> np.ediff1d(x)
    array([ 1,  2,  3, -7])
    """
    return np.diff(arr)
Generated code for numpy.gradient
