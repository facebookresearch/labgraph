[{"C:\\Users\\zenak\\Desktop\\labgraph_monitor\\src\\index.js":"1","C:\\Users\\zenak\\Desktop\\labgraph_monitor\\src\\App.js":"2","C:\\Users\\zenak\\Desktop\\labgraph_monitor\\src\\reportWebVitals.js":"3","C:\\Users\\zenak\\Desktop\\labgraph_monitor\\src\\helper.js":"4"},{"size":302,"mtime":1637930999483,"results":"5","hashOfConfig":"6"},{"size":4847,"mtime":1639948355337,"results":"7","hashOfConfig":"6"},{"size":375,"mtime":1635088034926,"results":"8","hashOfConfig":"6"},{"size":2902,"mtime":1639948152535,"results":"9","hashOfConfig":"6"},{"filePath":"10","messages":"11","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},"kqapyo",{"filePath":"13","messages":"14","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"15"},{"filePath":"16","messages":"17","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},{"filePath":"18","messages":"19","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"20"},"C:\\Users\\zenak\\Desktop\\labgraph_monitor\\src\\index.js",[],["21","22"],"C:\\Users\\zenak\\Desktop\\labgraph_monitor\\src\\App.js",["23","24"],"import React, { useState, useEffect, useCallback} from 'react';\r\nimport { w3cwebsocket as W3CWebSocket } from \"websocket\";\r\nimport ReactFlow, { addEdge, MiniMap, Controls, Background, isNode} from 'react-flow-renderer';\r\nimport { dataToConnections, connectionsToNodes, dataToObjects } from './helper';\r\nimport './App.css';\r\nimport dagre from 'dagre';\r\n\r\n// sample connections array: {'NoiseGenerator': ['RollingAverager'], 'RollingAverager': ['AveragedNoise'], 'AveragedNoise': ['Plot']}\r\n\r\n// dagreGraph helps layout the nodes in the graph \r\nconst dagreGraph = new dagre.graphlib.Graph();\r\ndagreGraph.setDefaultEdgeLabel(() => ({}));\r\n\r\nconst nodeWidth = 172;\r\nconst nodeHeight = 36;\r\n\r\n// setting up the horizontal and vertical options to change the orientation \r\nconst getLayoutedElements = (elements, direction = 'TB') => {\r\n  const isHorizontal = direction === 'LR';\r\n  dagreGraph.setGraph({ rankdir: direction });\r\n\r\n  elements.forEach((el) => {\r\n    if (isNode(el)) {\r\n      dagreGraph.setNode(el.id, { width: nodeWidth, height: nodeHeight });\r\n    } else {\r\n      dagreGraph.setEdge(el.source, el.target);\r\n    }\r\n  });\r\n\r\n  dagre.layout(dagreGraph);\r\n\r\n  return elements.map((el) => {\r\n    if (isNode(el)) {\r\n      const nodeWithPosition = dagreGraph.node(el.id);\r\n      el.targetPosition = isHorizontal ? 'left' : 'top';\r\n      el.sourcePosition = isHorizontal ? 'right' : 'bottom';\r\n      el.position = {\r\n        x: nodeWithPosition.x - nodeWidth / 2 + Math.random() / 1000,\r\n        y: nodeWithPosition.y - nodeHeight / 2,\r\n      };\r\n    }\r\n\r\n    return el;\r\n  });\r\n};\r\n\r\nconst InteractionGraph = () => {\r\n  const [node_name, setName] = useState(\"None\");\r\n  const [connections, setConnections] = useState([]);\r\n  const [elements, setElements] = useState([]);\r\n  const [nodeObjects, setNodeObjects] = useState([]);\r\n  const [type, setType] = useState('None')\r\n\r\n  // getting the node that the user is clicking \r\n  const onElementClick = (event, element) => {\r\n    setName(element.id)\r\n    setType(nodeObjects[element.id].type)\r\n    console.log(\"node\", node_name)\r\n  };\r\n\r\n  // receiving the messages from server \r\n  useEffect(() => {\r\n    // connecting to the server \r\n    const client = new W3CWebSocket('ws://localhost:9000');\r\n\r\n    client.onopen = () => {\r\n      console.log('connected');\r\n      client.send(JSON.stringify({\r\n        \"api_version\": \"0.1\",\r\n        \"api_request\": {\r\n          \"request_id\": 1,\r\n          \"start_stream_request\": {\r\n            \"stream_id\": \"LABGRAPH.MONITOR\",\r\n             \"labgraph.monitor\": {\r\n             }\r\n          }\r\n        }\r\n     }))\r\n    };\r\n\r\n    client.onmessage = (message) => {\r\n      const dataFromServer = JSON.parse(message.data);\r\n      if (dataFromServer.stream_batch){\r\n        const dataArray = dataFromServer.stream_batch[\"labgraph.monitor\"].samples[0].data; // dataArray is the part of JSON data we are interested in\r\n        const connections = dataToConnections(dataArray); // generating the connections array \r\n        const elements = connectionsToNodes(connections); // changing the connections array to an elements array having the properties of nodes in reactflow\r\n        const layoutedElements = getLayoutedElements(elements); // using dagreGraph and the getLayoutedElements function defined earlier to layout the nodes\r\n        const nodeObjects = dataToObjects(dataArray); \r\n        setElements(layoutedElements);\r\n        setConnections(connections);\r\n        setNodeObjects(nodeObjects);\r\n        console.log(\"nodeObjects\", nodeObjects);\r\n        console.log(\"connection\", connections);\r\n        console.log(\"server message received \", dataArray)\r\n      }\r\n    };\r\n\r\n    return () => {\r\n      client.close();\r\n    }\r\n  }, []);\r\n\r\n  const onLayout = useCallback(\r\n    (direction) => {\r\n      const layoutedElements = getLayoutedElements(elements, direction);\r\n      setElements(layoutedElements);\r\n    },\r\n    [elements]\r\n  );\r\n\r\n  return(\r\n  <div>\r\n    <div className='table-div'> \r\n      <div className='annotations'></div>\r\n      <div className=\"controls\">\r\n          <button onClick={() => onLayout('TB')}>vertical layout</button>\r\n          <button onClick={() => onLayout('LR')}>horizontal layout</button>\r\n        </div>\r\n      <table>\r\n        <thead>\r\n          <tr>\r\n            <th>Node</th>\r\n            <th>Type</th>\r\n          </tr>\r\n        </thead>\r\n        <tbody>\r\n          <tr>\r\n            <td>{node_name}</td>\r\n            <td>{type}</td>\r\n          </tr>\r\n        </tbody>\r\n      </table>\r\n    </div>\r\n\r\n    <div style={{ height: 400 }}> \r\n    <ReactFlow \r\n    elements={elements}\r\n    onElementClick={onElementClick}\r\n    >\r\n      <MiniMap\r\n        nodeBorderRadius={2}\r\n      />\r\n      <Controls />\r\n      <Background color=\"#aaa\" gap={16} />\r\n    </ReactFlow>\r\n    </div>\r\n\r\n  </div>\r\n\r\n  \r\n  )\r\n};\r\n\r\nexport default InteractionGraph;","C:\\Users\\zenak\\Desktop\\labgraph_monitor\\src\\reportWebVitals.js",[],"C:\\Users\\zenak\\Desktop\\labgraph_monitor\\src\\helper.js",["25"],"/**\r\n * Converts the data from server to connections array\r\n * @param {Array} data - data received from server through websocket\r\n * @return {Array} An array having arrays of connections\r\n */\r\nfunction dataToConnections(data){\r\n    const connections = {}\r\n    for (const [a, b] of data) {\r\n        connections[Object.keys(a)[0]] = [\r\n            Object.keys(b)[0]\r\n        ]\r\n    }\r\n    return connections\r\n}\r\n\r\n/**\r\n * Converts the data from server to Objects array of the nodes\r\n * @param {Array} data - data received from server through websocket\r\n * @return {Array} An array having arrays of Objects representation of data from server. \r\n * Every object represents a node and has properties such as inputs, outputs, config.. for that node\r\n */\r\nfunction dataToObjects(data){\r\n    const connections = {}\r\n    for (const [a, b] of data) {\r\n        connections[Object.keys(a)[0]] = a[Object.keys(a)[0]]\r\n        connections[Object.keys(b)[0]] = b[Object.keys(b)[0]]\r\n    }\r\n    return connections\r\n}\r\n\r\n/**\r\n * Converts the data from server to connections array\r\n * @param {Array} connections - connections between nodes generated from server data\r\n * @return {Array} Elements array having Nodes for graph representation. A sample graph Node has id, data and position\r\n */\r\n function connectionsToNodes(connections){\r\n    connections['RollingAverager'].push('Node4', 'Node5', 'Node2')\r\n    connections['Node2'] = ['Node6', 'Node7']\r\n    const adjacencyListKeys = Object.keys(connections)\r\n    console.log(\"adjacency list keys\", adjacencyListKeys)\r\n    console.log(\"connections are\" , connections)\r\n    // adding all nodes of the graph without duplicates\r\n    const allNodes = Object.keys(connections)\r\n    for (let [, edgeNodes] of Object.entries(connections)) {\r\n        for (let n of edgeNodes) {\r\n            if (!allNodes.includes(n)) {\r\n            allNodes.push(n)\r\n            }\r\n        }\r\n    }\r\n    // generating the elements list having nodes with their properties\r\n    const elements = []\r\n    for (let node of allNodes) {\r\n        elements.push({\r\n            id: node,\r\n            data: { label: node },\r\n            position: 0,\r\n        })\r\n    }\r\n\r\n    const elements_index = {}\r\n\r\n    for (let i = 0; i < elements.length; i++) {\r\n        const node = elements[i].id\r\n        elements_index[node] = i\r\n    }\r\n\r\n    // generating the edges between every source and target node\r\n    for (let i = 0; i < adjacencyListKeys.length; i++) {\r\n        const node = adjacencyListKeys[i]\r\n        const edgeNodes = connections[node]\r\n        let j = -1\r\n        for (let edgeNode of edgeNodes) {\r\n            elements.push({ id: `e-${node}-${edgeNode}`, source: node, target: edgeNode, animated: true },)\r\n            j ++\r\n        }\r\n    }\r\n\r\n    console.log(elements)\r\n\r\n    return elements\r\n }\r\n\r\nmodule.exports = {\r\n    dataToConnections,\r\n    dataToObjects,\r\n    connectionsToNodes,\r\n}\r\n\r\n",{"ruleId":"26","replacedBy":"27"},{"ruleId":"28","replacedBy":"29"},{"ruleId":"30","severity":1,"message":"31","line":3,"column":21,"nodeType":"32","messageId":"33","endLine":3,"endColumn":28},{"ruleId":"30","severity":1,"message":"34","line":49,"column":10,"nodeType":"32","messageId":"33","endLine":49,"endColumn":21},{"ruleId":"30","severity":1,"message":"35","line":75,"column":13,"nodeType":"32","messageId":"33","endLine":75,"endColumn":14},"no-native-reassign",["36"],"no-negated-in-lhs",["37"],"no-unused-vars","'addEdge' is defined but never used.","Identifier","unusedVar","'connections' is assigned a value but never used.","'j' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]