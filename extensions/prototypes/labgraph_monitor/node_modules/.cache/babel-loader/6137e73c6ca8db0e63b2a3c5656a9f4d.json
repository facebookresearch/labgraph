{"ast":null,"code":"/**\r\n * Converts the data from server to connections array\r\n * @param {Array} data - data received from server through websocket\r\n * @return {Array} An array having arrays of connections\r\n */\nfunction dataToConnections(data) {\n  const connections = {};\n\n  for (const [a, b] of data) {\n    connections[Object.keys(a)[0]] = [Object.keys(b)[0]];\n  }\n\n  return connections;\n}\n/**\r\n * Converts the data from server to connections array\r\n * @param {Array} data - data received from server through websocket\r\n * @return {Array} An array having arrays of Objects representation of data from server\r\n */\n\n\nfunction dataToObjects(data) {\n  const connections = {};\n\n  for (const [a, b] of data) {\n    connections[Object.keys(a)[0]] = a[Object.keys(a)[0]];\n    connections[Object.keys(b)[0]] = b[Object.keys(b)[0]];\n  }\n\n  return connections;\n}\n/**\r\n * Converts the data from server to connections array\r\n * @param {Array} connections - connections between nodes generated from server data\r\n * @return {Array} Elements array having Nodes for graph representation. A sample graph Node has id, data and position\r\n */\n\n\nfunction connectionsToNodes(connections) {\n  const adjacencyListKeys = Object.keys(connections); // adding all nodes of the graph without duplicates\n\n  const allNodes = Object.keys(connections);\n\n  for (let [, edgeNodes] of Object.entries(connections)) {\n    for (let n of edgeNodes) {\n      if (!allNodes.includes(n)) {\n        allNodes.push(n);\n      }\n    }\n  } // generating the elements list having nodes with their properties\n\n\n  const elements = [];\n  let i = 0;\n\n  for (let node of allNodes) {\n    elements.push({\n      id: node,\n      data: {\n        label: node\n      },\n      position: {\n        x: 100 + 60 * i,\n        y: 125 + 60 * i\n      }\n    });\n    i++;\n  } // generating the edges between every source and target node\n\n\n  for (let i = 0; i < adjacencyListKeys.length; i++) {\n    const node = adjacencyListKeys[i];\n    const edgeNodes = connections[node];\n\n    for (let edgeNode of edgeNodes) {\n      elements.push({\n        id: `e-${node}-${edgeNode}`,\n        source: node,\n        target: edgeNode,\n        animated: true\n      });\n    }\n  }\n\n  return elements;\n}\n\nmodule.exports = {\n  dataToConnections,\n  dataToObjects,\n  connectionsToNodes\n};\ndata = [[{\n  \"SimulationGenerator\": {\n    \"type\": \"Node\",\n    \"config\": {\n      \"GeneratorConfig\": {\n        \"sample_rate\": \"float\",\n        \"num_features\": \"int\",\n        \"window\": \"float\"\n      }\n    },\n    \"inputs\": [],\n    \"outputs\": [{\n      \"SimulationMessage\": {\n        \"timestamp\": \"np.ndarray\",\n        \"daub_data\": \"np.ndarray\"\n      }\n    }]\n  },\n  \"Plot\": {\n    \"type\": \"Node\",\n    \"state\": \"PlotState\",\n    \"config\": \"PlotConfig\",\n    \"inputs\": [\"SimulationMessage\"],\n    \"outputs\": []\n  }\n}]];\nnode_name = 'SimulationGenerator';\nobjects = dataToObjects(data);\nconsole.log(objects[node_name].type);","map":{"version":3,"sources":["C:/Users/zenak/Desktop/labgraph_monitor/src/helper.js"],"names":["dataToConnections","data","connections","a","b","Object","keys","dataToObjects","connectionsToNodes","adjacencyListKeys","allNodes","edgeNodes","entries","n","includes","push","elements","i","node","id","label","position","x","y","length","edgeNode","source","target","animated","module","exports","node_name","objects","console","log","type"],"mappings":"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","sourcesContent":["/**\r\n * Converts the data from server to connections array\r\n * @param {Array} data - data received from server through websocket\r\n * @return {Array} An array having arrays of connections\r\n */\r\nfunction dataToConnections(data){\r\n    const connections = {}\r\n    for (const [a, b] of data) {\r\n        connections[Object.keys(a)[0]] = [\r\n            Object.keys(b)[0]\r\n        ]\r\n    }\r\n    return connections\r\n}\r\n\r\n/**\r\n * Converts the data from server to connections array\r\n * @param {Array} data - data received from server through websocket\r\n * @return {Array} An array having arrays of Objects representation of data from server\r\n */\r\nfunction dataToObjects(data){\r\n    const connections = {}\r\n    for (const [a, b] of data) {\r\n        connections[Object.keys(a)[0]] = a[Object.keys(a)[0]]\r\n        connections[Object.keys(b)[0]] = b[Object.keys(b)[0]]\r\n    }\r\n    return connections\r\n}\r\n\r\n/**\r\n * Converts the data from server to connections array\r\n * @param {Array} connections - connections between nodes generated from server data\r\n * @return {Array} Elements array having Nodes for graph representation. A sample graph Node has id, data and position\r\n */\r\n function connectionsToNodes(connections){\r\n    const adjacencyListKeys = Object.keys(connections)\r\n    // adding all nodes of the graph without duplicates\r\n    const allNodes = Object.keys(connections)\r\n    for (let [, edgeNodes] of Object.entries(connections)) {\r\n        for (let n of edgeNodes) {\r\n            if (!allNodes.includes(n)) {\r\n            allNodes.push(n)\r\n            }\r\n        }\r\n    }\r\n    // generating the elements list having nodes with their properties\r\n    const elements = []\r\n    let i = 0\r\n    for (let node of allNodes) {\r\n        elements.push({\r\n            id: node,\r\n            data: { label: node },\r\n            position: { x: 100 + 60 * i, y: 125 + 60 * i },\r\n        })\r\n        i++;\r\n    }\r\n    // generating the edges between every source and target node\r\n    for (let i = 0; i < adjacencyListKeys.length; i++) {\r\n        const node = adjacencyListKeys[i]\r\n        const edgeNodes = connections[node]\r\n        for (let edgeNode of edgeNodes) {\r\n            elements.push({ id: `e-${node}-${edgeNode}`, source: node, target: edgeNode, animated: true },)\r\n        }\r\n    }\r\n\r\n    return elements\r\n }\r\n\r\nmodule.exports = {\r\n    dataToConnections,\r\n    dataToObjects,\r\n    connectionsToNodes,\r\n}\r\n\r\ndata = [\r\n    [\r\n        {\r\n            \"SimulationGenerator\": {\r\n                \"type\": \"Node\",\r\n                \"config\": {\r\n                    \"GeneratorConfig\": {\r\n                        \"sample_rate\": \"float\",\r\n                        \"num_features\": \"int\",\r\n                        \"window\": \"float\"\r\n                    }\r\n                },\r\n                \"inputs\": [],\r\n                \"outputs\": [\r\n                    {\r\n                        \"SimulationMessage\": {\r\n                            \"timestamp\": \"np.ndarray\",\r\n                            \"daub_data\": \"np.ndarray\"\r\n                        }\r\n                    }\r\n                ]\r\n            },\r\n            \"Plot\": {\r\n                \"type\": \"Node\",\r\n                \"state\": \"PlotState\",\r\n                \"config\": \"PlotConfig\",\r\n                \"inputs\": [\r\n                    \"SimulationMessage\"\r\n                ],\r\n                \"outputs\": []\r\n            }\r\n        }\r\n    ]\r\n]\r\n\r\nnode_name = 'SimulationGenerator'\r\n\r\nobjects = dataToObjects(data)\r\n\r\nconsole.log(objects[node_name].type)\r\n"]},"metadata":{},"sourceType":"module"}