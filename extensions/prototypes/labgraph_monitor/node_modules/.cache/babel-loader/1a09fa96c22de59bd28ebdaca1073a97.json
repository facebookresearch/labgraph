{"ast":null,"code":"var _ = require(\"../lodash\");\n\nvar Graph = require(\"../graphlib\").Graph;\n\nmodule.exports = buildLayerGraph;\n/*\n * Constructs a graph that can be used to sort a layer of nodes. The graph will\n * contain all base and subgraph nodes from the request layer in their original\n * hierarchy and any edges that are incident on these nodes and are of the type\n * requested by the \"relationship\" parameter.\n *\n * Nodes from the requested rank that do not have parents are assigned a root\n * node in the output graph, which is set in the root graph attribute. This\n * makes it easy to walk the hierarchy of movable nodes during ordering.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG\n *    2. Base nodes in the input graph have a rank attribute\n *    3. Subgraph nodes in the input graph has minRank and maxRank attributes\n *    4. Edges have an assigned weight\n *\n * Post-conditions:\n *\n *    1. Output graph has all nodes in the movable rank with preserved\n *       hierarchy.\n *    2. Root nodes in the movable layer are made children of the node\n *       indicated by the root attribute of the graph.\n *    3. Non-movable nodes incident on movable nodes, selected by the\n *       relationship parameter, are included in the graph (without hierarchy).\n *    4. Edges incident on movable nodes, selected by the relationship\n *       parameter, are added to the output graph.\n *    5. The weights for copied edges are aggregated as need, since the output\n *       graph is not a multi-graph.\n */\n\nfunction buildLayerGraph(g, rank, relationship) {\n  var root = createRootNode(g),\n      result = new Graph({\n    compound: true\n  }).setGraph({\n    root: root\n  }).setDefaultNodeLabel(function (v) {\n    return g.node(v);\n  });\n\n  _.forEach(g.nodes(), function (v) {\n    var node = g.node(v),\n        parent = g.parent(v);\n\n    if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {\n      result.setNode(v);\n      result.setParent(v, parent || root); // This assumes we have only short edges!\n\n      _.forEach(g[relationship](v), function (e) {\n        var u = e.v === v ? e.w : e.v,\n            edge = result.edge(u, v),\n            weight = !_.isUndefined(edge) ? edge.weight : 0;\n        result.setEdge(u, v, {\n          weight: g.edge(e).weight + weight\n        });\n      });\n\n      if (_.has(node, \"minRank\")) {\n        result.setNode(v, {\n          borderLeft: node.borderLeft[rank],\n          borderRight: node.borderRight[rank]\n        });\n      }\n    }\n  });\n\n  return result;\n}\n\nfunction createRootNode(g) {\n  var v;\n\n  while (g.hasNode(v = _.uniqueId(\"_root\")));\n\n  return v;\n}","map":{"version":3,"sources":["C:/Users/zenak/Desktop/labgraph_monitor/node_modules/dagre/lib/order/build-layer-graph.js"],"names":["_","require","Graph","module","exports","buildLayerGraph","g","rank","relationship","root","createRootNode","result","compound","setGraph","setDefaultNodeLabel","v","node","forEach","nodes","parent","minRank","maxRank","setNode","setParent","e","u","w","edge","weight","isUndefined","setEdge","has","borderLeft","borderRight","hasNode","uniqueId"],"mappings":"AAAA,IAAIA,CAAC,GAAGC,OAAO,CAAC,WAAD,CAAf;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,aAAD,CAAP,CAAuBC,KAAnC;;AAEAC,MAAM,CAACC,OAAP,GAAiBC,eAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,eAAT,CAAyBC,CAAzB,EAA4BC,IAA5B,EAAkCC,YAAlC,EAAgD;AAC9C,MAAIC,IAAI,GAAGC,cAAc,CAACJ,CAAD,CAAzB;AAAA,MACEK,MAAM,GAAG,IAAIT,KAAJ,CAAU;AAAEU,IAAAA,QAAQ,EAAE;AAAZ,GAAV,EAA8BC,QAA9B,CAAuC;AAAEJ,IAAAA,IAAI,EAAEA;AAAR,GAAvC,EACNK,mBADM,CACc,UAASC,CAAT,EAAY;AAAE,WAAOT,CAAC,CAACU,IAAF,CAAOD,CAAP,CAAP;AAAmB,GAD/C,CADX;;AAIAf,EAAAA,CAAC,CAACiB,OAAF,CAAUX,CAAC,CAACY,KAAF,EAAV,EAAqB,UAASH,CAAT,EAAY;AAC/B,QAAIC,IAAI,GAAGV,CAAC,CAACU,IAAF,CAAOD,CAAP,CAAX;AAAA,QACEI,MAAM,GAAGb,CAAC,CAACa,MAAF,CAASJ,CAAT,CADX;;AAGA,QAAIC,IAAI,CAACT,IAAL,KAAcA,IAAd,IAAsBS,IAAI,CAACI,OAAL,IAAgBb,IAAhB,IAAwBA,IAAI,IAAIS,IAAI,CAACK,OAA/D,EAAwE;AACtEV,MAAAA,MAAM,CAACW,OAAP,CAAeP,CAAf;AACAJ,MAAAA,MAAM,CAACY,SAAP,CAAiBR,CAAjB,EAAoBI,MAAM,IAAIV,IAA9B,EAFsE,CAItE;;AACAT,MAAAA,CAAC,CAACiB,OAAF,CAAUX,CAAC,CAACE,YAAD,CAAD,CAAgBO,CAAhB,CAAV,EAA8B,UAASS,CAAT,EAAY;AACxC,YAAIC,CAAC,GAAGD,CAAC,CAACT,CAAF,KAAQA,CAAR,GAAYS,CAAC,CAACE,CAAd,GAAkBF,CAAC,CAACT,CAA5B;AAAA,YACEY,IAAI,GAAGhB,MAAM,CAACgB,IAAP,CAAYF,CAAZ,EAAeV,CAAf,CADT;AAAA,YAEEa,MAAM,GAAG,CAAC5B,CAAC,CAAC6B,WAAF,CAAcF,IAAd,CAAD,GAAuBA,IAAI,CAACC,MAA5B,GAAqC,CAFhD;AAGAjB,QAAAA,MAAM,CAACmB,OAAP,CAAeL,CAAf,EAAkBV,CAAlB,EAAqB;AAAEa,UAAAA,MAAM,EAAEtB,CAAC,CAACqB,IAAF,CAAOH,CAAP,EAAUI,MAAV,GAAmBA;AAA7B,SAArB;AACD,OALD;;AAOA,UAAI5B,CAAC,CAAC+B,GAAF,CAAMf,IAAN,EAAY,SAAZ,CAAJ,EAA4B;AAC1BL,QAAAA,MAAM,CAACW,OAAP,CAAeP,CAAf,EAAkB;AAChBiB,UAAAA,UAAU,EAAEhB,IAAI,CAACgB,UAAL,CAAgBzB,IAAhB,CADI;AAEhB0B,UAAAA,WAAW,EAAEjB,IAAI,CAACiB,WAAL,CAAiB1B,IAAjB;AAFG,SAAlB;AAID;AACF;AACF,GAvBD;;AAyBA,SAAOI,MAAP;AACD;;AAED,SAASD,cAAT,CAAwBJ,CAAxB,EAA2B;AACzB,MAAIS,CAAJ;;AACA,SAAOT,CAAC,CAAC4B,OAAF,CAAWnB,CAAC,GAAGf,CAAC,CAACmC,QAAF,CAAW,OAAX,CAAf,CAAP,CAA4C;;AAC5C,SAAOpB,CAAP;AACD","sourcesContent":["var _ = require(\"../lodash\");\nvar Graph = require(\"../graphlib\").Graph;\n\nmodule.exports = buildLayerGraph;\n\n/*\n * Constructs a graph that can be used to sort a layer of nodes. The graph will\n * contain all base and subgraph nodes from the request layer in their original\n * hierarchy and any edges that are incident on these nodes and are of the type\n * requested by the \"relationship\" parameter.\n *\n * Nodes from the requested rank that do not have parents are assigned a root\n * node in the output graph, which is set in the root graph attribute. This\n * makes it easy to walk the hierarchy of movable nodes during ordering.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG\n *    2. Base nodes in the input graph have a rank attribute\n *    3. Subgraph nodes in the input graph has minRank and maxRank attributes\n *    4. Edges have an assigned weight\n *\n * Post-conditions:\n *\n *    1. Output graph has all nodes in the movable rank with preserved\n *       hierarchy.\n *    2. Root nodes in the movable layer are made children of the node\n *       indicated by the root attribute of the graph.\n *    3. Non-movable nodes incident on movable nodes, selected by the\n *       relationship parameter, are included in the graph (without hierarchy).\n *    4. Edges incident on movable nodes, selected by the relationship\n *       parameter, are added to the output graph.\n *    5. The weights for copied edges are aggregated as need, since the output\n *       graph is not a multi-graph.\n */\nfunction buildLayerGraph(g, rank, relationship) {\n  var root = createRootNode(g),\n    result = new Graph({ compound: true }).setGraph({ root: root })\n      .setDefaultNodeLabel(function(v) { return g.node(v); });\n\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v),\n      parent = g.parent(v);\n\n    if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {\n      result.setNode(v);\n      result.setParent(v, parent || root);\n\n      // This assumes we have only short edges!\n      _.forEach(g[relationship](v), function(e) {\n        var u = e.v === v ? e.w : e.v,\n          edge = result.edge(u, v),\n          weight = !_.isUndefined(edge) ? edge.weight : 0;\n        result.setEdge(u, v, { weight: g.edge(e).weight + weight });\n      });\n\n      if (_.has(node, \"minRank\")) {\n        result.setNode(v, {\n          borderLeft: node.borderLeft[rank],\n          borderRight: node.borderRight[rank]\n        });\n      }\n    }\n  });\n\n  return result;\n}\n\nfunction createRootNode(g) {\n  var v;\n  while (g.hasNode((v = _.uniqueId(\"_root\"))));\n  return v;\n}\n"]},"metadata":{},"sourceType":"script"}