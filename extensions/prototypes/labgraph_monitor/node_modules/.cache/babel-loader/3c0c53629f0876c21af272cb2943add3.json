{"ast":null,"code":"var _ = require(\"../lodash\");\n\nmodule.exports = PriorityQueue;\n/**\n * A min-priority queue data structure. This algorithm is derived from Cormen,\n * et al., \"Introduction to Algorithms\". The basic idea of a min-priority\n * queue is that you can efficiently (in O(1) time) get the smallest key in\n * the queue. Adding and removing elements takes O(log n) time. A key can\n * have its priority decreased in O(log n) time.\n */\n\nfunction PriorityQueue() {\n  this._arr = [];\n  this._keyIndices = {};\n}\n/**\n * Returns the number of elements in the queue. Takes `O(1)` time.\n */\n\n\nPriorityQueue.prototype.size = function () {\n  return this._arr.length;\n};\n/**\n * Returns the keys that are in the queue. Takes `O(n)` time.\n */\n\n\nPriorityQueue.prototype.keys = function () {\n  return this._arr.map(function (x) {\n    return x.key;\n  });\n};\n/**\n * Returns `true` if **key** is in the queue and `false` if not.\n */\n\n\nPriorityQueue.prototype.has = function (key) {\n  return _.has(this._keyIndices, key);\n};\n/**\n * Returns the priority for **key**. If **key** is not present in the queue\n * then this function returns `undefined`. Takes `O(1)` time.\n *\n * @param {Object} key\n */\n\n\nPriorityQueue.prototype.priority = function (key) {\n  var index = this._keyIndices[key];\n\n  if (index !== undefined) {\n    return this._arr[index].priority;\n  }\n};\n/**\n * Returns the key for the minimum element in this queue. If the queue is\n * empty this function throws an Error. Takes `O(1)` time.\n */\n\n\nPriorityQueue.prototype.min = function () {\n  if (this.size() === 0) {\n    throw new Error(\"Queue underflow\");\n  }\n\n  return this._arr[0].key;\n};\n/**\n * Inserts a new key into the priority queue. If the key already exists in\n * the queue this function returns `false`; otherwise it will return `true`.\n * Takes `O(n)` time.\n *\n * @param {Object} key the key to add\n * @param {Number} priority the initial priority for the key\n */\n\n\nPriorityQueue.prototype.add = function (key, priority) {\n  var keyIndices = this._keyIndices;\n  key = String(key);\n\n  if (!_.has(keyIndices, key)) {\n    var arr = this._arr;\n    var index = arr.length;\n    keyIndices[key] = index;\n    arr.push({\n      key: key,\n      priority: priority\n    });\n\n    this._decrease(index);\n\n    return true;\n  }\n\n  return false;\n};\n/**\n * Removes and returns the smallest key in the queue. Takes `O(log n)` time.\n */\n\n\nPriorityQueue.prototype.removeMin = function () {\n  this._swap(0, this._arr.length - 1);\n\n  var min = this._arr.pop();\n\n  delete this._keyIndices[min.key];\n\n  this._heapify(0);\n\n  return min.key;\n};\n/**\n * Decreases the priority for **key** to **priority**. If the new priority is\n * greater than the previous priority, this function will throw an Error.\n *\n * @param {Object} key the key for which to raise priority\n * @param {Number} priority the new priority for the key\n */\n\n\nPriorityQueue.prototype.decrease = function (key, priority) {\n  var index = this._keyIndices[key];\n\n  if (priority > this._arr[index].priority) {\n    throw new Error(\"New priority is greater than current priority. \" + \"Key: \" + key + \" Old: \" + this._arr[index].priority + \" New: \" + priority);\n  }\n\n  this._arr[index].priority = priority;\n\n  this._decrease(index);\n};\n\nPriorityQueue.prototype._heapify = function (i) {\n  var arr = this._arr;\n  var l = 2 * i;\n  var r = l + 1;\n  var largest = i;\n\n  if (l < arr.length) {\n    largest = arr[l].priority < arr[largest].priority ? l : largest;\n\n    if (r < arr.length) {\n      largest = arr[r].priority < arr[largest].priority ? r : largest;\n    }\n\n    if (largest !== i) {\n      this._swap(i, largest);\n\n      this._heapify(largest);\n    }\n  }\n};\n\nPriorityQueue.prototype._decrease = function (index) {\n  var arr = this._arr;\n  var priority = arr[index].priority;\n  var parent;\n\n  while (index !== 0) {\n    parent = index >> 1;\n\n    if (arr[parent].priority < priority) {\n      break;\n    }\n\n    this._swap(index, parent);\n\n    index = parent;\n  }\n};\n\nPriorityQueue.prototype._swap = function (i, j) {\n  var arr = this._arr;\n  var keyIndices = this._keyIndices;\n  var origArrI = arr[i];\n  var origArrJ = arr[j];\n  arr[i] = origArrJ;\n  arr[j] = origArrI;\n  keyIndices[origArrJ.key] = i;\n  keyIndices[origArrI.key] = j;\n};","map":{"version":3,"sources":["C:/Users/zenak/Desktop/labgraph_monitor/node_modules/graphlib/lib/data/priority-queue.js"],"names":["_","require","module","exports","PriorityQueue","_arr","_keyIndices","prototype","size","length","keys","map","x","key","has","priority","index","undefined","min","Error","add","keyIndices","String","arr","push","_decrease","removeMin","_swap","pop","_heapify","decrease","i","l","r","largest","parent","j","origArrI","origArrJ"],"mappings":"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","sourcesContent":["var _ = require(\"../lodash\");\n\nmodule.exports = PriorityQueue;\n\n/**\n * A min-priority queue data structure. This algorithm is derived from Cormen,\n * et al., \"Introduction to Algorithms\". The basic idea of a min-priority\n * queue is that you can efficiently (in O(1) time) get the smallest key in\n * the queue. Adding and removing elements takes O(log n) time. A key can\n * have its priority decreased in O(log n) time.\n */\nfunction PriorityQueue() {\n  this._arr = [];\n  this._keyIndices = {};\n}\n\n/**\n * Returns the number of elements in the queue. Takes `O(1)` time.\n */\nPriorityQueue.prototype.size = function() {\n  return this._arr.length;\n};\n\n/**\n * Returns the keys that are in the queue. Takes `O(n)` time.\n */\nPriorityQueue.prototype.keys = function() {\n  return this._arr.map(function(x) { return x.key; });\n};\n\n/**\n * Returns `true` if **key** is in the queue and `false` if not.\n */\nPriorityQueue.prototype.has = function(key) {\n  return _.has(this._keyIndices, key);\n};\n\n/**\n * Returns the priority for **key**. If **key** is not present in the queue\n * then this function returns `undefined`. Takes `O(1)` time.\n *\n * @param {Object} key\n */\nPriorityQueue.prototype.priority = function(key) {\n  var index = this._keyIndices[key];\n  if (index !== undefined) {\n    return this._arr[index].priority;\n  }\n};\n\n/**\n * Returns the key for the minimum element in this queue. If the queue is\n * empty this function throws an Error. Takes `O(1)` time.\n */\nPriorityQueue.prototype.min = function() {\n  if (this.size() === 0) {\n    throw new Error(\"Queue underflow\");\n  }\n  return this._arr[0].key;\n};\n\n/**\n * Inserts a new key into the priority queue. If the key already exists in\n * the queue this function returns `false`; otherwise it will return `true`.\n * Takes `O(n)` time.\n *\n * @param {Object} key the key to add\n * @param {Number} priority the initial priority for the key\n */\nPriorityQueue.prototype.add = function(key, priority) {\n  var keyIndices = this._keyIndices;\n  key = String(key);\n  if (!_.has(keyIndices, key)) {\n    var arr = this._arr;\n    var index = arr.length;\n    keyIndices[key] = index;\n    arr.push({key: key, priority: priority});\n    this._decrease(index);\n    return true;\n  }\n  return false;\n};\n\n/**\n * Removes and returns the smallest key in the queue. Takes `O(log n)` time.\n */\nPriorityQueue.prototype.removeMin = function() {\n  this._swap(0, this._arr.length - 1);\n  var min = this._arr.pop();\n  delete this._keyIndices[min.key];\n  this._heapify(0);\n  return min.key;\n};\n\n/**\n * Decreases the priority for **key** to **priority**. If the new priority is\n * greater than the previous priority, this function will throw an Error.\n *\n * @param {Object} key the key for which to raise priority\n * @param {Number} priority the new priority for the key\n */\nPriorityQueue.prototype.decrease = function(key, priority) {\n  var index = this._keyIndices[key];\n  if (priority > this._arr[index].priority) {\n    throw new Error(\"New priority is greater than current priority. \" +\n        \"Key: \" + key + \" Old: \" + this._arr[index].priority + \" New: \" + priority);\n  }\n  this._arr[index].priority = priority;\n  this._decrease(index);\n};\n\nPriorityQueue.prototype._heapify = function(i) {\n  var arr = this._arr;\n  var l = 2 * i;\n  var r = l + 1;\n  var largest = i;\n  if (l < arr.length) {\n    largest = arr[l].priority < arr[largest].priority ? l : largest;\n    if (r < arr.length) {\n      largest = arr[r].priority < arr[largest].priority ? r : largest;\n    }\n    if (largest !== i) {\n      this._swap(i, largest);\n      this._heapify(largest);\n    }\n  }\n};\n\nPriorityQueue.prototype._decrease = function(index) {\n  var arr = this._arr;\n  var priority = arr[index].priority;\n  var parent;\n  while (index !== 0) {\n    parent = index >> 1;\n    if (arr[parent].priority < priority) {\n      break;\n    }\n    this._swap(index, parent);\n    index = parent;\n  }\n};\n\nPriorityQueue.prototype._swap = function(i, j) {\n  var arr = this._arr;\n  var keyIndices = this._keyIndices;\n  var origArrI = arr[i];\n  var origArrJ = arr[j];\n  arr[i] = origArrJ;\n  arr[j] = origArrI;\n  keyIndices[origArrJ.key] = i;\n  keyIndices[origArrI.key] = j;\n};\n"]},"metadata":{},"sourceType":"script"}