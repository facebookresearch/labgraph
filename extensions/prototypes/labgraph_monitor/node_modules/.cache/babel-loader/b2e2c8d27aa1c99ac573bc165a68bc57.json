{"ast":null,"code":"\"use strict\";\n\nvar _ = require(\"../lodash\");\n\nvar feasibleTree = require(\"./feasible-tree\");\n\nvar slack = require(\"./util\").slack;\n\nvar initRank = require(\"./util\").longestPath;\n\nvar preorder = require(\"../graphlib\").alg.preorder;\n\nvar postorder = require(\"../graphlib\").alg.postorder;\n\nvar simplify = require(\"../util\").simplify;\n\nmodule.exports = networkSimplex; // Expose some internals for testing purposes\n\nnetworkSimplex.initLowLimValues = initLowLimValues;\nnetworkSimplex.initCutValues = initCutValues;\nnetworkSimplex.calcCutValue = calcCutValue;\nnetworkSimplex.leaveEdge = leaveEdge;\nnetworkSimplex.enterEdge = enterEdge;\nnetworkSimplex.exchangeEdges = exchangeEdges;\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\n\nfunction networkSimplex(g) {\n  g = simplify(g);\n  initRank(g);\n  var t = feasibleTree(g);\n  initLowLimValues(t);\n  initCutValues(t, g);\n  var e, f;\n\n  while (e = leaveEdge(t)) {\n    f = enterEdge(t, g, e);\n    exchangeEdges(t, g, e, f);\n  }\n}\n/*\n * Initializes cut values for all edges in the tree.\n */\n\n\nfunction initCutValues(t, g) {\n  var vs = postorder(t, t.nodes());\n  vs = vs.slice(0, vs.length - 1);\n\n  _.forEach(vs, function (v) {\n    assignCutValue(t, g, v);\n  });\n}\n\nfunction assignCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);\n}\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\n\n\nfunction calcCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent; // True if the child is on the tail end of the edge in the directed graph\n\n  var childIsTail = true; // The graph's view of the tree edge we're inspecting\n\n  var graphEdge = g.edge(child, parent); // The accumulated cut value for the edge between this node and its parent\n\n  var cutValue = 0;\n\n  if (!graphEdge) {\n    childIsTail = false;\n    graphEdge = g.edge(parent, child);\n  }\n\n  cutValue = graphEdge.weight;\n\n  _.forEach(g.nodeEdges(child), function (e) {\n    var isOutEdge = e.v === child,\n        other = isOutEdge ? e.w : e.v;\n\n    if (other !== parent) {\n      var pointsToHead = isOutEdge === childIsTail,\n          otherWeight = g.edge(e).weight;\n      cutValue += pointsToHead ? otherWeight : -otherWeight;\n\n      if (isTreeEdge(t, child, other)) {\n        var otherCutValue = t.edge(child, other).cutvalue;\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue;\n      }\n    }\n  });\n\n  return cutValue;\n}\n\nfunction initLowLimValues(tree, root) {\n  if (arguments.length < 2) {\n    root = tree.nodes()[0];\n  }\n\n  dfsAssignLowLim(tree, {}, 1, root);\n}\n\nfunction dfsAssignLowLim(tree, visited, nextLim, v, parent) {\n  var low = nextLim;\n  var label = tree.node(v);\n  visited[v] = true;\n\n  _.forEach(tree.neighbors(v), function (w) {\n    if (!_.has(visited, w)) {\n      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);\n    }\n  });\n\n  label.low = low;\n  label.lim = nextLim++;\n\n  if (parent) {\n    label.parent = parent;\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent;\n  }\n\n  return nextLim;\n}\n\nfunction leaveEdge(tree) {\n  return _.find(tree.edges(), function (e) {\n    return tree.edge(e).cutvalue < 0;\n  });\n}\n\nfunction enterEdge(t, g, edge) {\n  var v = edge.v;\n  var w = edge.w; // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n\n  if (!g.hasEdge(v, w)) {\n    v = edge.w;\n    w = edge.v;\n  }\n\n  var vLabel = t.node(v);\n  var wLabel = t.node(w);\n  var tailLabel = vLabel;\n  var flip = false; // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n\n  if (vLabel.lim > wLabel.lim) {\n    tailLabel = wLabel;\n    flip = true;\n  }\n\n  var candidates = _.filter(g.edges(), function (edge) {\n    return flip === isDescendant(t, t.node(edge.v), tailLabel) && flip !== isDescendant(t, t.node(edge.w), tailLabel);\n  });\n\n  return _.minBy(candidates, function (edge) {\n    return slack(g, edge);\n  });\n}\n\nfunction exchangeEdges(t, g, e, f) {\n  var v = e.v;\n  var w = e.w;\n  t.removeEdge(v, w);\n  t.setEdge(f.v, f.w, {});\n  initLowLimValues(t);\n  initCutValues(t, g);\n  updateRanks(t, g);\n}\n\nfunction updateRanks(t, g) {\n  var root = _.find(t.nodes(), function (v) {\n    return !g.node(v).parent;\n  });\n\n  var vs = preorder(t, root);\n  vs = vs.slice(1);\n\n  _.forEach(vs, function (v) {\n    var parent = t.node(v).parent,\n        edge = g.edge(v, parent),\n        flipped = false;\n\n    if (!edge) {\n      edge = g.edge(parent, v);\n      flipped = true;\n    }\n\n    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);\n  });\n}\n/*\n * Returns true if the edge is in the tree.\n */\n\n\nfunction isTreeEdge(tree, u, v) {\n  return tree.hasEdge(u, v);\n}\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\n\n\nfunction isDescendant(tree, vLabel, rootLabel) {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;\n}","map":{"version":3,"sources":["C:/Users/zenak/Desktop/labgraph_monitor/node_modules/dagre/lib/rank/network-simplex.js"],"names":["_","require","feasibleTree","slack","initRank","longestPath","preorder","alg","postorder","simplify","module","exports","networkSimplex","initLowLimValues","initCutValues","calcCutValue","leaveEdge","enterEdge","exchangeEdges","g","t","e","f","vs","nodes","slice","length","forEach","v","assignCutValue","child","childLab","node","parent","edge","cutvalue","childIsTail","graphEdge","cutValue","weight","nodeEdges","isOutEdge","other","w","pointsToHead","otherWeight","isTreeEdge","otherCutValue","tree","root","arguments","dfsAssignLowLim","visited","nextLim","low","label","neighbors","has","lim","find","edges","hasEdge","vLabel","wLabel","tailLabel","flip","candidates","filter","isDescendant","minBy","removeEdge","setEdge","updateRanks","flipped","rank","minlen","u","rootLabel"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _ = require(\"../lodash\");\nvar feasibleTree = require(\"./feasible-tree\");\nvar slack = require(\"./util\").slack;\nvar initRank = require(\"./util\").longestPath;\nvar preorder = require(\"../graphlib\").alg.preorder;\nvar postorder = require(\"../graphlib\").alg.postorder;\nvar simplify = require(\"../util\").simplify;\n\nmodule.exports = networkSimplex;\n\n// Expose some internals for testing purposes\nnetworkSimplex.initLowLimValues = initLowLimValues;\nnetworkSimplex.initCutValues = initCutValues;\nnetworkSimplex.calcCutValue = calcCutValue;\nnetworkSimplex.leaveEdge = leaveEdge;\nnetworkSimplex.enterEdge = enterEdge;\nnetworkSimplex.exchangeEdges = exchangeEdges;\n\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\nfunction networkSimplex(g) {\n  g = simplify(g);\n  initRank(g);\n  var t = feasibleTree(g);\n  initLowLimValues(t);\n  initCutValues(t, g);\n\n  var e, f;\n  while ((e = leaveEdge(t))) {\n    f = enterEdge(t, g, e);\n    exchangeEdges(t, g, e, f);\n  }\n}\n\n/*\n * Initializes cut values for all edges in the tree.\n */\nfunction initCutValues(t, g) {\n  var vs = postorder(t, t.nodes());\n  vs = vs.slice(0, vs.length - 1);\n  _.forEach(vs, function(v) {\n    assignCutValue(t, g, v);\n  });\n}\n\nfunction assignCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);\n}\n\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\nfunction calcCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  // True if the child is on the tail end of the edge in the directed graph\n  var childIsTail = true;\n  // The graph's view of the tree edge we're inspecting\n  var graphEdge = g.edge(child, parent);\n  // The accumulated cut value for the edge between this node and its parent\n  var cutValue = 0;\n\n  if (!graphEdge) {\n    childIsTail = false;\n    graphEdge = g.edge(parent, child);\n  }\n\n  cutValue = graphEdge.weight;\n\n  _.forEach(g.nodeEdges(child), function(e) {\n    var isOutEdge = e.v === child,\n      other = isOutEdge ? e.w : e.v;\n\n    if (other !== parent) {\n      var pointsToHead = isOutEdge === childIsTail,\n        otherWeight = g.edge(e).weight;\n\n      cutValue += pointsToHead ? otherWeight : -otherWeight;\n      if (isTreeEdge(t, child, other)) {\n        var otherCutValue = t.edge(child, other).cutvalue;\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue;\n      }\n    }\n  });\n\n  return cutValue;\n}\n\nfunction initLowLimValues(tree, root) {\n  if (arguments.length < 2) {\n    root = tree.nodes()[0];\n  }\n  dfsAssignLowLim(tree, {}, 1, root);\n}\n\nfunction dfsAssignLowLim(tree, visited, nextLim, v, parent) {\n  var low = nextLim;\n  var label = tree.node(v);\n\n  visited[v] = true;\n  _.forEach(tree.neighbors(v), function(w) {\n    if (!_.has(visited, w)) {\n      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);\n    }\n  });\n\n  label.low = low;\n  label.lim = nextLim++;\n  if (parent) {\n    label.parent = parent;\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent;\n  }\n\n  return nextLim;\n}\n\nfunction leaveEdge(tree) {\n  return _.find(tree.edges(), function(e) {\n    return tree.edge(e).cutvalue < 0;\n  });\n}\n\nfunction enterEdge(t, g, edge) {\n  var v = edge.v;\n  var w = edge.w;\n\n  // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n  if (!g.hasEdge(v, w)) {\n    v = edge.w;\n    w = edge.v;\n  }\n\n  var vLabel = t.node(v);\n  var wLabel = t.node(w);\n  var tailLabel = vLabel;\n  var flip = false;\n\n  // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n  if (vLabel.lim > wLabel.lim) {\n    tailLabel = wLabel;\n    flip = true;\n  }\n\n  var candidates = _.filter(g.edges(), function(edge) {\n    return flip === isDescendant(t, t.node(edge.v), tailLabel) &&\n           flip !== isDescendant(t, t.node(edge.w), tailLabel);\n  });\n\n  return _.minBy(candidates, function(edge) { return slack(g, edge); });\n}\n\nfunction exchangeEdges(t, g, e, f) {\n  var v = e.v;\n  var w = e.w;\n  t.removeEdge(v, w);\n  t.setEdge(f.v, f.w, {});\n  initLowLimValues(t);\n  initCutValues(t, g);\n  updateRanks(t, g);\n}\n\nfunction updateRanks(t, g) {\n  var root = _.find(t.nodes(), function(v) { return !g.node(v).parent; });\n  var vs = preorder(t, root);\n  vs = vs.slice(1);\n  _.forEach(vs, function(v) {\n    var parent = t.node(v).parent,\n      edge = g.edge(v, parent),\n      flipped = false;\n\n    if (!edge) {\n      edge = g.edge(parent, v);\n      flipped = true;\n    }\n\n    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);\n  });\n}\n\n/*\n * Returns true if the edge is in the tree.\n */\nfunction isTreeEdge(tree, u, v) {\n  return tree.hasEdge(u, v);\n}\n\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\nfunction isDescendant(tree, vLabel, rootLabel) {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;\n}\n"]},"metadata":{},"sourceType":"script"}