{"ast":null,"code":"var _ = require(\"./lodash\");\n\nvar Graph = require(\"./graphlib\").Graph;\n\nvar List = require(\"./data/list\");\n/*\n * A greedy heuristic for finding a feedback arc set for a graph. A feedback\n * arc set is a set of edges that can be removed to make a graph acyclic.\n * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, \"A fast and\n * effective heuristic for the feedback arc set problem.\" This implementation\n * adjusts that from the paper to allow for weighted edges.\n */\n\n\nmodule.exports = greedyFAS;\n\nvar DEFAULT_WEIGHT_FN = _.constant(1);\n\nfunction greedyFAS(g, weightFn) {\n  if (g.nodeCount() <= 1) {\n    return [];\n  }\n\n  var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);\n  var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx); // Expand multi-edges\n\n  return _.flatten(_.map(results, function (e) {\n    return g.outEdges(e.v, e.w);\n  }), true);\n}\n\nfunction doGreedyFAS(g, buckets, zeroIdx) {\n  var results = [];\n  var sources = buckets[buckets.length - 1];\n  var sinks = buckets[0];\n  var entry;\n\n  while (g.nodeCount()) {\n    while (entry = sinks.dequeue()) {\n      removeNode(g, buckets, zeroIdx, entry);\n    }\n\n    while (entry = sources.dequeue()) {\n      removeNode(g, buckets, zeroIdx, entry);\n    }\n\n    if (g.nodeCount()) {\n      for (var i = buckets.length - 2; i > 0; --i) {\n        entry = buckets[i].dequeue();\n\n        if (entry) {\n          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));\n          break;\n        }\n      }\n    }\n  }\n\n  return results;\n}\n\nfunction removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {\n  var results = collectPredecessors ? [] : undefined;\n\n  _.forEach(g.inEdges(entry.v), function (edge) {\n    var weight = g.edge(edge);\n    var uEntry = g.node(edge.v);\n\n    if (collectPredecessors) {\n      results.push({\n        v: edge.v,\n        w: edge.w\n      });\n    }\n\n    uEntry.out -= weight;\n    assignBucket(buckets, zeroIdx, uEntry);\n  });\n\n  _.forEach(g.outEdges(entry.v), function (edge) {\n    var weight = g.edge(edge);\n    var w = edge.w;\n    var wEntry = g.node(w);\n    wEntry[\"in\"] -= weight;\n    assignBucket(buckets, zeroIdx, wEntry);\n  });\n\n  g.removeNode(entry.v);\n  return results;\n}\n\nfunction buildState(g, weightFn) {\n  var fasGraph = new Graph();\n  var maxIn = 0;\n  var maxOut = 0;\n\n  _.forEach(g.nodes(), function (v) {\n    fasGraph.setNode(v, {\n      v: v,\n      \"in\": 0,\n      out: 0\n    });\n  }); // Aggregate weights on nodes, but also sum the weights across multi-edges\n  // into a single edge for the fasGraph.\n\n\n  _.forEach(g.edges(), function (e) {\n    var prevWeight = fasGraph.edge(e.v, e.w) || 0;\n    var weight = weightFn(e);\n    var edgeWeight = prevWeight + weight;\n    fasGraph.setEdge(e.v, e.w, edgeWeight);\n    maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);\n    maxIn = Math.max(maxIn, fasGraph.node(e.w)[\"in\"] += weight);\n  });\n\n  var buckets = _.range(maxOut + maxIn + 3).map(function () {\n    return new List();\n  });\n\n  var zeroIdx = maxIn + 1;\n\n  _.forEach(fasGraph.nodes(), function (v) {\n    assignBucket(buckets, zeroIdx, fasGraph.node(v));\n  });\n\n  return {\n    graph: fasGraph,\n    buckets: buckets,\n    zeroIdx: zeroIdx\n  };\n}\n\nfunction assignBucket(buckets, zeroIdx, entry) {\n  if (!entry.out) {\n    buckets[0].enqueue(entry);\n  } else if (!entry[\"in\"]) {\n    buckets[buckets.length - 1].enqueue(entry);\n  } else {\n    buckets[entry.out - entry[\"in\"] + zeroIdx].enqueue(entry);\n  }\n}","map":{"version":3,"sources":["C:/Users/zenak/Desktop/labgraph_monitor/node_modules/dagre/lib/greedy-fas.js"],"names":["_","require","Graph","List","module","exports","greedyFAS","DEFAULT_WEIGHT_FN","constant","g","weightFn","nodeCount","state","buildState","results","doGreedyFAS","graph","buckets","zeroIdx","flatten","map","e","outEdges","v","w","sources","length","sinks","entry","dequeue","removeNode","i","concat","collectPredecessors","undefined","forEach","inEdges","edge","weight","uEntry","node","push","out","assignBucket","wEntry","fasGraph","maxIn","maxOut","nodes","setNode","edges","prevWeight","edgeWeight","setEdge","Math","max","range","enqueue"],"mappings":"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","sourcesContent":["var _ = require(\"./lodash\");\nvar Graph = require(\"./graphlib\").Graph;\nvar List = require(\"./data/list\");\n\n/*\n * A greedy heuristic for finding a feedback arc set for a graph. A feedback\n * arc set is a set of edges that can be removed to make a graph acyclic.\n * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, \"A fast and\n * effective heuristic for the feedback arc set problem.\" This implementation\n * adjusts that from the paper to allow for weighted edges.\n */\nmodule.exports = greedyFAS;\n\nvar DEFAULT_WEIGHT_FN = _.constant(1);\n\nfunction greedyFAS(g, weightFn) {\n  if (g.nodeCount() <= 1) {\n    return [];\n  }\n  var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);\n  var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);\n\n  // Expand multi-edges\n  return _.flatten(_.map(results, function(e) {\n    return g.outEdges(e.v, e.w);\n  }), true);\n}\n\nfunction doGreedyFAS(g, buckets, zeroIdx) {\n  var results = [];\n  var sources = buckets[buckets.length - 1];\n  var sinks = buckets[0];\n\n  var entry;\n  while (g.nodeCount()) {\n    while ((entry = sinks.dequeue()))   { removeNode(g, buckets, zeroIdx, entry); }\n    while ((entry = sources.dequeue())) { removeNode(g, buckets, zeroIdx, entry); }\n    if (g.nodeCount()) {\n      for (var i = buckets.length - 2; i > 0; --i) {\n        entry = buckets[i].dequeue();\n        if (entry) {\n          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));\n          break;\n        }\n      }\n    }\n  }\n\n  return results;\n}\n\nfunction removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {\n  var results = collectPredecessors ? [] : undefined;\n\n  _.forEach(g.inEdges(entry.v), function(edge) {\n    var weight = g.edge(edge);\n    var uEntry = g.node(edge.v);\n\n    if (collectPredecessors) {\n      results.push({ v: edge.v, w: edge.w });\n    }\n\n    uEntry.out -= weight;\n    assignBucket(buckets, zeroIdx, uEntry);\n  });\n\n  _.forEach(g.outEdges(entry.v), function(edge) {\n    var weight = g.edge(edge);\n    var w = edge.w;\n    var wEntry = g.node(w);\n    wEntry[\"in\"] -= weight;\n    assignBucket(buckets, zeroIdx, wEntry);\n  });\n\n  g.removeNode(entry.v);\n\n  return results;\n}\n\nfunction buildState(g, weightFn) {\n  var fasGraph = new Graph();\n  var maxIn = 0;\n  var maxOut = 0;\n\n  _.forEach(g.nodes(), function(v) {\n    fasGraph.setNode(v, { v: v, \"in\": 0, out: 0 });\n  });\n\n  // Aggregate weights on nodes, but also sum the weights across multi-edges\n  // into a single edge for the fasGraph.\n  _.forEach(g.edges(), function(e) {\n    var prevWeight = fasGraph.edge(e.v, e.w) || 0;\n    var weight = weightFn(e);\n    var edgeWeight = prevWeight + weight;\n    fasGraph.setEdge(e.v, e.w, edgeWeight);\n    maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);\n    maxIn  = Math.max(maxIn,  fasGraph.node(e.w)[\"in\"]  += weight);\n  });\n\n  var buckets = _.range(maxOut + maxIn + 3).map(function() { return new List(); });\n  var zeroIdx = maxIn + 1;\n\n  _.forEach(fasGraph.nodes(), function(v) {\n    assignBucket(buckets, zeroIdx, fasGraph.node(v));\n  });\n\n  return { graph: fasGraph, buckets: buckets, zeroIdx: zeroIdx };\n}\n\nfunction assignBucket(buckets, zeroIdx, entry) {\n  if (!entry.out) {\n    buckets[0].enqueue(entry);\n  } else if (!entry[\"in\"]) {\n    buckets[buckets.length - 1].enqueue(entry);\n  } else {\n    buckets[entry.out - entry[\"in\"] + zeroIdx].enqueue(entry);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}