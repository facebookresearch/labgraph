{"ast":null,"code":"\"use strict\";\n\nvar _ = require(\"./lodash\");\n\nvar util = require(\"./util\");\n\nmodule.exports = {\n  run: run,\n  undo: undo\n};\n/*\n * Breaks any long edges in the graph into short segments that span 1 layer\n * each. This operation is undoable with the denormalize function.\n *\n * Pre-conditions:\n *\n *    1. The input graph is a DAG.\n *    2. Each node in the graph has a \"rank\" property.\n *\n * Post-condition:\n *\n *    1. All edges in the graph have a length of 1.\n *    2. Dummy nodes are added where edges have been split into segments.\n *    3. The graph is augmented with a \"dummyChains\" attribute which contains\n *       the first dummy in each chain of dummy nodes produced.\n */\n\nfunction run(g) {\n  g.graph().dummyChains = [];\n\n  _.forEach(g.edges(), function (edge) {\n    normalizeEdge(g, edge);\n  });\n}\n\nfunction normalizeEdge(g, e) {\n  var v = e.v;\n  var vRank = g.node(v).rank;\n  var w = e.w;\n  var wRank = g.node(w).rank;\n  var name = e.name;\n  var edgeLabel = g.edge(e);\n  var labelRank = edgeLabel.labelRank;\n  if (wRank === vRank + 1) return;\n  g.removeEdge(e);\n  var dummy, attrs, i;\n\n  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {\n    edgeLabel.points = [];\n    attrs = {\n      width: 0,\n      height: 0,\n      edgeLabel: edgeLabel,\n      edgeObj: e,\n      rank: vRank\n    };\n    dummy = util.addDummyNode(g, \"edge\", attrs, \"_d\");\n\n    if (vRank === labelRank) {\n      attrs.width = edgeLabel.width;\n      attrs.height = edgeLabel.height;\n      attrs.dummy = \"edge-label\";\n      attrs.labelpos = edgeLabel.labelpos;\n    }\n\n    g.setEdge(v, dummy, {\n      weight: edgeLabel.weight\n    }, name);\n\n    if (i === 0) {\n      g.graph().dummyChains.push(dummy);\n    }\n\n    v = dummy;\n  }\n\n  g.setEdge(v, w, {\n    weight: edgeLabel.weight\n  }, name);\n}\n\nfunction undo(g) {\n  _.forEach(g.graph().dummyChains, function (v) {\n    var node = g.node(v);\n    var origLabel = node.edgeLabel;\n    var w;\n    g.setEdge(node.edgeObj, origLabel);\n\n    while (node.dummy) {\n      w = g.successors(v)[0];\n      g.removeNode(v);\n      origLabel.points.push({\n        x: node.x,\n        y: node.y\n      });\n\n      if (node.dummy === \"edge-label\") {\n        origLabel.x = node.x;\n        origLabel.y = node.y;\n        origLabel.width = node.width;\n        origLabel.height = node.height;\n      }\n\n      v = w;\n      node = g.node(v);\n    }\n  });\n}","map":{"version":3,"sources":["C:/Users/zenak/Desktop/labgraph_monitor/node_modules/dagre/lib/normalize.js"],"names":["_","require","util","module","exports","run","undo","g","graph","dummyChains","forEach","edges","edge","normalizeEdge","e","v","vRank","node","rank","w","wRank","name","edgeLabel","labelRank","removeEdge","dummy","attrs","i","points","width","height","edgeObj","addDummyNode","labelpos","setEdge","weight","push","origLabel","successors","removeNode","x","y"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _ = require(\"./lodash\");\nvar util = require(\"./util\");\n\nmodule.exports = {\n  run: run,\n  undo: undo\n};\n\n/*\n * Breaks any long edges in the graph into short segments that span 1 layer\n * each. This operation is undoable with the denormalize function.\n *\n * Pre-conditions:\n *\n *    1. The input graph is a DAG.\n *    2. Each node in the graph has a \"rank\" property.\n *\n * Post-condition:\n *\n *    1. All edges in the graph have a length of 1.\n *    2. Dummy nodes are added where edges have been split into segments.\n *    3. The graph is augmented with a \"dummyChains\" attribute which contains\n *       the first dummy in each chain of dummy nodes produced.\n */\nfunction run(g) {\n  g.graph().dummyChains = [];\n  _.forEach(g.edges(), function(edge) { normalizeEdge(g, edge); });\n}\n\nfunction normalizeEdge(g, e) {\n  var v = e.v;\n  var vRank = g.node(v).rank;\n  var w = e.w;\n  var wRank = g.node(w).rank;\n  var name = e.name;\n  var edgeLabel = g.edge(e);\n  var labelRank = edgeLabel.labelRank;\n\n  if (wRank === vRank + 1) return;\n\n  g.removeEdge(e);\n\n  var dummy, attrs, i;\n  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {\n    edgeLabel.points = [];\n    attrs = {\n      width: 0, height: 0,\n      edgeLabel: edgeLabel, edgeObj: e,\n      rank: vRank\n    };\n    dummy = util.addDummyNode(g, \"edge\", attrs, \"_d\");\n    if (vRank === labelRank) {\n      attrs.width = edgeLabel.width;\n      attrs.height = edgeLabel.height;\n      attrs.dummy = \"edge-label\";\n      attrs.labelpos = edgeLabel.labelpos;\n    }\n    g.setEdge(v, dummy, { weight: edgeLabel.weight }, name);\n    if (i === 0) {\n      g.graph().dummyChains.push(dummy);\n    }\n    v = dummy;\n  }\n\n  g.setEdge(v, w, { weight: edgeLabel.weight }, name);\n}\n\nfunction undo(g) {\n  _.forEach(g.graph().dummyChains, function(v) {\n    var node = g.node(v);\n    var origLabel = node.edgeLabel;\n    var w;\n    g.setEdge(node.edgeObj, origLabel);\n    while (node.dummy) {\n      w = g.successors(v)[0];\n      g.removeNode(v);\n      origLabel.points.push({ x: node.x, y: node.y });\n      if (node.dummy === \"edge-label\") {\n        origLabel.x = node.x;\n        origLabel.y = node.y;\n        origLabel.width = node.width;\n        origLabel.height = node.height;\n      }\n      v = w;\n      node = g.node(v);\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"script"}