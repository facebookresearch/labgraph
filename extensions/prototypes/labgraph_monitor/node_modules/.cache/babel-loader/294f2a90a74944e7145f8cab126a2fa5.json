{"ast":null,"code":"\"use strict\";\n\nvar _ = require(\"../lodash\");\n\nmodule.exports = resolveConflicts;\n/*\n * Given a list of entries of the form {v, barycenter, weight} and a\n * constraint graph this function will resolve any conflicts between the\n * constraint graph and the barycenters for the entries. If the barycenters for\n * an entry would violate a constraint in the constraint graph then we coalesce\n * the nodes in the conflict into a new node that respects the contraint and\n * aggregates barycenter and weight information.\n *\n * This implementation is based on the description in Forster, \"A Fast and\n * Simple Hueristic for Constrained Two-Level Crossing Reduction,\" thought it\n * differs in some specific details.\n *\n * Pre-conditions:\n *\n *    1. Each entry has the form {v, barycenter, weight}, or if the node has\n *       no barycenter, then {v}.\n *\n * Returns:\n *\n *    A new list of entries of the form {vs, i, barycenter, weight}. The list\n *    `vs` may either be a singleton or it may be an aggregation of nodes\n *    ordered such that they do not violate constraints from the constraint\n *    graph. The property `i` is the lowest original index of any of the\n *    elements in `vs`.\n */\n\nfunction resolveConflicts(entries, cg) {\n  var mappedEntries = {};\n\n  _.forEach(entries, function (entry, i) {\n    var tmp = mappedEntries[entry.v] = {\n      indegree: 0,\n      \"in\": [],\n      out: [],\n      vs: [entry.v],\n      i: i\n    };\n\n    if (!_.isUndefined(entry.barycenter)) {\n      tmp.barycenter = entry.barycenter;\n      tmp.weight = entry.weight;\n    }\n  });\n\n  _.forEach(cg.edges(), function (e) {\n    var entryV = mappedEntries[e.v];\n    var entryW = mappedEntries[e.w];\n\n    if (!_.isUndefined(entryV) && !_.isUndefined(entryW)) {\n      entryW.indegree++;\n      entryV.out.push(mappedEntries[e.w]);\n    }\n  });\n\n  var sourceSet = _.filter(mappedEntries, function (entry) {\n    return !entry.indegree;\n  });\n\n  return doResolveConflicts(sourceSet);\n}\n\nfunction doResolveConflicts(sourceSet) {\n  var entries = [];\n\n  function handleIn(vEntry) {\n    return function (uEntry) {\n      if (uEntry.merged) {\n        return;\n      }\n\n      if (_.isUndefined(uEntry.barycenter) || _.isUndefined(vEntry.barycenter) || uEntry.barycenter >= vEntry.barycenter) {\n        mergeEntries(vEntry, uEntry);\n      }\n    };\n  }\n\n  function handleOut(vEntry) {\n    return function (wEntry) {\n      wEntry[\"in\"].push(vEntry);\n\n      if (--wEntry.indegree === 0) {\n        sourceSet.push(wEntry);\n      }\n    };\n  }\n\n  while (sourceSet.length) {\n    var entry = sourceSet.pop();\n    entries.push(entry);\n\n    _.forEach(entry[\"in\"].reverse(), handleIn(entry));\n\n    _.forEach(entry.out, handleOut(entry));\n  }\n\n  return _.map(_.filter(entries, function (entry) {\n    return !entry.merged;\n  }), function (entry) {\n    return _.pick(entry, [\"vs\", \"i\", \"barycenter\", \"weight\"]);\n  });\n}\n\nfunction mergeEntries(target, source) {\n  var sum = 0;\n  var weight = 0;\n\n  if (target.weight) {\n    sum += target.barycenter * target.weight;\n    weight += target.weight;\n  }\n\n  if (source.weight) {\n    sum += source.barycenter * source.weight;\n    weight += source.weight;\n  }\n\n  target.vs = source.vs.concat(target.vs);\n  target.barycenter = sum / weight;\n  target.weight = weight;\n  target.i = Math.min(source.i, target.i);\n  source.merged = true;\n}","map":{"version":3,"sources":["C:/Users/zenak/Desktop/labgraph_monitor/node_modules/dagre/lib/order/resolve-conflicts.js"],"names":["_","require","module","exports","resolveConflicts","entries","cg","mappedEntries","forEach","entry","i","tmp","v","indegree","out","vs","isUndefined","barycenter","weight","edges","e","entryV","entryW","w","push","sourceSet","filter","doResolveConflicts","handleIn","vEntry","uEntry","merged","mergeEntries","handleOut","wEntry","length","pop","reverse","map","pick","target","source","sum","concat","Math","min"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _ = require(\"../lodash\");\n\nmodule.exports = resolveConflicts;\n\n/*\n * Given a list of entries of the form {v, barycenter, weight} and a\n * constraint graph this function will resolve any conflicts between the\n * constraint graph and the barycenters for the entries. If the barycenters for\n * an entry would violate a constraint in the constraint graph then we coalesce\n * the nodes in the conflict into a new node that respects the contraint and\n * aggregates barycenter and weight information.\n *\n * This implementation is based on the description in Forster, \"A Fast and\n * Simple Hueristic for Constrained Two-Level Crossing Reduction,\" thought it\n * differs in some specific details.\n *\n * Pre-conditions:\n *\n *    1. Each entry has the form {v, barycenter, weight}, or if the node has\n *       no barycenter, then {v}.\n *\n * Returns:\n *\n *    A new list of entries of the form {vs, i, barycenter, weight}. The list\n *    `vs` may either be a singleton or it may be an aggregation of nodes\n *    ordered such that they do not violate constraints from the constraint\n *    graph. The property `i` is the lowest original index of any of the\n *    elements in `vs`.\n */\nfunction resolveConflicts(entries, cg) {\n  var mappedEntries = {};\n  _.forEach(entries, function(entry, i) {\n    var tmp = mappedEntries[entry.v] = {\n      indegree: 0,\n      \"in\": [],\n      out: [],\n      vs: [entry.v],\n      i: i\n    };\n    if (!_.isUndefined(entry.barycenter)) {\n      tmp.barycenter = entry.barycenter;\n      tmp.weight = entry.weight;\n    }\n  });\n\n  _.forEach(cg.edges(), function(e) {\n    var entryV = mappedEntries[e.v];\n    var entryW = mappedEntries[e.w];\n    if (!_.isUndefined(entryV) && !_.isUndefined(entryW)) {\n      entryW.indegree++;\n      entryV.out.push(mappedEntries[e.w]);\n    }\n  });\n\n  var sourceSet = _.filter(mappedEntries, function(entry) {\n    return !entry.indegree;\n  });\n\n  return doResolveConflicts(sourceSet);\n}\n\nfunction doResolveConflicts(sourceSet) {\n  var entries = [];\n\n  function handleIn(vEntry) {\n    return function(uEntry) {\n      if (uEntry.merged) {\n        return;\n      }\n      if (_.isUndefined(uEntry.barycenter) ||\n          _.isUndefined(vEntry.barycenter) ||\n          uEntry.barycenter >= vEntry.barycenter) {\n        mergeEntries(vEntry, uEntry);\n      }\n    };\n  }\n\n  function handleOut(vEntry) {\n    return function(wEntry) {\n      wEntry[\"in\"].push(vEntry);\n      if (--wEntry.indegree === 0) {\n        sourceSet.push(wEntry);\n      }\n    };\n  }\n\n  while (sourceSet.length) {\n    var entry = sourceSet.pop();\n    entries.push(entry);\n    _.forEach(entry[\"in\"].reverse(), handleIn(entry));\n    _.forEach(entry.out, handleOut(entry));\n  }\n\n  return _.map(_.filter(entries, function(entry) { return !entry.merged; }),\n    function(entry) {\n      return _.pick(entry, [\"vs\", \"i\", \"barycenter\", \"weight\"]);\n    });\n\n}\n\nfunction mergeEntries(target, source) {\n  var sum = 0;\n  var weight = 0;\n\n  if (target.weight) {\n    sum += target.barycenter * target.weight;\n    weight += target.weight;\n  }\n\n  if (source.weight) {\n    sum += source.barycenter * source.weight;\n    weight += source.weight;\n  }\n\n  target.vs = source.vs.concat(target.vs);\n  target.barycenter = sum / weight;\n  target.weight = weight;\n  target.i = Math.min(source.i, target.i);\n  source.merged = true;\n}\n"]},"metadata":{},"sourceType":"script"}